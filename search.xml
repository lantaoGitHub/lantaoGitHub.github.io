<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lock总结]]></title>
    <url>%2F2019%2F06%2F14%2FLock%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Lock在我们日常研发中经常会使用到，比如ReenTrantLock，ReentrantReadWriteLock，StampedLock (JDK1.8新增)， 下面就详细介绍一下它们的使用方法。 ReenTrantLockReenTrantLock支持公平锁和非公平锁,也是独占锁,下面来说一下ReenTrantLock下的方法和使用。 lock：获取阻塞锁。 123456789101112// 默认是费公平锁，可自定，在参数中增加 true-公平 false-非公平ReenTrantLock lockObjcet = new ReenTrantLock();try &#123; // 获取锁 ，如果获取不到则阻塞线程 lockObjcet.lock(); // 同步代码块&#125; catch (Exception e) &#123; &#125; finally &#123; // 释放锁 lockObjcet.unLock();&#125; tryLock：获取非阻塞锁，如果无法获取到锁，返回false，获取到了返回true。 123456ReenTrantLock lock = new ReenTrantLock();if (lock.tryLock()) &#123; // 获取到了锁&#125; else &#123; // 没有获取到锁&#125; tryLock(time)：获取非阻塞超时锁，在time时间内如果获取到了锁，返回true，获取不到锁返回false。 1234567ReenTrantLock lock = new ReenTrantLock();// 获取锁，如果在指定时间内还未获得，则返回falseif (lock.tryLock(100)) &#123; // 获取到了锁&#125; else &#123; // 没有获取到锁&#125; lockInterruptibly()：获取可中断锁，和lock区别就是在获取锁的过程中可以中断线程。 unlock()：解锁 boolean isHeldByCurrentThread()：判断锁是否是当前线程持有，是返回true，不是返回false。 boolean isLocked()：判断锁是否被获取或占用。 boolean isFair()：是否是公平锁，是 返回true， 不是返回false。 Thread getOwner()：获取当前锁的拥有者， 如果有拥有者则返回拥有者，如果没有返回null。 boolean hasQueuedThreads()：判断是否有等待线程，如果有则返回true，反之false。 boolean hasQueuedThread(Thread thread)：判断入参的线程是否存在于等待队列中，如果存在则返回true，反之false。 int getQueueLength()：获取等待队列中线程总数。 Collection getQueuedThreads()：获取等待队列中的所有线程。 boolean hasWaiters(Condition condition)：否有线程在与此锁关联的给定条件上等待，有返回true 反之 false。 int getWaitQueueLength(Condition condition)：获取被参数条件等待的线程总数。 Collection getWaitingThreads(Condition condition)：获取当前锁的条件等待的所有线程. ReentrantReadWriteLock读写锁： 读锁可以多线程一起获取，写锁只有一个线程可以获取，读写锁支持公平锁和非公平锁，支持重入锁。 读锁： 可以被多个线程共同获取锁，同时进入代码块。 写锁：只允许一个线程获取，如果当前线程获取到写锁后，发现有线程获取了读锁，并且不是当前线程，这时当前线程就进入等待状态。 代码示例： 123456// 读写锁private ReadWriteLock rw = new ReentrantReadWriteLock();// 读锁 共享锁private Lock r = rw.readLock();// 写锁 排它锁private Lock w = rw.writeLock(); WriteLock lock()：写锁为独占锁，当线程A获取到了写锁时任何线程都不能获取到读锁和写锁，如果线程A获取到了写锁，但是读锁已经被线程B获取并且未释放，这时就需要将线程A状态改为等待，等待线程B释放了写锁再继续执行。 unlock()：解锁。 ReadLock lock()： 加锁。 unlock()： 解锁。 StampedLock (JDK1.8新增)StampedLock： 读写锁，但是StampedLock比ReenTrantReadWriteLock更块,但是StampedLock用于乐观读锁，悲观读锁，和写锁，StampedLock不支持重入锁，StampedLock 的悲观读锁、写锁都不支持条件变量。 tryOptimisticRead：乐观读。 readLock：悲观读。 writeLock：悲观写。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738/** * @Auther: lantao * @Date: 2019-05-05 17:55 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class StampedLockTest &#123; static StampedLock s =new StampedLock(); public static void main(String[] args) &#123; // 悲观读 long l = s.readLock(); // 释放悲观读 s.unlockRead(l); // 悲观写 long l1 = s.writeLock(); // 释放悲观写 s.unlockWrite(l1); // 乐观读 升级 悲观读 long l2 = s.tryOptimisticRead(); //验证是否被修改 如果返回false 会释放 l2，所以后续直接释放l3即可 if (!s.validate(l2))&#123; // 升级悲观读 long l3 = s.readLock(); s.unlockRead(l3); &#125; &#125;&#125; ConditionnCondition： Lock 的条件 ,其实初始化的是ConditionObject， ConditionObject是Condition的实现，singal和signlAll的时候需要在获取锁后。 await()： 线程等待，相当于Objcet的wait()方法。 awaitNanos(time)： 等待一定时间，如果超过则继续执行，相当于Object的wait(time)方法。 signal()： 随机唤醒一个被Condition.await()的线程，相当于Object的notify()方法。 signalAll()： 唤醒全部被Condition.await()的线程，相当于Object的notifyAll()方法。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @Auther: lantao * @Date: 2019-04-15 14:49 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁 执行singal和notify的时候也需要在等待获取锁 */public class LockCondition &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition a = lock.newCondition(); public static Condition b = lock.newCondition(); public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); a.await(); System.out.println(Thread.currentThread().getName() + " 的 a conndition 被唤醒了"); b.await(); System.out.println(Thread.currentThread().getName() + " 的 b conndition 被唤醒了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; Runnable runnable1 = () -&gt; &#123; try &#123; lock.lock(); System.out.println("线程" +Thread.currentThread().getName() + " 开始执行a condition sinalAll"); a.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; Runnable runnable2 = () -&gt; &#123; try &#123; lock.lock(); System.out.println("线程" +Thread.currentThread().getName() + " 开始执行b condition sinalAll"); b.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; new Thread(runnable,"Thread1").start(); new Thread(runnable,"Thread2").start(); Thread.sleep(100); new Thread(runnable1,"Thread3").start(); Thread.sleep(100); new Thread(runnable2,"Thread4").start(); &#125;&#125;// 执行结果Thread1Thread2线程Thread3 开始执行a condition sinalAllThread1 的 a conndition 被唤醒了Thread2 的 a conndition 被唤醒了线程Thread4 开始执行b condition sinalAllThread1 的 b conndition 被唤醒了Thread2 的 b conndition 被唤醒了]]></content>
      <categories>
        <category>Lock锁</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程的宏观和微观视角]]></title>
    <url>%2F2019%2F02%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8F%E8%A7%82%E5%92%8C%E5%BE%AE%E8%A7%82%E8%A7%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能； 微观视角 可见性: 一个线程对共享变量的修改，另外一个线程能够立刻感知到，我们称为可见性; 原子性： 一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性； 有序性： 就是我们代码的执行顺序，依赖等。(指令重排导致顺序被打乱); &#8195;&#8195;线程工作内存： 是指 Cpu 的 ‘寄存器’ 和 ‘高速缓存’，线程的 工作内存/本地内存 是指cpu的寄存器和高速缓存的抽象描述,数据读取顺序优先级 是：寄存器－&gt;高速缓存－&gt;内存 宏观视角 安全性： 安全性我认为其实是包含了原子性丶可见性和有序性的，是一个总的概念，在程序开发的时候首先要注重安全性，会在下面详细解释这三点； 活跃性活跃性告诉我们的是要避免死锁，饥饿和活锁； — 死锁：这个都不陌生，线程A持有1锁，等待获取2锁，线程B持有2锁，等待获取1锁，这就是个典型的死锁，就就是阻塞了。 — 饥饿：饥饿当多线程获取锁都得时候，总有线程没有机会获取到锁，出现饥饿的三中情况：1-高优先级的线程吞噬了低优先级线程的CPU使用权 2-线程被一直阻塞(比如Thread.Sleep) 3-等待线程永远不被唤醒，也可以理解为锁的优先级，我们常用的synchronized就是非公平锁，例如线程A，B,C按顺序获取锁1，首先是A获取到了锁，执行完临界区代码释放了锁，这是线程D来了直接获取到了锁，这就是非公平锁；ReentrantLock()默认是非公平锁，可以在ReentractLock（true）创建公平锁。 — 活锁：在生活中A和B同时进入左手门，为了不发生碰撞，A和B互相礼让同时进入了右手门，为了不发生碰撞又进入了左手们会一直循环下去，**实例代码找到适用的场景在增加。 性能1：延迟: 延迟就是指一个请求调用到返回所使用的时间，时间越短，程序的处理的就越快，性能也就会高；2：吞吐量: 吞吐量就是值在单位时间内(秒)处理的请求数量，吞吐量越大，程序处理的请求就越多，性能也越好； 可见性：线程工作空间导致可见性问题&#8195;&#8195;例如：线程A在主存中年将变量age=0拉去到自己的工作内存中，然后做了age = 5，当然这个操作是在cpu的寄存器中进行的，然后写会高速缓存中，这时线程A的高速缓存还未执行同步主内存的操作，线程B又将age=0从主存拉取到了线程B的工作内存中，导致A线程已经更新但是B线程看不到的可见性问题； 原子性：线程切换导致原子性问题 ++count&#8195;&#8195;例如：当线程A从主内存中将共享变量Count加载到线程A的工作内存后，发生了线程切换，这个时候线程B也将共享变量Count从主内存加载到了线程B的工作内存，这时线程A和B的工作内存中count都是0，线程B执行了Count = Count + 1,然后写回到主内存，这时候线程切换完成，回到了线程A再次执行 Count = Count + 1,再将线程A工作内存计算过的count写回主内存，现在我们得到的主内存呢中Count值是1而不是2。 有序性：指令重排导致有序性问题；在这里讲一个例子，就是获取单例双重检查锁(double-checked locking)判断： 123456789101112131415161718192021222324/** * @Auther: lantao * @Date: 2019-03-28 14:32 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class Test1 &#123; private DoMain doMain; public DoMain getDoMain()&#123; if(doMain == null)&#123; synchronized (this.getClass())&#123; if(doMain == null)&#123; doMain = new DoMain(""); &#125; return doMain; &#125; &#125;else&#123; return doMain; &#125; &#125;&#125; &#8195;&#8195;在上边的代码中在synchronized内和外都有一个if判断，判断doMain是否为null操作，有很多人对synchronized中的if null判断不理解，其实可以这样想，线程A和线程B都执行到了synchronized这里进行竞争锁，结果A得到锁，判断if null，结果还未实例化，继续进行实例化，然后return对象并释放锁，这时线程B获取到了锁进入if null判断，发现doMain已经被线程A实例化过了，直接返回实例即可，第二个if null的作用就在这里； 看上去上边的代码是完美的，但是new的操作上我们理解是： 创建内存M 在内存M上初始化doMain对象 将内存M的地址指向变量doMain 但是实际上优化后(指令重排)的执行路径可能是这样的： 创建内存M 将内存M的地址指向变量doMain 将内存M的地址指向变量doMain]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>可见性/原子性/有序性</tag>
        <tag>安全性/活跃性/性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized总结]]></title>
    <url>%2F2019%2F01%2F20%2FSynchronized%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等,下 面我们就来介绍一下Synchronized的流程和使用方法； Synchronized的升级过程Synchronized的升级顺序是 无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁，顺内不可逆，(Java SE 1.6中为了减少获得锁和释放锁带来的 性能消耗而引入的偏向锁和轻量级锁) 偏向锁：当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁，以后该线程在进入和退出该同步代码块时不需要花费 CAS 操作来加锁和解锁，而只需简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁(当前线程的线程ID)，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果偏向锁标识是1，则使用 CAS 进行锁获取，偏向锁标识不是1，则尝试使用 CAS 将对象头的偏向锁指向当前线程，上述两种CAS获取锁的操作，如果CAS操作成功则获取到了偏向锁，失败则代表出现了锁竞争，需要锁撤销操作。 锁撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等待拥有偏向锁的线程到达全局安全点（在这个时间点上没有字节码正在执行），会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁的对象的对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行(判断是否需要持有锁)，遍历偏向对象的锁记录，查看使用情况，如果还需要持有偏向锁，则偏向锁升级为轻量级锁，如果不需要持有偏向锁了，则将锁对象恢复成无锁状态，最后唤醒暂停的线程。 轻量级锁：线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，自旋有一定次数，如果超过设置自旋的次数则升级到重量级锁，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。 轻量级锁解锁：轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 例如：T1线程持有锁，T2线程自旋，但是T2线程自旋最大次数已经过了，则自旋失败，进行锁升级到重量级锁，T2线程阻塞，这时T1执行完了同步代码块，进行轻量级锁解锁，但是这时Mark Word中的标志位已经从原来的00(偏向锁)变成了10(中练级锁)，解锁会CAS失败，T1会进行解锁(释放监视器，释放锁)，并唤醒线程T2. 重量级锁：Synchronized是非公平锁,Synchronized在线程进入阻塞队列时，等待的线程会先尝试获取锁，如果获取不到就进入阻塞队列，这明显对于已经进入队列的线程是不公平的。 优缺点： 锁 优点 缺点 场景 偏向锁 加解锁不需要过多的资源消耗，和非同步方法的相比仅仅是纳秒的差距 如果存在所竞争，会有额外的锁撤销操作 适用于只有一个线程访问的场景 轻量级锁 竞争线程不会阻塞，会自旋，减少了上线文切换。 如果始终得不到锁，会消耗cpu资源 追求响应时间，同步代码块多为计算，执行快的场景 重量级锁 没啥优点 线程阻塞响应时间慢 同步代码块执行时间较长的场景使用 流程图： Synchronized 的使用1: Synchronized 是java的内置锁，也是排它锁和非公平锁，排它锁也就是当前线程获取锁后，其他线程都会阻塞挂起 ，非公平锁是在线程后去锁的时候会先尝试后去锁，获取不到在进行阻塞。 2: Synchronized 是如何保证 ‘原子性’ 的？是因为进入 Synchronized 块的内存语义是把 Synchronized 块内使用的 ‘工作内存清除’， 这样在使用共享变量时就会直接存主内存中获取并复制到工作你内存中，在退出 Synchronized 语句块时 会把 工作内存中计算过的 ‘共享变量’ 更新到主内存中。 3: 获取到 Synchronized 锁 ，都是 ‘对象锁’而非’代码块锁’ (锁的都是对象或类，而不是某个方法)，因此 Synchronized 是具有可重入性，在获取到该对象锁后可以不用再次获取该对象其他方法的锁，直接进入。 4: 如果是 Synchronized 用在 static 上， 就代表是类锁(.class)，无论创建多少个对象都不可行； 使用方法：1234567891011121314// 代码块 锁的是括号里的对象 Synchronized(需要锁的对象)&#123; //临界区 &#125; // 普通方法 锁的是当前对象 public Synchronized void test()&#123; //是临界区 &#125; // 静态方法 锁的是当前的类(.class) public static Synchronized void test()&#123; //临界区 &#125; wait/notify/notifyAll 的使用注意：wait和sleep区别在于wait会释放锁， 但是sleep不会释放锁 ，sleep会导致线程阻塞挂起。 wait/wait(timeout)/notify/notifyAll 方法仅可以在获取到锁后才可以使用。 解释：wait： 线程等待。 wait(time)： 线程等待，如果时间超过了设置的time，则继续执行。 notify： 随机唤醒一个等待的线程。 notifyAll： 唤醒全部等待线程。 代码演示：12/** * @Auther: concurrenncy @Date: 2019-03-25 16:43 @Company: 随行付支付有限公司 @maill: lan_tao@suixingpay.com @Description: wait 和 sleep 区别在于 wait会释放锁， 但是 sleep 不会 ，sleep会导致线程阻塞挂起 / public class WaitAndNotifyTest { private static Object obj = new Object(); public static void main(String[] args) { // 创建线程 thread1 Thread thread1 = new Thread(new Runnable() { @Override public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; begin wait...&quot;); synchronized (obj) { obj.wait(); } System.out.println(Thread.currentThread().getName() + &quot; end wait...&quot;); } catch (Exception e) { e.printStackTrace(); } } }, &quot;thread1&quot;); // 创建线程 thread2 Thread thread2 = new Thread(new Runnable() { @Override public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; begin wait...&quot;); synchronized (obj) { obj.wait(); } System.out.println(Thread.currentThread().getName() + &quot; end wait...&quot;); } catch (Exception e) { e.printStackTrace(); } } }, &quot;thread2&quot;); // 启动 thread1.start(); thread2.start(); try { // 睡眠一秒 Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } // 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常 synchronized (obj) { // 唤醒 使用 obj 调用 wait 方法的其中一个线程 (随机) obj.notify(); // 唤醒 使用呢 obj 调用 wait 方法的所有线程 obj.notifyAll(); } } } 12]]></content>
      <categories>
        <category>Synchronized锁</category>
      </categories>
      <tags>
        <tag>偏向锁/轻量级锁/重量级锁</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
</search>
