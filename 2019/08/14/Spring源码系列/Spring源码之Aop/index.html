<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="最怕一生碌碌无为，还说平凡难得可贵">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Spring源码之Aop |
    
    七英里的旅行</title>
  
    <link rel="shortcut icon" href="/source">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-Spring源码系列/Spring源码之Aop" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  

<!-- 目录内容 -->
        
            
            <p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
            <span class="btn-bg"></span>
            <span class="btn-text">文章导航</span>
            </p>

            <div id="toc-article" class="toc-article">
                <span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
                <strong class="toc-title">文章目录</strong>

                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Jdk动态代理和CGLIB代理"><span class="toc-text">1 Jdk动态代理和CGLIB代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jdk动态代理"><span class="toc-text">Jdk动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#描述"><span class="toc-text">描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB代理"><span class="toc-text">CGLIB代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#描述-1"><span class="toc-text">描述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-示例代码"><span class="toc-text">2 示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-AspetJTest注解"><span class="toc-text">2.1 AspetJTest注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Aop配置类"><span class="toc-text">2.2 Aop配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-注解使用类"><span class="toc-text">2.3 注解使用类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-测试类"><span class="toc-text">2.4 测试类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Aop-xml配置类"><span class="toc-text">2.5 Aop xml配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-执行结果"><span class="toc-text">2.6 执行结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-XMl标签解析源码讲解"><span class="toc-text">3 XMl标签解析源码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-解析Aop配置xml"><span class="toc-text">3.1 解析Aop配置xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册-AnnotationAwareAspectJAutoProxyCreator"><span class="toc-text">注册 AnnotationAwareAspectJAutoProxyCreator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SpringBoot-自动配置Aop"><span class="toc-text">4 SpringBoot 自动配置Aop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Aop实现源码分析"><span class="toc-text">5 Aop实现源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-术语定义"><span class="toc-text">5.1 术语定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-AnnotationAwareAspectJAutoProxyCreator类解析"><span class="toc-text">5.2 AnnotationAwareAspectJAutoProxyCreator类解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-postProcessBeforeInstantiation方法解析"><span class="toc-text">5.2.1 postProcessBeforeInstantiation方法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-postProcessAfterInitialization方法解析"><span class="toc-text">5.2.2 postProcessAfterInitialization方法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取增强器"><span class="toc-text">获取增强器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-2-2-1-findCandidateAdvisors方法获取全部增强器"><span class="toc-text">5.2.2.1 findCandidateAdvisors方法获取全部增强器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-2-2-2-findAdvisorsThatCanApply匹配适用bean的增强器"><span class="toc-text">5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-创建代理"><span class="toc-text">6 创建代理</span></a></li></ol></li></ol>
           </div>

           <script type="text/javascript">
            function showToc(){
                var toc_article = document.getElementById("toc-article");
                var show_toc_btn = document.getElementById("show-toc-btn");
                toc_article.setAttribute("style","display:block");
                show_toc_btn.setAttribute("style","display:none");
                };
            function showBtn(){
                var toc_article = document.getElementById("toc-article");
                var show_toc_btn = document.getElementById("show-toc-btn");
                toc_article.setAttribute("style","display:none");
                show_toc_btn.setAttribute("style","display:block");
                };
           </script>
             
        <!-- 目录内容结束 -->


  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring源码之Aop
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/14/Spring源码系列/Spring源码之Aop/" class="article-date">
  <time datetime="2019-08-13T16:00:00.000Z" itemprop="datePublished">2019-08-14</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring源码/">spring源码</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p>本文主要介绍Spring的<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签，了解spring是如何实现扫描注解进行aop的，主要实现是在 AspectJAutoProxyBeanDefinitionParser的parser方法中，另外这里</p>
<a id="more"></a>

<p>还需要了解一下NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 的关系，如果不清楚的可以看一下<strong>Spring源码之ApplicationContext</strong>中的解释。</p>
<h2 id="1-Jdk动态代理和CGLIB代理"><a href="#1-Jdk动态代理和CGLIB代理" class="headerlink" title="1 Jdk动态代理和CGLIB代理"></a>1 Jdk动态代理和CGLIB代理</h2><p>​        在讲述aop源码之前，需要先了解一下 <strong>Jdk</strong> 动态代理和 <strong>CGLIB</strong> 代理的区别和使用。</p>
<ul>
<li><h3 id="Jdk动态代理"><a href="#Jdk动态代理" class="headerlink" title="Jdk动态代理"></a><strong>Jdk动态代理</strong></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>Jdk动态代理需要目标类至少实现一个接口，在运行时期生成代理类。</p>
</li>
<li><h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a><strong>CGLIB代理</strong></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>CGLIB代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但CGLIB会继承目标对象，需要重写方法，所以目标对象不能为<strong>final</strong>类。</p>
</li>
</ul>
<h2 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2 示例代码"></a>2 示例代码</h2><h3 id="2-1-AspetJTest注解"><a href="#2-1-AspetJTest注解" class="headerlink" title="2.1 AspetJTest注解"></a>2.1 AspetJTest注解</h3><p>示例是基于注解形式，AspetJTest类为注解类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AspetJTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Aop配置类"><a href="#2-2-Aop配置类" class="headerlink" title="2.2 Aop配置类"></a>2.2 Aop配置类</h3><p>Config为Aop的配置类，Pointcut(切点)配置为AspetJTest注解，则所有使用@AspetJTest注解的方法都会被代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Pointcut</span>(<span class="string">"@annotation(AspetJTest)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">Around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入Around方法"</span>);</span><br><span class="line">      Object proceed = point.proceed();</span><br><span class="line">      System.out.println(<span class="string">"退出Around方法"</span>);</span><br><span class="line">      <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入after方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入before方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-注解使用类"><a href="#2-3-注解使用类" class="headerlink" title="2.3 注解使用类"></a>2.3 注解使用类</h3><p>TestService真正的业务类，例如输入插入/删除等，aop代理实现事物。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 13:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@aspetJTest</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入了printInfo方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-测试类"><a href="#2-4-测试类" class="headerlink" title="2.4 测试类"></a>2.4 测试类</h3><p>TestAopMain就是测试类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAopMain</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-bean-aop.xml"</span>);</span><br><span class="line">      TestService bean = classPathXmlApplicationContext.getBean(TestService.class);</span><br><span class="line">      bean.printInfo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Aop-xml配置类"><a href="#2-5-Aop-xml配置类" class="headerlink" title="2.5 Aop xml配置类"></a>2.5 Aop xml配置类</h3><p>Xml配置类，在其中有<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签，使Aop生效，<a href="context:component-scan/" target="_blank" rel="noopener">context:component-scan/</a>开启注解扫描。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller，@Component和@Repository 的注解的类进行扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"lantao.aop"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 只扫描 base-package 的 controller 注解 还有对应的 exclude-filter 标签 排除 ； use-default-filters="false" 和 include-filter 一起使用 和 exclude-filter一起回抛异常--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Component"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-执行结果"><a href="#2-6-执行结果" class="headerlink" title="2.6 执行结果"></a>2.6 执行结果</h3><p>以上代码的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入Around方法</span><br><span class="line">进入before方法</span><br><span class="line">进入了printInfo方法</span><br><span class="line">退出Around方法</span><br><span class="line">进入after方法</span><br></pre></td></tr></table></figure>

<p>在执行TestAopMain类中的main方法时，发现getBean方法返回的并不是目标类，而是目标类的<strong>代理类</strong></p>
<p><img src="/Users/lantao/Downloads/1.jpg" alt></p>
<h2 id="3-XMl标签解析源码讲解"><a href="#3-XMl标签解析源码讲解" class="headerlink" title="3 XMl标签解析源码讲解"></a>3 XMl标签解析源码讲解</h2><h3 id="3-1-解析Aop配置xml"><a href="#3-1-解析Aop配置xml" class="headerlink" title="3.1 解析Aop配置xml"></a>3.1 解析Aop配置xml</h3><p>这里直接从<strong>DefaultBeanDefinitionDocumentReader</strong>类的<strong>doRegisterBeanDefinitions</strong>方法开始讲解，因前边都是xml解析的代码，已经在<strong>Spring源码之XmlBeanFactory</strong>中讲过了，其中<strong>parseBeanDefinitions</strong>方法是做标签解析使用的</p>
<p><strong>DefaultBeanDefinitionDocumentReader . parseBeanDefinitions方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span></span>&#123;</span><br><span class="line">   <span class="comment">//验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">//对默认标签处理</span></span><br><span class="line">               <span class="comment">// 这里只处理 nade namespace 为 http://www.springframework.org/schema/beans 的标签</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//对自定义标签处理 非namespace 为 http://www.springframework.org/schema/beans 的标签 ，会解析 &lt;context:component-scan base-package="lantao.scan"/&gt; 或者自定义 dubbo</span></span><br><span class="line">               <span class="comment">// 或者 aop</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//对自定义标签处理</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接关注<strong>parseCustomElement</strong>方法，<strong>parseDefaultElement</strong>方法处理的是bean标签。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取node的 NameSpaceURI</span></span><br><span class="line">   String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">   <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析自定义标签 需要在 Meta-inf 文件加 增加 spring.handlers 文件 例如：http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span></span><br><span class="line">   <span class="comment">// 根据指定的 NameSpaceURI 获取 NamespaceHandler  handler可以参考spring.handlers文件</span></span><br><span class="line">   <span class="comment">// abstract NamespaceHandlerSupport 实现了 NamespaceHandler 接口，继而实现了 NamespaceHandler 的两个个方法（parser，docreate），自定义handler 需要实现 NamespaceHandlerSupport 类</span></span><br><span class="line">   <span class="comment">// 进行 NamespaceHandler 类的 init 方法的 实现， 主要是做注册 BeanDefinitionParser（ registerBeanDefinitionParser ） ， 需要自定义解析类 继承 BeanDefinitionParser 类</span></span><br><span class="line">   NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析操作</span></span><br><span class="line">   <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要的工作就是机械<strong>NamespaceHandler</strong>,这里通过<strong>NamespaceHandlerResolver的resolve方法</strong>来解析各种<strong>NamespaceHandler</strong>,<strong>最后进行调用解析类的parse方法进行解析</strong>，接下来看一下resolve方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里获取的是所有注册到 handlerMappings 中的  NamespaceHandler ，</span></span><br><span class="line">   <span class="comment">// 就是 resource/META-INF/spring.handler 中的  key就是namespaceUri ，</span></span><br><span class="line">   <span class="comment">// 这些类都继承了 NamespaceHandlerSupport 实现了init方法 在init方法中进行 BeanDefinitionParse 的注册</span></span><br><span class="line">   Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">   <span class="comment">// 通过 namespaceUri 在 handlerMappings 中获取对应的处理器或者 className 如果是初始化过的就直接返回，反之进行类初始化工作</span></span><br><span class="line">   Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">   <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">      <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      String className = (String) handlerOrClassName;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">         <span class="comment">// 判断实例化的类的超类或者超级接口 是否是 NamespaceHandler</span></span><br><span class="line">         <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line">                  <span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">         <span class="comment">// 注册 自定义标签所对应的 解析策略类  解析策略类都继承了 BeanDefinitionParser ，比如 ComponentScanBeanDefinitionParser</span></span><br><span class="line">         namespaceHandler.init();</span><br><span class="line">         <span class="comment">// 放入缓存中</span></span><br><span class="line">         handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">         <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Could not find NamespaceHandler class ["</span> + className +</span><br><span class="line">               <span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Unresolvable class definition for NamespaceHandler class ["</span> +</span><br><span class="line">               className + <span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>resolve方法</strong>中一共做了<strong>两件事情</strong></p>
<p>1: 调用<strong>getHandlerMappings</strong>方法解析<strong>resources 中的 META-INF/spring.handlers</strong>文件，读取<strong>各种处理类</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.handlers:</span><br><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>2：进行<strong>处理类的实例化</strong>操作，然后调用<strong>处理类</strong>的<strong>init</strong>方法，<strong>进行解析类(Parser)的注册</strong>，并将<strong>实例化的处理类进行缓存处理</strong>，以备下次使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resolve</strong>方法理解后在回到<strong>主方法(parseDefaultElement)</strong>中,在实例化和解析操作后，调用了<strong>处理类的parse</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 在 NamespaceHandlerSupport 中的 parser 集合中获取 BeanDefinitionParser 的实现类 进行 parser</span></span><br><span class="line">   BeanDefinitionParser parser = findParserForElement(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> (parser != <span class="keyword">null</span> ? parser.parse(element, parserContext) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>findParserForElement</strong>方法中通过<strong>标签(aspectj-autoproxy)</strong>进行获取<strong>对应的处理类(AspectJAutoProxyBeanDefinitionParser)</strong>，<strong>处理类的注册在实例化处理类后调用init方法已经完成，</strong> 接下来看一下 解析类的 <strong>parse</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">  <span class="comment">// 扩展BeanDefinition 处理 子节点 &lt;aop:include/&gt;</span></span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册 AnnotationAwareAspectJAutoProxyCreator"></a>注册 AnnotationAwareAspectJAutoProxyCreator</h3><p>在解析<strong>(parse)</strong>方法中,首先是注册了<strong>AnnotationAwareAspectJAutoProxyCreator</strong>类，这个类是处理注解拦截的代理类，然后又扩展了刚刚注册的<strong>AnnotationAwareAspectJAutoProxyCreator</strong>，对xml中<a href="aop:aspectj-autoproxy" target="_blank" rel="noopener">aop:aspectj-autoproxy</a>标签的子节点<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>进行了处理。</p>
<p>首先看一下注册AnnotationAwareAspectJAutoProxyCreator的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">   BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">   <span class="comment">// 处理 proxy-target-class 和  expose-proxy属性</span></span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">   <span class="comment">// 注册 BeanComponentDefinition</span></span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分为三个步骤</p>
<p>1：通过调用<strong>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</strong>方法进行注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>类。</p>
<p>2：处理<strong>aop:aspectj-autoproxy</strong>标签的 <strong>proxy-target-class</strong> 和 <strong>expose-proxy</strong> 属性。</p>
<p>3：注册 <strong>BeanComponentDefinition</strong> ，就是对 <strong>AnnotationAwareAspectJAutoProxyCreator</strong> 的封装。具体作用后续补上</p>
<p>先来看第一步注册的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">      BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">      <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">         <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">         <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">         <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">            apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">   beanDefinition.setSource(source);</span><br><span class="line">   beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">   <span class="comment">// 定义角色，完全内部使用</span></span><br><span class="line">   beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">   registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">   <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就没什么好说的，先判断一下是否已经注册，如果已经注册，则<strong>判断优先级</strong>，如果已注册优先级高则直接结束，反之直接创建<strong>RootBeanDefinition</strong>，通过调用<strong>DefaultListableBeanFactory的registerBeanDefinition方法进行bean注册</strong>。</p>
<p>优先级判断代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="comment">// Set up the escalation list...</span></span><br><span class="line">   APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">   APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">   APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPriorityForClass</span><span class="params">(@Nullable String className)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; APC_PRIORITY_LIST.size(); i++) &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = APC_PRIORITY_LIST.get(i);</span><br><span class="line">      <span class="keyword">if</span> (clazz.getName().equals(className)) &#123;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">         <span class="string">"Class name ["</span> + className + <span class="string">"] is not a known auto-proxy creator class"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册说完了继续看一下对 <strong>proxy-target-class</strong> 和 <strong>expose-proxy</strong> 属性的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, @Nullable Element sourceElement)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 对标签 proxy-target-class 的处理，使用方法 &lt;aop:config proxy-target-class = "true"&gt; 或 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 使用</span></span><br><span class="line">      <span class="comment">// 其作用是 强制使用 CGLIB 代理，设置&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;  ，或需要使用CGLIB 和 @Aspectj自动代理支持 属性 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</span></span><br><span class="line">      <span class="comment">// JDK动态代理需要至少实现一个借口  CGLIB 不需要实现接口</span></span><br><span class="line">      <span class="keyword">boolean</span> proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">      <span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">         AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对 expose-proxy 的处理 其作用是实现 目标对象内部方法调用可实现切面的增强</span></span><br><span class="line">      <span class="comment">// 例如 例如 A类中 c方法 调用 A类中的 d方法是无法实时切面增强的，需要设置 &lt;aop:aspectj-autoproxy expose-proxy="true"/&gt; 例如 d 方法 有 @Transaction 注解则失效</span></span><br><span class="line">         <span class="keyword">boolean</span> exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">      <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">         AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>proxy-target-class</strong>属性的作用是强制使用 CGLIB 代理。</p>
<p><strong>expose-proxy</strong>属性的作用是<strong>目标对象内部方法调用可实现切面的增强</strong>,例如Test类中的A，B方法，A调用B方法进行数据库save操作，B方法上有<strong>@Transactional</strong>注解，如果A直接调用B方法则事物是不起作用的，需要设置<strong>expose-proxy=true</strong>，然后使用 <strong>((A)AopContext.currentProxy()).b()</strong> 调用方式。</p>
<p>注册整体完成后，看一下主方法的<strong>extendBeanDefinition</strong>方法，扩展BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendBeanDefinition</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   BeanDefinition beanDef =</span><br><span class="line">      parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">   <span class="keyword">if</span> (element.hasChildNodes()) &#123;</span><br><span class="line">      addIncludePatterns(element, parserContext, beanDef);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIncludePatterns</span><span class="params">(Element element, ParserContext parserContext, BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line">   ManagedList&lt;TypedStringValue&gt; includePatterns = <span class="keyword">new</span> ManagedList&lt;&gt;();</span><br><span class="line">   NodeList childNodes = element.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">      Node node = childNodes.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">         Element includeElement = (Element) node;</span><br><span class="line">         TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(includeElement.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">         valueHolder.setSource(parserContext.extractSource(includeElement));</span><br><span class="line">         includePatterns.add(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!includePatterns.isEmpty()) &#123;</span><br><span class="line">      includePatterns.setSource(parserContext.extractSource(element));</span><br><span class="line">      beanDef.getPropertyValues().add(<span class="string">"includePatterns"</span>, includePatterns);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>extendBeanDefinition</strong>方法主要是对注册的<strong>AnnotationAwareAspectJAutoProxyCreator</strong>就行扩充，如果<strong>aop:aspectj-autoproxy</strong>标签还有子标签，也就是<strong><a href="aop:include/" target="_blank" rel="noopener">aop:include/</a></strong>标签，则会作getPropertyValues.add的操作，这里的<strong><a href="aop:include/" target="_blank" rel="noopener">aop:include/</a></strong>标签如果存在对于解析@Aspect标注的类时有一个match的动作，这里的内容会在<strong>buildAspectJAdvisors</strong>方法中详细讲解。 好了到这里整个Xml的解析注册就完成了，接下来看一下具体的实现。</p>
<h2 id="4-SpringBoot-自动配置Aop"><a href="#4-SpringBoot-自动配置Aop" class="headerlink" title="4 SpringBoot 自动配置Aop"></a>4 SpringBoot 自动配置Aop</h2><h2 id="5-Aop实现源码分析"><a href="#5-Aop实现源码分析" class="headerlink" title="5 Aop实现源码分析"></a>5 Aop实现源码分析</h2><h3 id="5-1-术语定义"><a href="#5-1-术语定义" class="headerlink" title="5.1 术语定义"></a>5.1 术语定义</h3><ol>
<li>ClassFilter：类过滤器</li>
<li>Advisor：通知器</li>
<li>targetClass：目标类，或称被代理的原始类</li>
<li>Advice：通知，或称拦截器，也就是要增强的代码逻辑</li>
<li>MethodMatcher：方法匹配器</li>
<li>Pointcut：切点，由<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>组成</li>
</ol>
<p><code>ClassFilter</code>用于约束一个<code>Advisor(通知器)</code>，与指定的<code>targetClass</code>是否匹配,只有匹配的前提下,<code>Advisor</code>才能使用其内部持有的<code>Advice(增强器)</code>对<code>targetClass</code>进行增强。</p>
<p>​        <strong>Advisor</strong>分两大类：<strong>IntroductionAdvisor</strong>（引介通知器）和<strong>PointcutAdvisor</strong>（切点通知器）。两类<strong>Advisor</strong>都是为了增强<strong>targetClass</strong>，但是作用不一样。<strong>IntroductionAdvisor</strong>主要为了给<strong>targetClass</strong>追加接口（或者说追加更多的方法），这种增强属于<code>类级别</code>的增强；而<strong>PointcutAdvisor</strong>主要为了拦截方法，这种增强属于<code>方法级别</code>的增强。</p>
<p>​        正是由于两类Advisor的增强级别不同，而导致了对<strong>ClassFilter</strong>的使用方式不同。<strong>IntroductionAdvisor</strong>进行类级别增强，因此只需要直接持有<strong>ClassFilter</strong>即可；而<strong>PointcutAdvisor</strong>进行方法级别增强，因此需要同时使用<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>（方法匹配器）。PointcutAdvisor内部持有一个<strong>Pointcut</strong>，而<strong>Pointcut就是由ClassFilter和MethodMatcher组成的</strong>。</p>
<h3 id="5-2-AnnotationAwareAspectJAutoProxyCreator类解析"><a href="#5-2-AnnotationAwareAspectJAutoProxyCreator类解析" class="headerlink" title="5.2 AnnotationAwareAspectJAutoProxyCreator类解析"></a>5.2 AnnotationAwareAspectJAutoProxyCreator类解析</h3><p>​        在上面的xml解析<strong>aop:aspectj-autoproxy</strong>标签时，一直都在说注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>，其实它是继承了<strong>InstantiationAwareBeanPostProcessor -&gt; BeanPostProcessor</strong>的，继承了 <strong>InstantiationAwareBeanPostProcessor</strong> 会在<code>实例化之前执行</code><strong>postProcessBeforeInstantiation</strong>和<strong>postProcessAfterInstantiation</strong>方法，但同时它也<code>间接性</code>继承了<strong>BeanPostProcessor</strong>，也会在<code>初始化前后执行</code> <strong>postProcessBeforeInstantiation</strong> 和 <strong>postProcessAfterInitialization</strong> 方法，在<strong>createBean</strong>方法中有这么一方法<strong>resolveBeforeInstantiation</strong>，它就是在<code>实例化</code>之前执行的<strong>InstantiationAwareBeanPostProcessor</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">************</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">// 给BeanPostProcessors一个返回代理而不是目标bean实例的机会</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">**********</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-postProcessBeforeInstantiation方法解析"><a href="#5-2-1-postProcessBeforeInstantiation方法解析" class="headerlink" title="5.2.1 postProcessBeforeInstantiation方法解析"></a>5.2.1 postProcessBeforeInstantiation方法解析</h4><p>​        创建代理的真正方法就是<strong>AbstractAutoProxyCreator.postProcessAfterInitialization</strong>方法或 <strong>postProcessBeforeInstantiation</strong>方法。<strong>AbstractAutoProxyCreator</strong> 是 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>的超类。下面先看一下 <strong>AbstractAutoProxyCreator.postProcessBeforeInstantiation</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断beanName是否为空 和 targetSoucedBeans是否包含beanName</span></span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种</span></span><br><span class="line">			<span class="comment">// shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor所属的bean和入参bean是否是同一个，如果是则不用增强反之可以，</span></span><br><span class="line">			<span class="comment">// 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean</span></span><br><span class="line">			<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">		<span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">		<span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果有自定义的targetSouce 在这里就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化</span></span><br><span class="line">		TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">		<span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">				<span class="comment">// 缓存</span></span><br><span class="line">				<span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around 等</span></span><br><span class="line">			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 根据增强器创建代理</span></span><br><span class="line">			Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">			<span class="comment">// 缓存</span></span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>postProcessBeforeInstantiation</code>方法主要做了一下几件事情：</p>
<p>1: 判断<strong>beanName</strong>是否为空 和 <strong>targetSoucedBeans</strong>是否包含<strong>beanName</strong>。</p>
<p>2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 <strong>shouldSkip</strong> ，这里通过调用子类 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> 的 <strong>shouldSkip</strong> 方法，通过获取全部的<strong>Advisor</strong>，来判断<strong>Advisor</strong>所属的<strong>bean</strong>和入参<strong>bean</strong>是否是同一个，如果是<strong>(如果是则就是代表该bean是配置类)</strong>则不可以增强反之可以，然后会调用 <strong>super.shouldSkip</strong> 排除尾部是 .ORIGINA 结尾的<strong>bean</strong>。</p>
<p>3: 获取自定义的TargetSouce ,如果存在就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化。</p>
<p>4: 如果存在自定义的TargetSouce，则获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around ，找到符合该bean的增强器。</p>
<p>5: 根据查询出来的增强器创建代理并返回。</p>
<p>上述是对存在<strong>TargetSource</strong>情况的描述，下面我们看一下不存在的情况</p>
<h4 id="5-2-2-postProcessAfterInitialization方法解析"><a href="#5-2-2-postProcessAfterInitialization方法解析" class="headerlink" title="5.2.2 postProcessAfterInitialization方法解析"></a>5.2.2 postProcessAfterInitialization方法解析</h4><p>接下来看<strong>AbstractAutoProxyCreator</strong>类中的<strong>postProcessAfterInitialization</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">      <span class="comment">//防止 bean 多次被增强。</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">        <span class="comment">// 如果需要 则创建代理</span></span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 判断是否是 基础配置类或需要跳过的类。如果是则不增强 在下边的方法中会put</span></span><br><span class="line">   <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种</span></span><br><span class="line">		<span class="comment">// shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor 所属的 bean 和入参 bean 是否是同一个，如果是则不用增强反之可以，</span></span><br><span class="line">		<span class="comment">// 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean</span></span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">  <span class="comment">// 获取该bean的增强器，如果有</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果增强器不是空 则创建代理</span></span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">     <span class="comment">// 创建代理并返回</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">     <span class="comment">// 增加缓存</span></span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加缓存 如果不符合则话put，在上边的判断直接返回</span></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>来解析wrapIfNecessary方法都做了什么</strong>：</p>
<p>1: 判断是否是 基础配置类或需要跳过的类。</p>
<p>2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 <strong>shouldSkip</strong> ，这里通过调用子类 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> 的 <strong>shouldSkip</strong> 方法，通过获取全部的<strong>Advisor</strong>，来判断<strong>Advisor</strong>所属的<strong>bean</strong>和入参<strong>bean</strong>是否是同一个，如果是<strong>(如果是则就是代表该bean是配置类)</strong>则不可以增强反之可以，然后会调用 <strong>super.shouldSkip</strong> 排除尾部是 .ORIGINA 结尾的<strong>bean</strong>。</p>
<p>3: 获取该bean符合的增强器。</p>
<p>4: 创建代理并返回。</p>
<p>5: 增加缓存。</p>
<p>6: 增加缓存 如果存在可用的增强器，则将该bean设置为false，在1中会进行判断。</p>
<h5 id="获取增强器"><a href="#获取增强器" class="headerlink" title="获取增强器"></a>获取增强器</h5><h6 id="5-2-2-1-findCandidateAdvisors方法获取全部增强器"><a href="#5-2-2-1-findCandidateAdvisors方法获取全部增强器" class="headerlink" title="5.2.2.1 findCandidateAdvisors方法获取全部增强器"></a>5.2.2.1 findCandidateAdvisors方法获取全部增强器</h6><p>在<strong>wrapIfNecessary</strong>中最重要的方法就是<strong>getAdvicesAndAdvisorsForBean</strong>方法,通过<strong>getAdvicesAndAdvisorsForBean</strong>方法可以获取到适合<strong>bean增强器</strong>，接下来就看看它吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">      Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取该bean可以使用的增强器</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取所有增强器</span></span><br><span class="line">   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">   <span class="comment">// 获取当前bean可以使用的增强器</span></span><br><span class="line">   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   extendAdvisors(eligibleAdvisors);</span><br><span class="line">   <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">      eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>findEligibleAdvisors</strong>方法中首先获取了<strong>所有的增强器</strong>，然后获取适合bean的增强器，先看一下<strong>findCandidateAdvisors</strong>方法。</p>
<p>这里首先执行<code>子类</code>的<strong>findCandidateAdvisors</strong>方法，也就是<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">		<span class="comment">// 调用父类 findCandidateAdvisors 方法</span></span><br><span class="line">		List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">		<span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 处理注解形式的</span></span><br><span class="line">			advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> advisors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这里首先调用了<code>父类</code>的<strong>findCandidateAdvisors</strong>方法，也就是处理<strong>xml形式的Aop配置</strong>，然后执行了<strong>buildAspectJAdvisors</strong>方法，处理<strong>注解形式的aop配置</strong>。</p>
<p>先看一下父类的findCandidateAdvisors方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">   <span class="comment">// 获取缓存的 aop配置类名字，也就是 advisorBeanNames 数组中的信息</span></span><br><span class="line">   String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">   <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">      <span class="comment">// 如果 cachedAdvisorBeanNames 不存在则通过BeanFactoryUtils 获取，条件是 根据类型获取</span></span><br><span class="line">      advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不存在配置类则返回空数组</span></span><br><span class="line">   <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反之理解析</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">      <span class="comment">// 是否是有资格的bean</span></span><br><span class="line">      <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">         <span class="comment">// bean是否正在创建</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">               logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 存入到advisors中</span></span><br><span class="line">               advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">               Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">               <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                  BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                  String bceBeanName = bce.getBeanName();</span><br><span class="line">                  <span class="keyword">if</span> (bceBeanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Skipping advisor '"</span> + name +</span><br><span class="line">                              <span class="string">"' with dependency on currently created bean: "</span> + ex.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// Ignore: indicates a reference back to the bean we're trying to advise.</span></span><br><span class="line">                     <span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类方法中主要做了两件事：</p>
<p>1: 首先先从缓存<strong>cachedAdvisorBeanNames</strong>中获取，看是否存在<strong>Aop的配置类</strong>，如果不存在则通过<strong>BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false)</strong> 方法获取Aop的配置类，赋值到缓存中。</p>
<p>2：循环解析<strong>BeanName</strong>，通过<strong>beanFactory.isCurrentlyInCreation</strong>方法判断<strong>beanName</strong>是否是正在创建状态，如果不是则add到advisors中。</p>
<p>接下来看一下<strong>buildAspectJAdvisors</strong>方法，<strong>处理注解形式aop的配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">         <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 获取所有的bean</span></span><br><span class="line">            String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                  <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 循环所有的bean 来获取增强器</span></span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">               <span class="comment">// 判断bean是否有资格 默认所有bean都是有资格的 也可以配置 正则表达式 来判断哪些@aspet bean 是资格的</span></span><br><span class="line">               <span class="comment">// 检查给定的bean是否有资格进行自动代理。</span></span><br><span class="line">               <span class="comment">// 如果没有使用&lt;aop：include&gt;元素，则将 includePatterns null 并指定所有bean都是有资格的。如果“includePatterns”为非null，则需要和include中的name机型匹配。</span></span><br><span class="line">               <span class="comment">// 例如 @Aspect标注的类是 config     &lt;aop:include name="config1"/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效</span></span><br><span class="line">               <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">               <span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">               <span class="comment">// 获取bean的type</span></span><br><span class="line">               Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">               <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 判断是否是 aop配置bean 也就是是否被@Aspect注解标注</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                  aspectNames.add(beanName);</span><br><span class="line">                  <span class="comment">// 构建成AspectMetadata类</span></span><br><span class="line">                  AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 判断@Aspect注解中标注的是否为singleton类型，默认的切面类都是singleton类型</span></span><br><span class="line">                  <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                     MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                           <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                     <span class="comment">// 获取增强器</span></span><br><span class="line">                     List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                     <span class="comment">// put cache</span></span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// add advisors</span></span><br><span class="line">                     advisors.addAll(classAdvisors);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// Per target or per this.</span></span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                              <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                           <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                     <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                     advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">            <span class="keyword">return</span> advisors;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">      List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">      <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">         advisors.addAll(cachedAdvisors);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">         advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>buildAspectJAdvisors</strong>方法中，主要做了以下事情：</p>
<p>1: 首先获取所有的bean，通过BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)。</p>
<p>2: 判断bean是否有资格，默认所有bean都是有资格的，也可以通过配置<code>includePatterns</code>来判断哪些@aspet bean 是资格的。</p>
<p><strong>配置includePatterns：</strong></p>
<p>使用<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>标签，如果配置<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>元素，<strong>includePatterns</strong> 为非null，则需要和include中的name机型匹配。</p>
<p>如果不配置，则 includePatterns 为 null 并指定所有bean都是有资格的。</p>
<p> 例如 <strong>@Aspect</strong>标注的类是 <strong>config</strong>  &lt;aop:include name=”config1”/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效。</p>
<p>3: 判断bean是否是Aop配置类，也就是是否被@Aspect标识。</p>
<p>4: <strong>通过this.advisorFactory.getAdvisors(factory)方法获取bean的增强器</strong>。</p>
<p>5: 返回全部增强器， 其中2 3 4 5都是for循环中操作。</p>
<p>在<strong>buildAspectJAdvisors</strong>方法中，最重要的就是<code>步骤4</code>，获取每一个<strong>bean</strong>的增强器，接着看<strong>this.advisorFactory.getAdvisors(factory)</strong> 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注Bean 类型</span></span><br><span class="line">   Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注Bean 名字</span></span><br><span class="line">   String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">   <span class="comment">// 进行bean验证</span></span><br><span class="line">   validate(aspectClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">   <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">   MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">         <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获取除了 标记有 Pointcut 注解 的所有方法</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">      <span class="comment">// 获取每个方法上的 增强器</span></span><br><span class="line">      Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">      <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// add</span></span><br><span class="line">         advisors.add(advisor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">   <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">      Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">      advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find introduction fields.</span></span><br><span class="line">   <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">      Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">      <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         advisors.add(advisor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>getAdvisors</strong>方法中，通过<strong>getAdvisorMethods</strong>方法获取到了除了标记有 <strong>Pointcut</strong> 注解的其他所有方法，然后通过<strong>getAdvisor</strong>方法获取每个<strong>方法</strong>上的增强器。</p>
<p><strong>getAdvisorMethods方法源码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获取除了 标记有 Pointcut 注解 的所有方法</span></span><br><span class="line">   ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">      <span class="comment">// Exclude pointcuts</span></span><br><span class="line">      <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         methods.add(method);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   methods.sort(METHOD_COMPARATOR);</span><br><span class="line">   <span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getAdvisor方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证</span></span><br><span class="line">   validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取切点</span></span><br><span class="line">   AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">         candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实例化 增强器 这里使用的是PointcutAdvisor通知器，是方法级别的</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">         <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>getAdvisor</strong>方法中首先做了<strong>bean类型的验证</strong>，然后获取<strong>切点</strong>，最后开始<strong>实例化增强器, 这里实例化增强器使用的是PointcutAdvisor(通知器)，实际上InstantiationModelAwarePointcutAdvisorImpl是PointcutAdvisor的一个实现，也就是<code>方法级别</code>的通知器</strong>。</p>
<p><strong>先看beanType的验证，validate方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Class&lt;?&gt; aspectClass)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// If the parent has the annotation and isn't abstract it's an error</span></span><br><span class="line">  <span class="comment">// 是否存在@Aspect注解 和 abstract判断</span></span><br><span class="line">   <span class="keyword">if</span> (aspectClass.getSuperclass().getAnnotation(Aspect.class) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         !Modifier.isAbstract(aspectClass.getSuperclass().getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"["</span> + aspectClass.getName() + <span class="string">"] cannot extend concrete aspect ["</span> +</span><br><span class="line">            aspectClass.getSuperclass().getName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AjType&lt;?&gt; ajType = AjTypeSystem.getAjType(aspectClass);</span><br><span class="line">   <span class="comment">// 判断bean类型是否是 Aspect</span></span><br><span class="line">   <span class="keyword">if</span> (!ajType.isAspect()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NotAnAtAspectException(aspectClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 判断 bean 的 kind 是否是 PERCFLOW PERCFLOWBELOW  这两种在AOP中是不支持的</span></span><br><span class="line">   <span class="keyword">if</span> (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOW) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(aspectClass.getName() + <span class="string">" uses percflow instantiation model: "</span> +</span><br><span class="line">            <span class="string">"This is not supported in Spring AOP."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOWBELOW) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(aspectClass.getName() + <span class="string">" uses percflowbelow instantiation model: "</span> +</span><br><span class="line">            <span class="string">"This is not supported in Spring AOP."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接下来看获取增强器切点信息getPointcut方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 判断增强器类型</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构建 AspectJExpressionPointcut 类</span></span><br><span class="line">   AspectJExpressionPointcut ajexp =</span><br><span class="line">         <span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">   ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<strong>findAspectJAnnotationOnMethod</strong>方法获取到方法的增强器类型，然后构建<strong>AspectJExpressionPointcut</strong>类，</p>
<p><strong>最后看一下实例化增强器的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">   <span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">   <span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">   <span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">   <span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">   <span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">   <span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">   <span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">   <span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">      <span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">      Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line">      <span class="comment">// If it's not a dynamic pointcut, it may be optimized out</span></span><br><span class="line">      <span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line">      <span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line">            <span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">      <span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// A singleton aspect.</span></span><br><span class="line">      <span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line">      <span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 实例化增强器</span></span><br><span class="line">      <span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里主要关注<strong>instantiateAdvice</strong>方法，实际上它的作用就是<strong>实例化Advice</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注de bean的类型</span></span><br><span class="line">   Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证bean</span></span><br><span class="line">   validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取方法上的增强器</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line">   <span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line">   <span class="comment">// 检查 bean 是否是被 @Aspect标注</span></span><br><span class="line">   <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">            <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">            candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实例化 增强器 根据不同的类型实例化不通过的增强器</span></span><br><span class="line">   <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> AtPointcut:</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAround:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtBefore:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfter:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">            springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">            springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">               <span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now to configure the advice...</span></span><br><span class="line">   springAdvice.setAspectName(aspectName);</span><br><span class="line">   springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">   String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">   &#125;</span><br><span class="line">   springAdvice.calculateArgumentBindings();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里还是会首先<strong>验证bean的类型</strong>，通过<strong>validate</strong>方法，接下来获取<strong>method</strong>的增强器，依然是通过<strong>findAspectJAnnotationOnMethod</strong>方法，紧接着判断<strong>bean是否被@Aspect标注</strong>，最后通过<strong>switch</strong>语法<strong>实例化增强器</strong> 并赋值一些参数配置。</p>
<p>到这里我们已经<strong>获取到了上下文中所有的可用增强器</strong>，到此<strong>findCandidateAdvisors</strong>方法的代码就全部都解析完成了，如果还没有明白整体流程，可以看一下下方<strong>时序图</strong>。</p>
<p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/AOP%E8%8E%B7%E5%8F%96%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt></p>
<h6 id="5-2-2-2-findAdvisorsThatCanApply匹配适用bean的增强器"><a href="#5-2-2-2-findAdvisorsThatCanApply匹配适用bean的增强器" class="headerlink" title="5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器"></a>5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器</h6><p>接下来根据解析到的<strong>增强器进行匹配</strong>，查找出适用于需要<strong>实例化bean的增强器</strong>，<strong>findAdvisorsThatCanApply</strong>方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置当前代理对象名称</span></span><br><span class="line">   ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 删除当前代理对象名称</span></span><br><span class="line">      ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">			<span class="comment">// 在这里对 IntroductionAdvisor 类型的 Advisor(通知器)做会处理， 因为IntroductionAdvisor 是处理类拦截级别的</span></span><br><span class="line">			<span class="comment">// 仅需要使用classFilter 即可</span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">				eligibleAdvisors.add(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">		<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">			<span class="comment">// 对 处理过Advisor 的做 跳过处理</span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				<span class="comment">// already processed</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 在这里对 PointcutAdvisor 类型的 Advisor(通知器) 进行处理，因为 PointcutAdvisor 是方法级别的拦截，需要做 ClassFilter 和 MethodMatcher 判断</span></span><br><span class="line">			<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">				<span class="comment">// 将匹配的增强器 add </span></span><br><span class="line">				eligibleAdvisors.add(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回bean匹配的增强器</span></span><br><span class="line">		<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，可以看到，这里会对<strong>Advisor(通知器)</strong>做判断处理，分别是<strong>IntroductionAdvisor</strong>和<strong>PointcutAdvisor</strong>,他们都分别继承了<strong>Advisor</strong>, 在本文中是使用<strong>PointcutAdvisor</strong>的实现类<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>。</p>
<p><strong>区别</strong>：</p>
<p>IntroductionAdvisor: <strong>IntroductionAdvisor</strong>主要为了给<strong>targetClass</strong>追加接口（或者说追加更多的方法），这种增强属于<code>类级别</code>的增强,所以只需要做<strong>ClassFilter</strong>判断。</p>
<p>PointcutAdvisor: <strong>PointcutAdvisor</strong>主要为了拦截方法，这种增强属于<code>方法级别</code>的增强，则需要做<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>的判断。</p>
<p>在findAdvisorsThatCanApply方法中最重要的就是canApply方法，直接看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">   <span class="comment">// 首先ClassFilter 进行匹配</span></span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">      <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">   <span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">      classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">   &#125;</span><br><span class="line">   classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 循环匹配每一个方法</span></span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         <span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">               methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在canApply方法中首先做了<strong>ClassFilter的匹配</strong>判断，接下来获取到Class的全部public方法，遍历所有方法，进行MethodMatcher的<strong>匹配操作</strong>，最终将匹配到的<strong>Advisor</strong>全部返回，到这里<strong>findAdvisorsThatCanApply</strong>方法就全部解析完成了。</p>
<h3 id="6-创建代理"><a href="#6-创建代理" class="headerlink" title="6 创建代理"></a>6 创建代理</h3><p>在 <strong>5.2</strong> 中已经将适配于bean的增强器(Advice)获取到了, 接下来继续分析主流程<strong>wrapIfNecessary</strong>方法中的<strong>createProxy</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">								 @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 曝光 目标类</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">		proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断 是否设置了 ProxyTargetClass 是否使用CGLIB</span></span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">			<span class="comment">// 如果没有设置 ProxyTargetClass 则需要判断 beanClass 是否应该使用CGLIB  反之使用 JDK动态代理</span></span><br><span class="line">			<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">				proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置bean的增强器和拦截器</span></span><br><span class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">		proxyFactory.addAdvisors(advisors);</span><br><span class="line">		<span class="comment">// 设置目标类</span></span><br><span class="line">		proxyFactory.setTargetSource(targetSource);</span><br><span class="line">		customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">		proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">		<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">			proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法其实就是封装了<strong>ProxyFactory</strong>，真是创建代理的还是<strong>ProxyFactory</strong>，接下来看一下getProxy接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// 判断使用 CGLIB 还是 JDK动态代理</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// isOptimize ： 是否优化处理</span></span><br><span class="line">   <span class="comment">// isProxyTargetClass 是否使用CGLIB代理</span></span><br><span class="line">   <span class="comment">// hasNoUserSuppliedProxyInterfaces 是否实现了接口</span></span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">      <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">               <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是实现了接口 则 使用JDK代理</span></span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用CGLIB代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用JDK代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是调用getProxy方法进行CGLIB或者JDK代理创建了，然后返回代理类。</p>
<p>CBLIB 和 JDK 代理源码后续文章讲解。</p>
<p>GItHub : <a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></p>
<p>参考：<a href="https://my.oschina.net/lixin91/blog/684918" target="_blank" rel="noopener">https://my.oschina.net/lixin91/blog/684918</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.lantaoblog.site/2019/08/14/Spring源码系列/Spring源码之Aop/" data-id="cjzaz6pko000nk7x4y7m29bjg" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Aop/">Aop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring源码/">spring源码</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/2019/06/21/数据结构学习笔记/数组/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">数组</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'eacf3314ff57a55108e0',
      clientSecret: '267e4903bc9a8d92733ee6f4800a522de70384e1',
      repo: 'lantaoGitHub.github.io',
      owner: 'lantaoGitHub',
      admin: ['lantaoGitHub'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul align="center" class="list-inline">



      

      <li>&copy; 2019 七英里的旅行</li>
      <li>Author:  <a href="https://lantaogithub.github.io/">兰涛</a></li>
      <li>Email：lantao0518@sina.com </li>
      
<br>
      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

 
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>


<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>&nbsp&nbsp&nbsp
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


      <!--
      <li><a href="/">兰涛</a></li>
      -->
    </ul>







  </div>

 

</footer>


</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/favicon.ico" alt="七英里的旅行"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/categories">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/tags">标签云</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
      <li class="nav-item">
          <div class="totop" id="totop">
    <i class="fe fe-rocket"></i>
</div>
      </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>