<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="业精于勤荒于嬉，行成于思毁于随">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Java线程生命周期和锁的简单使用 |
    
    码农技术笔记</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-多线程/Java线程的生命周期和锁的使用" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>


    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      Java线程生命周期和锁的简单使用
    </h1>
  
  




            </header>
            



                
                    <div class="article-meta">
                        <a href="/2019/06/14/多线程/Java线程的生命周期和锁的使用/" class="article-date">
  <time datetime="2019-06-13T16:00:00.000Z" itemprop="datePublished">2019-06-14</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/多线程/">多线程</a>
  </div>

                        &emsp;<i class="fe fe-bar-chart"></i> <span class="post-count">1.9k</span>字
&emsp;<i class="fe fe-clock"></i> <span class="post-count">9</span>分钟
                    </div>

                    




                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p><span> </span></p>
<a id="more"></a>

<p>​        本文介绍了java线程的生命周期，Synchronized的几个方法简单的使用。</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ul>
<li><h4 id="初始状态-New"><a href="#初始状态-New" class="headerlink" title="初始状态(New)"></a><strong>初始状态(New)</strong></h4><p>New Thread之后，<br>&nbsp;</p>
</li>
<li><h4 id="就绪状态-Ready"><a href="#就绪状态-Ready" class="headerlink" title="就绪状态(Ready)"></a><strong>就绪状态(Ready)</strong></h4><p>表示获取到了Cpu的执行时间片，也就是cpu的执行权，等待开始执行。<br>&nbsp;</p>
</li>
<li><h4 id="运行状态-Runable"><a href="#运行状态-Runable" class="headerlink" title="运行状态(Runable)"></a><strong>运行状态(Runable)</strong></h4><p> 执行start之后，开始运行。<br>&nbsp;</p>
</li>
<li><h4 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a><strong>阻塞状态(Blocked)</strong></h4><p> 在进入synchronized的临界区或者Lock的临界区，等待获取监视器(monitor)锁，线程会进入同步队列(SynchronizedQueue)中。<br>&nbsp;</p>
</li>
<li><h4 id="等待状态-Waiting"><a href="#等待状态-Waiting" class="headerlink" title="等待状态:(Waiting)"></a><strong>等待状态:(Waiting)</strong></h4><p>在执行await(),wait(),jion(),LockSupport.park()方法进入等待状态;<br>&nbsp;</p>
</li>
<li><h4 id="等待超时状态"><a href="#等待超时状态" class="headerlink" title="等待超时状态"></a><strong>等待超时状态</strong></h4><p> 在执行Object.await(time), Object.wait(time), Object.sellp(time), LockSupport.parkUntil,lockSupport.parkNanos 进入等待超时状态。<br>&nbsp;</p>
</li>
<li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a><strong>终止状态</strong></h4><p>线程执行完毕或者执行了Thread.interrupt() / Thread.stop()，不建议使用的Thread.stop() 因为 Thread.stop是直接<strong>强行</strong>结束，<strong>不会释放资源</strong> ；</p>
</li>
<li><h4 id="配图"><a href="#配图" class="headerlink" title="配图"></a><strong>配图</strong></h4><p> <img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p>
</li>
</ul>
<h3 id="锁的几个简单方法"><a href="#锁的几个简单方法" class="headerlink" title="锁的几个简单方法"></a>锁的几个简单方法</h3><ul>
<li><h4 id="wait-和-notify-notifyAll"><a href="#wait-和-notify-notifyAll" class="headerlink" title="wait 和 notify/notifyAll"></a><strong>wait 和 notify/notifyAll</strong></h4><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h5><p><strong>wait：</strong> 将线程状态置位 <strong>‘等待状态’</strong>，进入等待队列等待。<br><strong>notify/notifyAll：</strong> notify是随机唤醒一个线程进入 <strong>‘同步队列’</strong>,notifyAll是唤醒全部被监视器锁wait的线程进入 ‘同步队列’，等待获取监视器锁后继续执行。</p>
<p><strong>提示：</strong>wait，notify/notifyAll都需要在获取到监视器所(monitor)后才可以进行操作。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程 thread1</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程 thread2</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠一秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面我们加上 obj.notify() 就会先输出 begin wait  然后sellp 10秒，执行obj.notify() 唤醒 thread1 线程 , 输出end wait</span></span><br><span class="line">        <span class="comment">// obj 上可能会存在wait 多个线程， notify唤醒是随机的，不一定能唤醒哪一个线程</span></span><br><span class="line">        <span class="comment">// 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的其中一个线程 (随机)</span></span><br><span class="line">            obj.notify();</span><br><span class="line">            <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的所有线程</span></span><br><span class="line">            obj.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">thread2   begin wait...</span><br><span class="line">thread1   begin wait...</span><br><span class="line">thread1   end wait...</span><br><span class="line">thread2   end wait...</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await,signal/signalAll"></a><strong>await,signal/signalAll</strong></h4><h5 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>await,signal/signalAll方法是Lock Condition的方法，语义和Object的wait，notify/notifyAll是完全相同的。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-15 14:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁  执行singal和notify的时候也需要在等待获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> Condition a = lock.newCondition();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Runnable runnable = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        a.await();</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"被唤醒了"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> +Thread.currentThread().getName() + <span class="string">"开始执行sinal"</span>);</span><br><span class="line">                        a.signalAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread1"</span>).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread2"</span>).start();</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">new</span> Thread(runnable1,<span class="string">"Thread3"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">Thread1</span><br><span class="line">Thread2</span><br><span class="line">线程Thread3开始执行sinal</span><br><span class="line">Thread1被唤醒了</span><br><span class="line">Thread2被唤醒了</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Join-和-Join-time"><a href="#Join-和-Join-time" class="headerlink" title="Join 和 Join(time)"></a><strong>Join 和 Join(time)</strong></h4><h5 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>等待<strong>调用Join的线程</strong>执行完成后<strong>再继续执行</strong>,或者<strong>等待时间超过了超时时间继续执行</strong>；</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Join 核心是等待指定线程运行完后再继续运行  Join(time) 就是等待线程执行的一个超时时间 超过了就继续执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                            System.out.println(<span class="string">"正常完成"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                thread1.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行 jion 等待线程 thread1 执行完后再继续执行</span></span><br><span class="line">                thread1.join();</span><br><span class="line"><span class="comment">//        thread1.join(1000);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这样最终执行的顺序是 1 2 3  如果不增加 thread1.join() 结果可能是 312 也可能是 132</span></span><br><span class="line">                <span class="comment">// Join 核心是等待指定线程运行完后再继续运行</span></span><br><span class="line">                System.out.println(<span class="string">"3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">正常完成</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h4><h5 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>yeid 方法的核心是<strong>让出 cpu 时间片</strong> ，也就是<strong>cpu执行权</strong>，线程会直接进入<strong>就绪状态</strong>,线程调度器会从线程就绪队列里获取一个线程优先级最高的线程来执行,当然也有可能直接会去到刚刚让出cpu执行权的线程，继续执行yield 后续的代码。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-03-25 17:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead1"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread1"</span>);</span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead2"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread2"</span>);</span><br><span class="line">                Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead3"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread3"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行三个线程， 正常当运行到yield 是 就会让出cpu执行权，线程到 就绪状态，线程调度器会从 线程就绪队列里获取一个线程优先级最高的线程来执行，</span></span><br><span class="line">                <span class="comment">// 当然也有可能直接会去到刚刚让出cpu的线程，继续执行yield 后续的代码</span></span><br><span class="line">                thread1.start();</span><br><span class="line">                thread3.start();</span><br><span class="line">                thread2.start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">thread1   开始执行 yield</span><br><span class="line">thread2   开始执行 yield</span><br><span class="line">thread3   开始执行 yield</span><br><span class="line">        trhead2</span><br><span class="line">trhead1</span><br><span class="line">trhead3</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="interrupt-和-stop"><a href="#interrupt-和-stop" class="headerlink" title="interrupt 和 stop"></a><strong>interrupt 和 stop</strong></h4><h5 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>interrupt和stop都代表中断线程，区别是 interrupt 会释放资源而stop不会，interrupt也不会立马就中断；说到interrupt就得说一下isInterrupted方法，他是判断线程中断标志的，如果线程A执行了线程B的interrupt方法，线程B在自己的线程中也可以使用 isInterrupted 方法判断自己的中断标志。<br>&nbsp;<br><strong>注意：在使用 interrupt方法时，如果线程在sleep wait wait(time)状态， 抛出InterruptedException异常后会清除 isInterrupted 方法获取的中断标志位，反之则不会</strong></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-17 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 在使用 interrupt方法是，如果线程咋sleep wait wait(time) 在抛出InterruptedException异常后会 清除 isInterrupted 方法获取的标志位 其他则不会</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">                &#125;, <span class="string">"循环线程"</span>);</span><br><span class="line"></span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"睡眠线程"</span>);</span><br><span class="line"></span><br><span class="line">                Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                o.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"等待线程"</span>);</span><br><span class="line"></span><br><span class="line">                thread1.start();</span><br><span class="line">                thread2.start();</span><br><span class="line">                thread3.start();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                thread1.interrupt();</span><br><span class="line">                thread2.interrupt();</span><br><span class="line">                thread3.interrupt();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">"循环线程isInteryupt is "</span> + thread1.isInterrupted());</span><br><span class="line">                System.out.println(<span class="string">"睡眠线程isInteryupt is "</span> + thread2.isInterrupted());</span><br><span class="line">                System.out.println(<span class="string">"等待线程isInteryupt is "</span> + thread3.isInterrupted());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.com.concurrenncy.InterruptTest.lambda$main$<span class="number">1</span>(InterruptTest.java:<span class="number">20</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">at com.com.concurrenncy.InterruptTest.lambda$main$<span class="number">2</span>(InterruptTest.java:<span class="number">32</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">循环线程isInteryupt is <span class="keyword">true</span></span><br><span class="line">睡眠线程isInteryupt is <span class="keyword">false</span></span><br><span class="line">等待线程isInteryupt is <span class="keyword">false</span></span><br></pre></td></tr></table></figure>



</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">




                                    <img src="/images/ocean/BlogQR.png">







                                        <a data-url="https://www.lantaoblog.site/2019/06/14/多线程/Java线程的生命周期和锁的使用/" data-id="ckgteilni000u4hx4d5s7x8hx" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2019/06/19/java基础/String的intern方法详解/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            String#intern方法详解
          
        </div>
      </a>
    
    
      <a href="/2019/06/14/锁/管程含义/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">管程含义</div>
      </a>
    
  </nav>


            

                
                    
    <div class="vcomments" id="vcomments"></div>
    <script src="https://unpkg.com/valine/dist/Valine.min.js"></script>
        <script>
            new Valine({
                el: '#vcomments',
                appId: 'H7Nh6Kr1FbVOyb1CXa836VCt-gzGzoHsz',
                appKey: 'St8IaqElFwAgVnPtR5uhga2C',
                notify: 'false',
                verify: 'true',
                avatar: 'mp',
                pageSize: '10',
                placeholder: '请输入...'
            })
        </script>
        
                        
                            




</article>
</section>
  <footer class="footer">
  <div class="outer">
 
    <ul class="list-inline">
      <li>&copy; 2020 码农技术笔记</li>
            <li> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/26/2019 15:49:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
	setInterval("createtime()",250);
</script></li>

      <li>全站共<span class="post-count">57.9k</span>字</li>
            <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>

    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="码农技术笔记"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/categories">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/tags">标签</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>