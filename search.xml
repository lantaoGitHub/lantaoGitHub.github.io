<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring源码之Aop]]></title>
    <url>%2F2019%2F08%2F14%2FSpring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BAop%2F</url>
    <content type="text"><![CDATA[本文主要介绍Spring的aop:aspectj-autoproxy/标签，了解spring是如何实现扫描注解进行aop的，主要实现是在 AspectJAutoProxyBeanDefinitionParser的parser方法中，另外这里 还需要了解一下NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 的关系，如果不清楚的可以看一下Spring源码之ApplicationContext中的解释。 1 Jdk动态代理和CGLIB代理​ 在讲述aop源码之前，需要先了解一下 Jdk 动态代理和 CGLIB 代理的区别和使用。 Jdk动态代理描述Jdk动态代理需要目标类至少实现一个接口，在运行时期生成代理类。 CGLIB代理描述CGLIB代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但CGLIB会继承目标对象，需要重写方法，所以目标对象不能为final类。 2 示例代码2.1 AspetJTest注解示例是基于注解形式，AspetJTest类为注解类。 12345678910111213141516package lantao.aop;import java.lang.annotation.*;/** * @Auther: lantao * @Date: 2019-05-09 14:01 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface AspetJTest &#123;&#125; 2.2 Aop配置类Config为Aop的配置类，Pointcut(切点)配置为AspetJTest注解，则所有使用@AspetJTest注解的方法都会被代理。 123456789101112131415161718192021222324252627282930313233343536373839package lantao.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * @Auther: lantao * @Date: 2019-05-09 14:03 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */@Aspect@Componentpublic class Config &#123; @Pointcut("@annotation(AspetJTest)") public void serviceAspect() &#123; &#125; @Around("serviceAspect()") public Object Around(ProceedingJoinPoint point) throws Throwable &#123; System.out.println("进入Around方法"); Object proceed = point.proceed(); System.out.println("退出Around方法"); return proceed; &#125; @After("serviceAspect()") public void after()&#123; System.out.println("进入after方法"); &#125; @Before("serviceAspect()") public void before()&#123; System.out.println("进入before方法"); &#125;&#125; 2.3 注解使用类TestService真正的业务类，例如输入插入/删除等，aop代理实现事物。 12345678910111213141516171819package lantao.aop;import org.springframework.stereotype.Service;/** * @Auther: lantao * @Date: 2019-05-09 13:59 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */@Servicepublic class TestService &#123; @aspetJTest public void printInfo() &#123; System.out.println("进入了printInfo方法"); &#125;&#125; 2.4 测试类TestAopMain就是测试类。 123456789101112131415161718192021package lantao.aop;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Arrays;import java.util.List;/** * @Auther: lantao * @Date: 2019-05-09 14:06 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class TestAopMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("spring-bean-aop.xml"); TestService bean = classPathXmlApplicationContext.getBean(TestService.class); bean.printInfo(); &#125;&#125; 2.5 Aop xml配置类Xml配置类，在其中有aop:aspectj-autoproxy/标签，使Aop生效，context:component-scan/开启注解扫描。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!-- use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller，@Component和@Repository 的注解的类进行扫描 --&gt; &lt;context:component-scan base-package="lantao.aop" use-default-filters="false"&gt; &lt;!-- 只扫描 base-package 的 controller 注解 还有对应的 exclude-filter 标签 排除 ； use-default-filters="false" 和 include-filter 一起使用 和 exclude-filter一起回抛异常--&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 2.6 执行结果以上代码的执行结果 12345进入Around方法进入before方法进入了printInfo方法退出Around方法进入after方法 在执行TestAopMain类中的main方法时，发现getBean方法返回的并不是目标类，而是目标类的代理类 3 XMl标签解析源码讲解3.1 解析Aop配置xml这里直接从DefaultBeanDefinitionDocumentReader类的doRegisterBeanDefinitions方法开始讲解，因前边都是xml解析的代码，已经在Spring源码之XmlBeanFactory中讲过了，其中parseBeanDefinitions方法是做标签解析使用的 DefaultBeanDefinitionDocumentReader . parseBeanDefinitions方法 1234567891011121314151617181920212223242526protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)&#123; //验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //对默认标签处理 // 这里只处理 nade namespace 为 http://www.springframework.org/schema/beans 的标签 parseDefaultElement(ele, delegate); &#125; else &#123; //对自定义标签处理 非namespace 为 http://www.springframework.org/schema/beans 的标签 ，会解析 &lt;context:component-scan base-package="lantao.scan"/&gt; 或者自定义 dubbo // 或者 aop delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //对自定义标签处理 delegate.parseCustomElement(root); &#125;&#125; 这里直接关注parseCustomElement方法，parseDefaultElement方法处理的是bean标签。 123456789101112131415161718192021222324@Nullablepublic BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;@Nullablepublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) &#123; // 获取node的 NameSpaceURI String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) &#123; return null; &#125; // 解析自定义标签 需要在 Meta-inf 文件加 增加 spring.handlers 文件 例如：http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler // 根据指定的 NameSpaceURI 获取 NamespaceHandler handler可以参考spring.handlers文件 // abstract NamespaceHandlerSupport 实现了 NamespaceHandler 接口，继而实现了 NamespaceHandler 的两个个方法（parser，docreate），自定义handler 需要实现 NamespaceHandlerSupport 类 // 进行 NamespaceHandler 类的 init 方法的 实现， 主要是做注册 BeanDefinitionParser（ registerBeanDefinitionParser ） ， 需要自定义解析类 继承 BeanDefinitionParser 类 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele); return null; &#125; // 解析操作 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 这里主要的工作就是机械NamespaceHandler,这里通过NamespaceHandlerResolver的resolve方法来解析各种NamespaceHandler,最后进行调用解析类的parse方法进行解析，接下来看一下resolve方法 123456789101112131415161718192021222324252627282930313233343536373839404142@Override@Nullablepublic NamespaceHandler resolve(String namespaceUri) &#123; // 这里获取的是所有注册到 handlerMappings 中的 NamespaceHandler ， // 就是 resource/META-INF/spring.handler 中的 key就是namespaceUri ， // 这些类都继承了 NamespaceHandlerSupport 实现了init方法 在init方法中进行 BeanDefinitionParse 的注册 Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); // 通过 namespaceUri 在 handlerMappings 中获取对应的处理器或者 className 如果是初始化过的就直接返回，反之进行类初始化工作 Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; try &#123; // 实例化 Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); // 判断实例化的类的超类或者超级接口 是否是 NamespaceHandler if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.class.getName() + "] interface"); &#125; NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); // 注册 自定义标签所对应的 解析策略类 解析策略类都继承了 BeanDefinitionParser ，比如 ComponentScanBeanDefinitionParser namespaceHandler.init(); // 放入缓存中 handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125; catch (ClassNotFoundException ex) &#123; throw new FatalBeanException("Could not find NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", ex); &#125; catch (LinkageError err) &#123; throw new FatalBeanException("Unresolvable class definition for NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", err); &#125; &#125;&#125; 在resolve方法中一共做了两件事情 1: 调用getHandlerMappings方法解析resources 中的 META-INF/spring.handlers文件，读取各种处理类。 12spring.handlers:http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler 2：进行处理类的实例化操作，然后调用处理类的init方法，进行解析类(Parser)的注册，并将实例化的处理类进行缓存处理，以备下次使用。 12345678@Overridepublic void init() &#123; // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser()); registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator()); registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());&#125; resolve方法理解后在回到主方法(parseDefaultElement)中,在实例化和解析操作后，调用了处理类的parse方法 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); 1234567@Override@Nullablepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 在 NamespaceHandlerSupport 中的 parser 集合中获取 BeanDefinitionParser 的实现类 进行 parser BeanDefinitionParser parser = findParserForElement(element, parserContext); return (parser != null ? parser.parse(element, parserContext) : null);&#125; 在findParserForElement方法中通过标签(aspectj-autoproxy)进行获取对应的处理类(AspectJAutoProxyBeanDefinitionParser)，处理类的注册在实例化处理类后调用init方法已经完成， 接下来看一下 解析类的 parse 方法。 123456789@Override@Nullablepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 注册 AnnotationAwareAspectJAutoProxyCreator AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 扩展BeanDefinition 处理 子节点 &lt;aop:include/&gt; extendBeanDefinition(element, parserContext); return null;&#125; 注册 AnnotationAwareAspectJAutoProxyCreator在解析(parse)方法中,首先是注册了AnnotationAwareAspectJAutoProxyCreator类，这个类是处理注解拦截的代理类，然后又扩展了刚刚注册的AnnotationAwareAspectJAutoProxyCreator，对xml中aop:aspectj-autoproxy标签的子节点aop:include/进行了处理。 首先看一下注册AnnotationAwareAspectJAutoProxyCreator的代码 1234567891011public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) &#123; // 注册 AnnotationAwareAspectJAutoProxyCreator BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); // 处理 proxy-target-class 和 expose-proxy属性 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); // 注册 BeanComponentDefinition registerComponentIfNecessary(beanDefinition, parserContext);&#125; 这里分为三个步骤 1：通过调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary方法进行注册AnnotationAwareAspectJAutoProxyCreator类。 2：处理aop:aspectj-autoproxy标签的 proxy-target-class 和 expose-proxy 属性。 3：注册 BeanComponentDefinition ，就是对 AnnotationAwareAspectJAutoProxyCreator 的封装。具体作用后续补上 先来看第一步注册的源码 1234567891011121314151617181920212223242526@Nullableprivate static BeanDefinition registerOrEscalateApcAsRequired( Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123; Assert.notNull(registry, "BeanDefinitionRegistry must not be null"); if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123; BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME); if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123; int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName()); int requiredPriority = findPriorityForClass(cls); if (currentPriority &lt; requiredPriority) &#123; apcDefinition.setBeanClassName(cls.getName()); &#125; &#125; return null; &#125; RootBeanDefinition beanDefinition = new RootBeanDefinition(cls); beanDefinition.setSource(source); beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE); // 定义角色，完全内部使用 beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition); return beanDefinition;&#125; 这里就没什么好说的，先判断一下是否已经注册，如果已经注册，则判断优先级，如果已注册优先级高则直接结束，反之直接创建RootBeanDefinition，通过调用DefaultListableBeanFactory的registerBeanDefinition方法进行bean注册。 优先级判断代码 12345678private static final List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = new ArrayList&lt;&gt;(3);static &#123; // Set up the escalation list... APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class); APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class); APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);&#125; 12345678910private static int findPriorityForClass(@Nullable String className) &#123; for (int i = 0; i &lt; APC_PRIORITY_LIST.size(); i++) &#123; Class&lt;?&gt; clazz = APC_PRIORITY_LIST.get(i); if (clazz.getName().equals(className)) &#123; return i; &#125; &#125; throw new IllegalArgumentException( "Class name [" + className + "] is not a known auto-proxy creator class");&#125; 注册说完了继续看一下对 proxy-target-class 和 expose-proxy 属性的处理 123456789101112131415161718private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) &#123; if (sourceElement != null) &#123; // 对标签 proxy-target-class 的处理，使用方法 &lt;aop:config proxy-target-class = "true"&gt; 或 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 使用 // 其作用是 强制使用 CGLIB 代理，设置&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; ，或需要使用CGLIB 和 @Aspectj自动代理支持 属性 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; // JDK动态代理需要至少实现一个借口 CGLIB 不需要实现接口 boolean proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); &#125; // 对 expose-proxy 的处理 其作用是实现 目标对象内部方法调用可实现切面的增强 // 例如 例如 A类中 c方法 调用 A类中的 d方法是无法实时切面增强的，需要设置 &lt;aop:aspectj-autoproxy expose-proxy="true"/&gt; 例如 d 方法 有 @Transaction 注解则失效 boolean exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) &#123; AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); &#125; &#125;&#125; proxy-target-class属性的作用是强制使用 CGLIB 代理。 expose-proxy属性的作用是目标对象内部方法调用可实现切面的增强,例如Test类中的A，B方法，A调用B方法进行数据库save操作，B方法上有@Transactional注解，如果A直接调用B方法则事物是不起作用的，需要设置expose-proxy=true，然后使用 ((A)AopContext.currentProxy()).b() 调用方式。 注册整体完成后，看一下主方法的extendBeanDefinition方法，扩展BeanDefinition。 12345678910111213141516171819202122232425private void extendBeanDefinition(Element element, ParserContext parserContext) &#123; BeanDefinition beanDef = parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME); if (element.hasChildNodes()) &#123; addIncludePatterns(element, parserContext, beanDef); &#125;&#125;private void addIncludePatterns(Element element, ParserContext parserContext, BeanDefinition beanDef) &#123; ManagedList&lt;TypedStringValue&gt; includePatterns = new ManagedList&lt;&gt;(); NodeList childNodes = element.getChildNodes(); for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; Node node = childNodes.item(i); if (node instanceof Element) &#123; Element includeElement = (Element) node; TypedStringValue valueHolder = new TypedStringValue(includeElement.getAttribute("name")); valueHolder.setSource(parserContext.extractSource(includeElement)); includePatterns.add(valueHolder); &#125; &#125; if (!includePatterns.isEmpty()) &#123; includePatterns.setSource(parserContext.extractSource(element)); beanDef.getPropertyValues().add("includePatterns", includePatterns); &#125;&#125; extendBeanDefinition方法主要是对注册的AnnotationAwareAspectJAutoProxyCreator就行扩充，如果aop:aspectj-autoproxy标签还有子标签，也就是aop:include/标签，则会作getPropertyValues.add的操作，这里的aop:include/标签如果存在对于解析@Aspect标注的类时有一个match的动作，这里的内容会在buildAspectJAdvisors方法中详细讲解。 好了到这里整个Xml的解析注册就完成了，接下来看一下具体的实现。 4 SpringBoot 自动配置Aop5 Aop实现源码分析5.1 术语定义 ClassFilter：类过滤器 Advisor：通知器 targetClass：目标类，或称被代理的原始类 Advice：通知，或称拦截器，也就是要增强的代码逻辑 MethodMatcher：方法匹配器 Pointcut：切点，由ClassFilter和MethodMatcher组成 ClassFilter用于约束一个Advisor(通知器)，与指定的targetClass是否匹配,只有匹配的前提下,Advisor才能使用其内部持有的Advice(增强器)对targetClass进行增强。 ​ Advisor分两大类：IntroductionAdvisor（引介通知器）和PointcutAdvisor（切点通知器）。两类Advisor都是为了增强targetClass，但是作用不一样。IntroductionAdvisor主要为了给targetClass追加接口（或者说追加更多的方法），这种增强属于类级别的增强；而PointcutAdvisor主要为了拦截方法，这种增强属于方法级别的增强。 ​ 正是由于两类Advisor的增强级别不同，而导致了对ClassFilter的使用方式不同。IntroductionAdvisor进行类级别增强，因此只需要直接持有ClassFilter即可；而PointcutAdvisor进行方法级别增强，因此需要同时使用ClassFilter和MethodMatcher（方法匹配器）。PointcutAdvisor内部持有一个Pointcut，而Pointcut就是由ClassFilter和MethodMatcher组成的。 5.2 AnnotationAwareAspectJAutoProxyCreator类解析​ 在上面的xml解析aop:aspectj-autoproxy标签时，一直都在说注册AnnotationAwareAspectJAutoProxyCreator，其实它是继承了InstantiationAwareBeanPostProcessor -&gt; BeanPostProcessor的，继承了 InstantiationAwareBeanPostProcessor 会在实例化之前执行postProcessBeforeInstantiation和postProcessAfterInstantiation方法，但同时它也间接性继承了BeanPostProcessor，也会在初始化前后执行 postProcessBeforeInstantiation 和 postProcessAfterInitialization 方法，在createBean方法中有这么一方法resolveBeforeInstantiation，它就是在实例化之前执行的InstantiationAwareBeanPostProcessor，代码如下： 12345678910111213141516171819@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123;************ try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 给BeanPostProcessors一个返回代理而不是目标bean实例的机会 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex); &#125;**********&#125; 5.2.1 postProcessBeforeInstantiation方法解析​ 创建代理的真正方法就是AbstractAutoProxyCreator.postProcessAfterInitialization方法或 postProcessBeforeInstantiation方法。AbstractAutoProxyCreator 是 AnnotationAwareAspectJAutoProxyCreator的超类。下面先看一下 AbstractAutoProxyCreator.postProcessBeforeInstantiation方法 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Object cacheKey = getCacheKey(beanClass, beanName); // 判断beanName是否为空 和 targetSoucedBeans是否包含beanName if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) &#123; if (this.advisedBeans.containsKey(cacheKey)) &#123; return null; &#125; // isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种 // shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor所属的bean和入参bean是否是同一个，如果是则不用增强反之可以， // 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. // 如果有自定义的targetSouce 在这里就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化 TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) &#123; if (StringUtils.hasLength(beanName)) &#123; // 缓存 this.targetSourcedBeans.add(beanName); &#125; // 获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around 等 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); // 根据增强器创建代理 Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); // 缓存 this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; return null; &#125; 在postProcessBeforeInstantiation方法主要做了一下几件事情： 1: 判断beanName是否为空 和 targetSoucedBeans是否包含beanName。 2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 shouldSkip ，这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor所属的bean和入参bean是否是同一个，如果是(如果是则就是代表该bean是配置类)则不可以增强反之可以，然后会调用 super.shouldSkip 排除尾部是 .ORIGINA 结尾的bean。 3: 获取自定义的TargetSouce ,如果存在就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化。 4: 如果存在自定义的TargetSouce，则获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around ，找到符合该bean的增强器。 5: 根据查询出来的增强器创建代理并返回。 上述是对存在TargetSource情况的描述，下面我们看一下不存在的情况 5.2.2 postProcessAfterInitialization方法解析接下来看AbstractAutoProxyCreator类中的postProcessAfterInitialization方法 123456789101112@Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &#123; if (bean != null) &#123; Object cacheKey = getCacheKey(bean.getClass(), beanName); //防止 bean 多次被增强。 if (this.earlyProxyReferences.remove(cacheKey) != bean) &#123; // 如果需要 则创建代理 return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean; &#125; 1234567891011121314151617181920212223242526272829303132333435protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; // 判断是否是 基础配置类或需要跳过的类。如果是则不增强 在下边的方法中会put if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; // isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种 // shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor 所属的 bean 和入参 bean 是否是同一个，如果是则不用增强反之可以， // 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // Create proxy if we have advice. // 获取该bean的增强器，如果有 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); // 如果增强器不是空 则创建代理 if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); // 创建代理并返回 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); // 增加缓存 this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; // 增加缓存 如果不符合则话put，在上边的判断直接返回 this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 来解析wrapIfNecessary方法都做了什么： 1: 判断是否是 基础配置类或需要跳过的类。 2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 shouldSkip ，这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor所属的bean和入参bean是否是同一个，如果是(如果是则就是代表该bean是配置类)则不可以增强反之可以，然后会调用 super.shouldSkip 排除尾部是 .ORIGINA 结尾的bean。 3: 获取该bean符合的增强器。 4: 创建代理并返回。 5: 增加缓存。 6: 增加缓存 如果存在可用的增强器，则将该bean设置为false，在1中会进行判断。 获取增强器5.2.2.1 findCandidateAdvisors方法获取全部增强器在wrapIfNecessary中最重要的方法就是getAdvicesAndAdvisorsForBean方法,通过getAdvicesAndAdvisorsForBean方法可以获取到适合bean增强器，接下来就看看它吧。 123456789101112@Override@Nullableprotected Object[] getAdvicesAndAdvisorsForBean( Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123; // 获取该bean可以使用的增强器 List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) &#123; return DO_NOT_PROXY; &#125; return advisors.toArray();&#125; 1234567891011protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; // 获取所有增强器 List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); // 获取当前bean可以使用的增强器 List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 在findEligibleAdvisors方法中首先获取了所有的增强器，然后获取适合bean的增强器，先看一下findCandidateAdvisors方法。 这里首先执行子类的findCandidateAdvisors方法，也就是AnnotationAwareAspectJAutoProxyCreator的。 123456789101112@Override protected List&lt;Advisor&gt; findCandidateAdvisors() &#123; // Add all the Spring advisors found according to superclass rules. // 调用父类 findCandidateAdvisors 方法 List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory. if (this.aspectJAdvisorsBuilder != null) &#123; // 处理注解形式的 advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); &#125; return advisors; &#125; 在这里首先调用了父类的findCandidateAdvisors方法，也就是处理xml形式的Aop配置，然后执行了buildAspectJAdvisors方法，处理注解形式的aop配置。 先看一下父类的findCandidateAdvisors方法 1234protected List&lt;Advisor&gt; findCandidateAdvisors() &#123; Assert.state(this.advisorRetrievalHelper != null, "No BeanFactoryAdvisorRetrievalHelper available"); return this.advisorRetrievalHelper.findAdvisorBeans();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public List&lt;Advisor&gt; findAdvisorBeans() &#123; // Determine list of advisor bean names, if not cached already. // 获取缓存的 aop配置类名字，也就是 advisorBeanNames 数组中的信息 String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) &#123; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! // 如果 cachedAdvisorBeanNames 不存在则通过BeanFactoryUtils 获取，条件是 根据类型获取 advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; &#125; // 如果不存在配置类则返回空数组 if (advisorNames.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; // 反之理解析 List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); for (String name : advisorNames) &#123; // 是否是有资格的bean if (isEligibleBean(name)) &#123; // bean是否正在创建 if (this.beanFactory.isCurrentlyInCreation(name)) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Skipping currently created advisor '" + name + "'"); &#125; &#125; else &#123; try &#123; // 存入到advisors中 advisors.add(this.beanFactory.getBean(name, Advisor.class)); &#125; catch (BeanCreationException ex) &#123; Throwable rootCause = ex.getMostSpecificCause(); if (rootCause instanceof BeanCurrentlyInCreationException) &#123; BeanCreationException bce = (BeanCreationException) rootCause; String bceBeanName = bce.getBeanName(); if (bceBeanName != null &amp;&amp; this.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Skipping advisor '" + name + "' with dependency on currently created bean: " + ex.getMessage()); &#125; // Ignore: indicates a reference back to the bean we're trying to advise. // We want to find advisors other than the currently created bean itself. continue; &#125; &#125; throw ex; &#125; &#125; &#125; &#125; return advisors;&#125; 父类方法中主要做了两件事： 1: 首先先从缓存cachedAdvisorBeanNames中获取，看是否存在Aop的配置类，如果不存在则通过BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false) 方法获取Aop的配置类，赋值到缓存中。 2：循环解析BeanName，通过beanFactory.isCurrentlyInCreation方法判断beanName是否是正在创建状态，如果不是则add到advisors中。 接下来看一下buildAspectJAdvisors方法，处理注解形式aop的配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public List&lt;Advisor&gt; buildAspectJAdvisors() &#123; List&lt;String&gt; aspectNames = this.aspectBeanNames; if (aspectNames == null) &#123; synchronized (this) &#123; aspectNames = this.aspectBeanNames; if (aspectNames == null) &#123; List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); aspectNames = new ArrayList&lt;&gt;(); // 获取所有的bean String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Object.class, true, false); // 循环所有的bean 来获取增强器 for (String beanName : beanNames) &#123; // 判断bean是否有资格 默认所有bean都是有资格的 也可以配置 正则表达式 来判断哪些@aspet bean 是资格的 // 检查给定的bean是否有资格进行自动代理。 // 如果没有使用&lt;aop：include&gt;元素，则将 includePatterns null 并指定所有bean都是有资格的。如果“includePatterns”为非null，则需要和include中的name机型匹配。 // 例如 @Aspect标注的类是 config &lt;aop:include name="config1"/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效 if (!isEligibleBean(beanName)) &#123; continue; &#125; // We must be careful not to instantiate beans eagerly as in this case they // would be cached by the Spring container but would not have been weaved. // 获取bean的type Class&lt;?&gt; beanType = this.beanFactory.getType(beanName); if (beanType == null) &#123; continue; &#125; // 判断是否是 aop配置bean 也就是是否被@Aspect注解标注 if (this.advisorFactory.isAspect(beanType)) &#123; aspectNames.add(beanName); // 构建成AspectMetadata类 AspectMetadata amd = new AspectMetadata(beanType, beanName); // 判断@Aspect注解中标注的是否为singleton类型，默认的切面类都是singleton类型 if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123; MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); // 获取增强器 List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); // put cache if (this.beanFactory.isSingleton(beanName)) &#123; this.advisorsCache.put(beanName, classAdvisors); &#125; else &#123; this.aspectFactoryCache.put(beanName, factory); &#125; // add advisors advisors.addAll(classAdvisors); &#125; else &#123; // Per target or per this. if (this.beanFactory.isSingleton(beanName)) &#123; throw new IllegalArgumentException("Bean with name '" + beanName + "' is a singleton, but aspect instantiation model is not singleton"); &#125; MetadataAwareAspectInstanceFactory factory = new PrototypeAspectInstanceFactory(this.beanFactory, beanName); this.aspectFactoryCache.put(beanName, factory); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; &#125; this.aspectBeanNames = aspectNames; return advisors; &#125; &#125; &#125; if (aspectNames.isEmpty()) &#123; return Collections.emptyList(); &#125; List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); for (String aspectName : aspectNames) &#123; List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName); if (cachedAdvisors != null) &#123; advisors.addAll(cachedAdvisors); &#125; else &#123; MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; return advisors;&#125; 在buildAspectJAdvisors方法中，主要做了以下事情： 1: 首先获取所有的bean，通过BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)。 2: 判断bean是否有资格，默认所有bean都是有资格的，也可以通过配置includePatterns来判断哪些@aspet bean 是资格的。 配置includePatterns： 使用aop:include/标签，如果配置aop:include/元素，includePatterns 为非null，则需要和include中的name机型匹配。 如果不配置，则 includePatterns 为 null 并指定所有bean都是有资格的。 例如 @Aspect标注的类是 config &lt;aop:include name=”config1”/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效。 3: 判断bean是否是Aop配置类，也就是是否被@Aspect标识。 4: 通过this.advisorFactory.getAdvisors(factory)方法获取bean的增强器。 5: 返回全部增强器， 其中2 3 4 5都是for循环中操作。 在buildAspectJAdvisors方法中，最重要的就是步骤4，获取每一个bean的增强器，接着看this.advisorFactory.getAdvisors(factory) 方法: 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123; // 获取 @Aspect 标注Bean 类型 Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); // 获取 @Aspect 标注Bean 名字 String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName(); // 进行bean验证 validate(aspectClass); // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator // so that it will only instantiate once. MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory); List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); // 获取除了 标记有 Pointcut 注解 的所有方法 for (Method method : getAdvisorMethods(aspectClass)) &#123; // 获取每个方法上的 增强器 Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName); if (advisor != null) &#123; // add advisors.add(advisor); &#125; &#125; // If it's a per target aspect, emit the dummy instantiating aspect. if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123; Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory); advisors.add(0, instantiationAdvisor); &#125; // Find introduction fields. for (Field field : aspectClass.getDeclaredFields()) &#123; Advisor advisor = getDeclareParentsAdvisor(field); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; return advisors;&#125; 在getAdvisors方法中，通过getAdvisorMethods方法获取到了除了标记有 Pointcut 注解的其他所有方法，然后通过getAdvisor方法获取每个方法上的增强器。 getAdvisorMethods方法源码: 123456789101112private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123; final List&lt;Method&gt; methods = new ArrayList&lt;&gt;(); // 获取除了 标记有 Pointcut 注解 的所有方法 ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123; // Exclude pointcuts if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123; methods.add(method); &#125; &#125;); methods.sort(METHOD_COMPARATOR); return methods;&#125; getAdvisor方法源码： 12345678910111213141516171819@Override@Nullablepublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName) &#123; // 验证 validate(aspectInstanceFactory.getAspectMetadata().getAspectClass()); // 获取切点 AspectJExpressionPointcut expressionPointcut = getPointcut( candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()); if (expressionPointcut == null) &#123; return null; &#125; // 实例化 增强器 这里使用的是PointcutAdvisor通知器，是方法级别的 return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName);&#125; 在getAdvisor方法中首先做了bean类型的验证，然后获取切点，最后开始实例化增强器, 这里实例化增强器使用的是PointcutAdvisor(通知器)，实际上InstantiationModelAwarePointcutAdvisorImpl是PointcutAdvisor的一个实现，也就是方法级别的通知器。 先看beanType的验证，validate方法源码： 12345678910111213141516171819202122232425@Overridepublic void validate(Class&lt;?&gt; aspectClass) throws AopConfigException &#123; // If the parent has the annotation and isn't abstract it's an error // 是否存在@Aspect注解 和 abstract判断 if (aspectClass.getSuperclass().getAnnotation(Aspect.class) != null &amp;&amp; !Modifier.isAbstract(aspectClass.getSuperclass().getModifiers())) &#123; throw new AopConfigException("[" + aspectClass.getName() + "] cannot extend concrete aspect [" + aspectClass.getSuperclass().getName() + "]"); &#125; AjType&lt;?&gt; ajType = AjTypeSystem.getAjType(aspectClass); // 判断bean类型是否是 Aspect if (!ajType.isAspect()) &#123; throw new NotAnAtAspectException(aspectClass); &#125; // 判断 bean 的 kind 是否是 PERCFLOW PERCFLOWBELOW 这两种在AOP中是不支持的 if (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOW) &#123; throw new AopConfigException(aspectClass.getName() + " uses percflow instantiation model: " + "This is not supported in Spring AOP."); &#125; if (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOWBELOW) &#123; throw new AopConfigException(aspectClass.getName() + " uses percflowbelow instantiation model: " + "This is not supported in Spring AOP."); &#125;&#125; 接下来看获取增强器切点信息getPointcut方法源码： 123456789101112131415161718@Nullableprivate AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123; // 获取 判断增强器类型 AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; // 构建 AspectJExpressionPointcut 类 AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]); ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); if (this.beanFactory != null) &#123; ajexp.setBeanFactory(this.beanFactory); &#125; return ajexp;&#125; 通过findAspectJAnnotationOnMethod方法获取到方法的增强器类型，然后构建AspectJExpressionPointcut类， 最后看一下实例化增强器的代码： 12345678910111213141516171819202122232425262728293031323334public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut, Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123; this.declaredPointcut = declaredPointcut; this.declaringClass = aspectJAdviceMethod.getDeclaringClass(); this.methodName = aspectJAdviceMethod.getName(); this.parameterTypes = aspectJAdviceMethod.getParameterTypes(); this.aspectJAdviceMethod = aspectJAdviceMethod; this.aspectJAdvisorFactory = aspectJAdvisorFactory; this.aspectInstanceFactory = aspectInstanceFactory; this.declarationOrder = declarationOrder; this.aspectName = aspectName; if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123; // Static part of the pointcut is a lazy type. Pointcut preInstantiationPointcut = Pointcuts.union( aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut); // Make it dynamic: must mutate from pre-instantiation to post-instantiation state. // If it's not a dynamic pointcut, it may be optimized out // by the Spring AOP infrastructure after the first evaluation. this.pointcut = new PerTargetInstantiationModelPointcut( this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory); this.lazy = true; &#125; else &#123; // A singleton aspect. this.pointcut = this.declaredPointcut; this.lazy = false; // 实例化增强器 this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut); &#125;&#125; 在这里主要关注instantiateAdvice方法，实际上它的作用就是实例化Advice： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Override@Nullablepublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123; // 获取 @Aspect 标注de bean的类型 Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); // 验证bean validate(candidateAspectClass); // 获取方法上的增强器 AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; // If we get here, we know we have an AspectJ method. // Check that it's an AspectJ-annotated class // 检查 bean 是否是被 @Aspect标注 if (!isAspect(candidateAspectClass)) &#123; throw new AopConfigException("Advice must be declared inside an aspect type: " + "Offending method '" + candidateAdviceMethod + "' in class [" + candidateAspectClass.getName() + "]"); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Found AspectJ method: " + candidateAdviceMethod); &#125; AbstractAspectJAdvice springAdvice; // 实例化 增强器 根据不同的类型实例化不通过的增强器 switch (aspectJAnnotation.getAnnotationType()) &#123; case AtPointcut: if (logger.isDebugEnabled()) &#123; logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'"); &#125; return null; case AtAround: springAdvice = new AspectJAroundAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtBefore: springAdvice = new AspectJMethodBeforeAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfter: springAdvice = new AspectJAfterAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfterReturning: springAdvice = new AspectJAfterReturningAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterReturningAnnotation.returning())) &#123; springAdvice.setReturningName(afterReturningAnnotation.returning()); &#125; break; case AtAfterThrowing: springAdvice = new AspectJAfterThrowingAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123; springAdvice.setThrowingName(afterThrowingAnnotation.throwing()); &#125; break; default: throw new UnsupportedOperationException( "Unsupported advice type on method: " + candidateAdviceMethod); &#125; // Now to configure the advice... springAdvice.setAspectName(aspectName); springAdvice.setDeclarationOrder(declarationOrder); String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod); if (argNames != null) &#123; springAdvice.setArgumentNamesFromStringArray(argNames); &#125; springAdvice.calculateArgumentBindings(); return springAdvice;&#125; 首先这里还是会首先验证bean的类型，通过validate方法，接下来获取method的增强器，依然是通过findAspectJAnnotationOnMethod方法，紧接着判断bean是否被@Aspect标注，最后通过switch语法实例化增强器 并赋值一些参数配置。 到这里我们已经获取到了上下文中所有的可用增强器，到此findCandidateAdvisors方法的代码就全部都解析完成了，如果还没有明白整体流程，可以看一下下方时序图。 5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器接下来根据解析到的增强器进行匹配，查找出适用于需要实例化bean的增强器，findAdvisorsThatCanApply方法源码: 1234567891011121314protected List&lt;Advisor&gt; findAdvisorsThatCanApply( List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) &#123; // 设置当前代理对象名称 ProxyCreationContext.setCurrentProxiedBeanName(beanName); try &#123; // 匹配 return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass); &#125; finally &#123; // 删除当前代理对象名称 ProxyCreationContext.setCurrentProxiedBeanName(null); &#125;&#125; 12345678910111213141516171819202122232425262728public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123; if (candidateAdvisors.isEmpty()) &#123; return candidateAdvisors; &#125; List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;(); for (Advisor candidate : candidateAdvisors) &#123; // 在这里对 IntroductionAdvisor 类型的 Advisor(通知器)做会处理， 因为IntroductionAdvisor 是处理类拦截级别的 // 仅需要使用classFilter 即可 if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) &#123; // 对 处理过Advisor 的做 跳过处理 if (candidate instanceof IntroductionAdvisor) &#123; // already processed continue; &#125; // 在这里对 PointcutAdvisor 类型的 Advisor(通知器) 进行处理，因为 PointcutAdvisor 是方法级别的拦截，需要做 ClassFilter 和 MethodMatcher 判断 if (canApply(candidate, clazz, hasIntroductions)) &#123; // 将匹配的增强器 add eligibleAdvisors.add(candidate); &#125; &#125; // 返回bean匹配的增强器 return eligibleAdvisors; &#125; 在上述代码中，可以看到，这里会对Advisor(通知器)做判断处理，分别是IntroductionAdvisor和PointcutAdvisor,他们都分别继承了Advisor, 在本文中是使用PointcutAdvisor的实现类InstantiationModelAwarePointcutAdvisorImpl。 区别： IntroductionAdvisor: IntroductionAdvisor主要为了给targetClass追加接口（或者说追加更多的方法），这种增强属于类级别的增强,所以只需要做ClassFilter判断。 PointcutAdvisor: PointcutAdvisor主要为了拦截方法，这种增强属于方法级别的增强，则需要做ClassFilter和MethodMatcher的判断。 在findAdvisorsThatCanApply方法中最重要的就是canApply方法，直接看一下源码： 12345678910111213141516171819202122232425262728293031323334353637public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; Assert.notNull(pc, "Pointcut must not be null"); // 首先ClassFilter 进行匹配 if (!pc.getClassFilter().matches(targetClass)) &#123; return false; &#125; MethodMatcher methodMatcher = pc.getMethodMatcher(); if (methodMatcher == MethodMatcher.TRUE) &#123; // No need to iterate the methods if we're matching any method anyway... return true; &#125; IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123; introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; &#125; Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(); if (!Proxy.isProxyClass(targetClass)) &#123; classes.add(ClassUtils.getUserClass(targetClass)); &#125; classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); // 循环匹配每一个方法 for (Class&lt;?&gt; clazz : classes) &#123; Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) &#123; if (introductionAwareMethodMatcher != null ? introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) : methodMatcher.matches(method, targetClass)) &#123; return true; &#125; &#125; &#125; return false;&#125; 在canApply方法中首先做了ClassFilter的匹配判断，接下来获取到Class的全部public方法，遍历所有方法，进行MethodMatcher的匹配操作，最终将匹配到的Advisor全部返回，到这里findAdvisorsThatCanApply方法就全部解析完成了。 6 创建代理在 5.2 中已经将适配于bean的增强器(Advice)获取到了, 接下来继续分析主流程wrapIfNecessary方法中的createProxy方法。 1234567891011121314151617181920212223242526272829303132333435protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123; // 曝光 目标类 if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123; AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); &#125; ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); // 判断 是否设置了 ProxyTargetClass 是否使用CGLIB if (!proxyFactory.isProxyTargetClass()) &#123; // 如果没有设置 ProxyTargetClass 则需要判断 beanClass 是否应该使用CGLIB 反之使用 JDK动态代理 if (shouldProxyTargetClass(beanClass, beanName)) &#123; proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; // 设置bean的增强器和拦截器 Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); // 设置目标类 proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; return proxyFactory.getProxy(getProxyClassLoader()); &#125; 上面的方法其实就是封装了ProxyFactory，真是创建代理的还是ProxyFactory，接下来看一下getProxy接口。 123public Object getProxy(@Nullable ClassLoader classLoader) &#123; return createAopProxy().getProxy(classLoader);&#125; 12345678910111213141516171819202122232425@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; // 判断使用 CGLIB 还是 JDK动态代理 // isOptimize ： 是否优化处理 // isProxyTargetClass 是否使用CGLIB代理 // hasNoUserSuppliedProxyInterfaces 是否实现了接口 if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException("TargetSource cannot determine target class: " + "Either an interface or a target is required for proxy creation."); &#125; // 如果是实现了接口 则 使用JDK代理 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; // 使用CGLIB代理 return new ObjenesisCglibAopProxy(config); &#125; else &#123; // 使用JDK代理 return new JdkDynamicAopProxy(config); &#125;&#125; 接下来就是调用getProxy方法进行CGLIB或者JDK代理创建了，然后返回代理类。 CBLIB 和 JDK 代理源码后续文章讲解。 GItHub : https://github.com/lantaoGitHub/spring-framework.git 参考：https://my.oschina.net/lixin91/blog/684918]]></content>
      <categories>
        <category>spring源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数据结构课程学习笔记。 数组概念数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据, 并且不支持动态扩容。 线性表线性表就是数据排成一条线一样的数据结构，每个线性表最多只有前后两个方向，数组，链表丶队列丶栈等都是线性表数据结构。 非线性表非线性表就是数据不规则，与线性表是相对立的，比如二叉树丶堆丶等，在非线性表中，数据之间并不是简单的前后关系。 数组随机访问 公式1address[i] = base_address + i * data_type_size address[i] : 下标 i 的地址值。 base_address： 数组的首地址。 data_type_size： 数组中每个元素的大小，也就是数据类型大小(字节)，例如int是4个字节。 数组的增加和删除数组 (Array) 在增删查这三个动作中，查询是高效的，但是增和删是低效的，查询高效是因为数组支持随机访问，时间复杂度是 O(1) ,这里就不多赘述了，但是在增加和删除的动作中，因为会涉及数据搬移，所以时间复杂度是 O(n) ，下面来详细讲解。 低效的”插入”和”删除”1int[] info = new int[6]; 插入数组 info 是一个一维数组，其内容是 33,44,66,77,88 现在需要在下标 2 的位置插入 55 ，将其变成33 44 55 66 77 88的数组，这其中涉及将下标 2 到下标 4 的之间进行数据进行搬移，完成后在下标 2 的位置插入 55 , 其复杂度是 O(n)， 但如果是在最后进行插入的话其复杂度是 O(1)。 删除还拿数组 info 来举例，数组删除前其内容是 33,44,00,55,66,77 现在进行删除操作，删除下标为 2 内容，这其中涉及将下标 3 到 5 的内容向前搬移，其操作的时间复杂度是 O(n) ，如果是是删除最后一位且后面没有内容，则其时间复杂度是O(1) 。 因插入和删除操作会涉及到数据搬移,所以说他是低效的。 CPU缓存** Cpu缓存的最小单位是Cpu缓存行，一个缓存行大小通常是64字节(取决于CPU)，试想一下你正在遍历一个长度为 16 的 long 数组 data[16]，原始数据自然存在于主内存中，访问过程描述如下： 1：访问 data[0]，CPU core 尝试访问 CPU Cache，未命中。 2：尝试访问主内存，操作系统一次访问的单位是一个 Cache Line 的大小 — 64 字节，这意味着：既从主内存中获取3：到了 data[0] 的值，同时将 data[0] ~ data[7] 加入到了 CPU Cache 之中， 4：访问 data[1]~data[7]，CPU core 尝试访问 CPU Cache，命中直接返回。 5：访问 data[8]，CPU core 尝试访问 CPU Cache，未命中, 尝试访问主存，重复步骤2。 测试数组和Cpu缓存行 因Cpu缓存最小单位是缓存行(64字节)，我么来测试一下二维数组的横向遍历和纵向遍历的具体时间和性能。 代码 1234567891011121314151617181920212223242526272829303132333435package com.com.array;/** * @Auther: lantao * @Date: 2019-06-24 15:52 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class ArrayTest &#123; static long[][] arr; public static void main(String[] args) &#123; long sum = 0L; arr = new long[1024 * 1024][10]; // 横向遍历 long l = System.currentTimeMillis(); for (int i = 0; i &lt; 1024 * 1024; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; sum += arr[i][j]; &#125; &#125; System.out.println("Loop Time 横向遍历：" + (System.currentTimeMillis() - l) + "ms"); long l1 = System.currentTimeMillis(); // 纵向遍历 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 1024 * 1024; j++) &#123; sum += arr[j][i]; &#125; &#125; System.out.println("Loop Time 纵向遍历：" + (System.currentTimeMillis() - l) + "ms"); &#125;&#125; 123结果：Loop Time 横向遍历：14msLoop Time 纵向遍历：83ms 总结： 因横向遍历遍历的是行，然后在循环行的每一列，Cpu缓存会缓存64字节大小的缓存行，所以可以减少cpu和主存之间的交互，直接和高速缓存交互，提升性能，纵向遍历因每次循环都是不同的行，所以使缓存行没有作用。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String#intern方法详解]]></title>
    <url>%2F2019%2F06%2F19%2Fjava%E5%9F%BA%E7%A1%80%2FString%E7%9A%84intern%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[记录创建String的两种方式，”” 和 new String()区别，String intern方法的使用和常量池。 String的使用 (Jdk1.8)代码12345678910111213141516171819202122232425package com.com.string;/** * @Auther: lantao * @Date: 2019-04-15 13:53 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class StringTest &#123; public static void main(String[] args) &#123; // 使用 "" 创建 会直接存储在 常量池中 String a = "lantao"; // 使用 new String 创建， 会将zahngsan存储到常量池中，然后在Heap中创建对象指向b String b = new String("zhangsan"); // 使用 字符串连接符拼接 ，会直接存储 'wangwuzhaoliu' 字符串在常量池中 String c = "wangwu" + "zhaoliu"; // 使用字符串 "引用" 拼接 ，不执行 intern 方法，不会存放到常量池中，但是会将 --- 存入到常量池中 String d = a + "---"; // 使用 new String 拼接 ，不执行 intern 方法，不会存放到常量池中，但是会将wang 和 jiu 两个字符串存到常量池中 String f = new String("wang") + "jiu"; // 使用 new String 拼接 ，不执行 intern 方法，不会存放到常量池中， 但是会将 zhao 和 ba 两个字符串存入到常量池中 String g = new String("zhao") + new String("ba"); &#125;&#125; 解释 变量a： “lantao” 是字符串常量，在编译期就被确定了，先检查字符串常量池中是否含有”lantao”字符串,若没有则添加“lantao”到字符串常量池中，并且直接指向它。所以a直接指向字符串常量池的”lantao”,也就是变量a指向的地址是常量池中的 lantao。 变量b：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间(Java Heap 中)，变量b的引用的地址在Java Heap中。 但是”zhangsan”字符串常量在编译期也会被加入到字符串常量池（如果常量池不存在的话）。 变量c：“wangwu”和”zhaoliu”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，在编译器会被编译器优化成”wangwuzhaoliu”，所以c也同样在编译期就被解析为一个字符串常量，并且c是常量池中”wangwuzhaoliu”的一个引用，所以变量c的引用地址在常量池中。 变量d： JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即`(a+”—“) 变量f： 变量f同样不能在编译期确定，但是”wang”和”jiu”这两个字符串常量会添加到字符串常量池中，并且在堆中创建String对象。（字符串常量池并不会存放”wangjiu”这个字符串,除非执行f.intern()方法） 变量g： 同理变量f。 图解 String 拼接 字符串拼接 12345public class StringTest &#123; public static void main(String[] args) &#123; String a = "lan" + "tao"; &#125;&#125; lan 和 tao 都是字符串，都是在编译器可知的，编译器会将这行代码优化，当一个字符串是由多个可知的字符串(非引用字符串)连接组成，将会优化为如下。 12345public class StringTest &#123; public static void main(String[] args) &#123; String a = "lantao"; &#125;&#125; JVM会将字符串”lantao”放入到String常量池中。 引用拼接： 12345678910public class StringTest &#123; public static void main(String[] args) &#123; String a = "lan"; String b = a + "tao"; // 上下含义相同 String c = "zhang"; String d = "san"; String f = c + d; &#125;&#125; 当Java编译器遇到字符串引用 或 字符串引用和可知字符串拼接的时候，会创建一个StringBuilder对象，后面的append()。 因为有字符串引用存在，而引用的值在程序编译期是无法确定的。另外 “lan”、”tao” 都会编译器添加到字符串常量池中（如果没有的话），因为它们都是编译期确定的字符串常量，但是最后的”lantao”并不会添加到字符串常量池, 除非执行b.intern() 方法 final拼接 1234567public class StringTest &#123; public static void main(String[] args) &#123; final String a = "lan"; final String b = "tao"; String c = a + b + "2019"; &#125;&#125; final拼接和以上两者的区别就是在前边增加了final修饰，用final修饰的字符串就是在编译期可知的，编译期就会将以上代码优化为 12345public class StringTest &#123; public static void main(String[] args) &#123; String str = "lantao2019"; &#125;&#125; 这里 final 拼接的效果是和字符串拼接是一致的。 String#intern方法intern方法详解String.intern()是一个Native(本地)方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回。 使用注意：基本数据类型之间的 == 是比较值，引用数据类型 == 比较的是地址值 常量池中存在字符串12345678910111213141516171819public class StringTest &#123; public static void main(String[] args) &#123; // 基本数据类型之间的 == 是比较值，引用数据类型 == 比较的是地址值 // 1：在Java Heap中创建对象 2：在字符串常量池中添加 zhangsan String a = new String("zhangsan"); // 调用 intern 方法，因上一步中已经将zhangsan存入常量池中，这里直接返回常量池 zhangsan 的引用地址 String b = a.intern(); // a 的地址在Java Heap中 ， b的地址在 常量池中 ，所以结果是flase System.out.println(a == b); // 因为常量池中已经包含zhangsan，所以直接返回 String c = "zhangsan"; // b c 的地址一致，所以是true System.out.println(b == c); &#125;&#125;//结果falsetrue 解释： 1：在Java Heap中创建对象然后在字符串常量池中添加 zhangsan。 2：调用 intern 方法，因上一步中已经将zhangsan存入常量池中，这里直接返回常量池 zhangsan 的引用地址。 3：因 a 的地址在Heap中，b的地址在字符串常量池中。 4：因为常量池中已经包含zhangsan，所以直接返回 5： b c 的地址一致，所以是true 地址可以使用System.identityHashCode(a)方法获取 常量池中不存在字符串123456789101112131415161718192021public class StringTest &#123; public static void main(String[] args) &#123; //1： 首先会在Heap中创建对象，然后在常量池中放入zhagnsan 和 wangwu ，但是并不会放入zhagnsanwangwu String a = new String("zhangsan") + "wangwu"; // 2：调用 intern ，因为字符串常量池中没有”zhangsanwangwu”这种拼接后的字符串，所以将堆中String对象的引用地址添加到字符串常量池中。jdk1.7后常量池引入到了Heap中，所以可以直接存储引用 String b = a.intern(); // 3：因为 a 的地址和 b的地址一致，锁以是true System.out.println(a == b); //4：因常量池中已经存在 zhangsanwangwu 了，所以直接返回引用就是 a 类型 a ==b 锁 a==b==c String c = "zhangsanwangwu"; System.out.println(a == c); // true System.out.println(b == c); // true // 5：首先会在Heap中创建对象，然后会在常量池中存储 zhang 和 san String d = new String("zhang") + "san"; // 6： 返回的是 常量池中的 地址，因在a变量时已经将 zhangsan 放入到了常量池中 String f = d.inter(); System.out.println(d = f); // false &#125;&#125; 解释： 1：首先会在Heap中创建对象a，然后在常量池中放入zhagnsan 和 wangwu** ，但是并不会放入zhagnsanwangwu。 2：调用 intern ，因为字符串常量池中没有”zhangsanwangwu”这种拼接后的字符串，所以将堆中String对象的引用地址添加到字符串常量池中。jdk1.7后常量池引入到了Heap中，所以可以直接存储引用。 3：因为 a 的地址和 b的地址一致，所以是true。 4：因常量池中已经存在 zhangsanwangwu 了，所以直接返回引用就是 a 类型， a ==b 所以 a==b==c。 5：首先会在Heap中创建对象d，然后会在常量池中存储 zhang 和 san。 6：因在创建对象a时，已经将 “zhangsan”放入到了常量池，所以返回的是常量池中的zhangsan地址，对象d的地址在Heap中，f的地址在常量池中，并不是一个，所以false； 参考：https://blog.csdn.net/qian520ao/article/details/78966179]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔记]]></title>
    <url>%2F2019%2F06%2F18%2F%E9%9A%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[随笔记，记录一些工作中遇到的问题和解决方案。 BeanFactory 和 FactoryBean 区别BeanFactory: 是 Ioc 的核心接口，一般是内部使用，外部使用的话用ApplicationContext，具体实现有XMLBeanFactory/ClassPathXMLApplicationContext，是用来管理bean的实例化，定位、配置应用程序中的对象及建立这些对象间的依赖以及bean的生命周期。 FactoryBean: FactoryBean也是接口，实现此接口的类也是一种Bean。Spring中共有二种bean，一种是普通bean（就是上面说的BeanFactory管理的bean），另一种是实现FactoryBean接口的Bean。它更加灵活，可以根据自己的需求灵活配置bean RestTemplate 的实现方式RestTemplate其默认实现是HttpURLConnection（集成了URLConnection），这是JDK自带的REST客户端实现,还可以实现别的Http源，RestTemplate有三个构造方法： RestTemplate() RestTemplate(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) RestTemplate(ClientHttpRequestFactory requestFactory)。 我们主要看第三个，ClientHttpRequestFactory 接口的实现，如下图： 图中列出了RestTemplate的几种REST Client的封装。其中最常用的有以下三种：SimpleClientHttpRequestFactory（封装URLConnection）HttpComponentsClientHttpRequestFactory（封装HttpClient）OkHttp3ClientHttpRequestFactory (封装OKHttp) 可在里边设置超时时间等信息； String是否可以做对象锁 String为什么要设计成不可变的]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程生命周期和锁的简单使用]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2FJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了java线程的生命周期，Synchronized的几个方法简单的使用。 线程生命周期 初始状态(New)New Thread之后，&nbsp; 就绪状态(Ready)表示获取到了Cpu的执行时间片，也就是cpu的执行权，等待开始执行。&nbsp; 运行状态(Runable) 执行start之后，开始运行。&nbsp; 阻塞状态(Blocked) 在进入synchronized的临界区或者Lock的临界区，等待获取监视器(monitor)锁，线程会进入同步队列(SynchronizedQueue)中。&nbsp; 等待状态:(Waiting)在执行await(),wait(),jion(),LockSupport.park()方法进入等待状态;&nbsp; 等待超时状态 在执行Object.await(time), Object.wait(time), Object.sellp(time), LockSupport.parkUntil,lockSupport.parkNanos 进入等待超时状态。&nbsp; 终止状态线程执行完毕或者执行了Thread.interrupt() / Thread.stop()，不建议使用的Thread.stop() 因为 Thread.stop是直接强行结束，不会释放资源 ； 配图 锁的几个简单方法 wait 和 notify/notifyAll解释wait： 将线程状态置位 ‘等待状态’，进入等待队列等待。notify/notifyAll： notify是随机唤醒一个线程进入 ‘同步队列’,notifyAll是唤醒全部被监视器锁wait的线程进入 ‘同步队列’，等待获取监视器锁后继续执行。 提示：wait，notify/notifyAll都需要在获取到监视器所(monitor)后才可以进行操作。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WaitAndNotifyTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; // 创建线程 thread1 Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " begin wait..."); synchronized (obj) &#123; obj.wait(); &#125; System.out.println(Thread.currentThread().getName() + " end wait..."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "thread1"); // 创建线程 thread2 Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " begin wait..."); synchronized (obj) &#123; obj.wait(); &#125; System.out.println(Thread.currentThread().getName() + " end wait..."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "thread2"); // 启动 thread1.start(); thread2.start(); try &#123; // 睡眠一秒 Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 下面我们加上 obj.notify() 就会先输出 begin wait 然后sellp 10秒，执行obj.notify() 唤醒 thread1 线程 , 输出end wait // obj 上可能会存在wait 多个线程， notify唤醒是随机的，不一定能唤醒哪一个线程 // 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常 synchronized (obj) &#123; // 唤醒 使用呢 obj 调用 wait 方法的其中一个线程 (随机) obj.notify(); // 唤醒 使用呢 obj 调用 wait 方法的所有线程 obj.notifyAll(); &#125; &#125;&#125; 12345执行结果：thread2 begin wait...thread1 begin wait...thread1 end wait...thread2 end wait... await,signal/signalAll解释await,signal/signalAll方法是Lock Condition的方法，语义和Object的wait，notify/notifyAll是完全相同的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @Auther: lantao * @Date: 2019-04-15 14:49 * @Company: * @maill: * @Description: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁 执行singal和notify的时候也需要在等待获取锁 */ public class LockCondition &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition a = lock.newCondition(); public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); System.out.println("1"); a.await(); System.out.println(Thread.currentThread().getName() + "被唤醒了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; Runnable runnable1 = () -&gt; &#123; try &#123; lock.lock(); System.out.println("线程" +Thread.currentThread().getName() + "开始执行sinal"); a.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; new Thread(runnable,"Thread1").start(); new Thread(runnable,"Thread2").start(); Thread.sleep(100); new Thread(runnable1,"Thread3").start(); &#125; &#125; 123456执行结果：Thread1Thread2线程Thread3开始执行sinalThread1被唤醒了Thread2被唤醒了 Join 和 Join(time)解释等待调用Join的线程执行完成后再继续执行,或者等待时间超过了超时时间继续执行； 代码12345678910111213141516171819202122232425262728293031323334/** * @Auther: lantao * @Date: * @Company: * @maill: * @Description: Join 核心是等待指定线程运行完后再继续运行 Join(time) 就是等待线程执行的一个超时时间 超过了就继续执行了 */ public class JoinTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("1"); try &#123; Thread.sleep(2000L); System.out.println("正常完成"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("2"); &#125; &#125;); thread1.start(); // 执行 jion 等待线程 thread1 执行完后再继续执行 thread1.join();// thread1.join(1000); // 这样最终执行的顺序是 1 2 3 如果不增加 thread1.join() 结果可能是 312 也可能是 132 // Join 核心是等待指定线程运行完后再继续运行 System.out.println("3"); &#125; &#125; 12345执行结果：1正常完成23 yield解释yeid 方法的核心是让出 cpu 时间片 ，也就是cpu执行权，线程会直接进入就绪状态,线程调度器会从线程就绪队列里获取一个线程优先级最高的线程来执行,当然也有可能直接会去到刚刚让出cpu执行权的线程，继续执行yield 后续的代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @Auther: lantao * @Date: 2019-03-25 17:20 * @Company: * @maill: * @Description: */ public class YieldTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; if (0 / 5 == i) &#123; System.out.println(Thread.currentThread().getName() + " 开始执行 yield "); Thread.yield(); System.out.println("trhead1"); &#125; &#125; &#125; &#125;, "thread1"); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; if (0 / 5 == i) &#123; System.out.println(Thread.currentThread().getName() + " 开始执行 yield "); Thread.yield(); System.out.println("trhead2"); &#125; &#125; &#125; &#125;, "thread2"); Thread thread3 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; if (0 / 5 == i) &#123; System.out.println(Thread.currentThread().getName() + " 开始执行 yield "); Thread.yield(); System.out.println("trhead3"); &#125; &#125; &#125; &#125;, "thread3"); // 执行三个线程， 正常当运行到yield 是 就会让出cpu执行权，线程到 就绪状态，线程调度器会从 线程就绪队列里获取一个线程优先级最高的线程来执行， // 当然也有可能直接会去到刚刚让出cpu的线程，继续执行yield 后续的代码 thread1.start(); thread3.start(); thread2.start(); &#125; &#125; 12345678执行结果：thread1 开始执行 yieldthread2 开始执行 yieldthread3 开始执行 yield trhead2trhead1trhead3 interrupt 和 stop解释interrupt和stop都代表中断线程，区别是 interrupt 会释放资源而stop不会，interrupt也不会立马就中断；说道interrupt就得说一下isInterrupted方法，他是判断线程中断标志的，如果线程A执行了线程B的interrupt方法，线程B在自己的线程中也可以使用 isInterrupted 方法判断自己的中断标志。&nbsp;注意：在使用 interrupt方法时，如果线程在sleep wait wait(time)状态， 抛出InterruptedException异常后会清除 isInterrupted 方法获取的中断标志位，反之则不会 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Auther: lantao * @Date: 2019-04-17 17:18 * @Company: * @maill: * @Description: 在使用 interrupt方法是，如果线程咋sleep wait wait(time) 在抛出InterruptedException异常后会 清除 isInterrupted 方法获取的标志位 其他则不会 */ public class InterruptTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (true) &#123;&#125; &#125;, "循环线程"); Thread thread2 = new Thread(() -&gt; &#123; while (true) &#123; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "睡眠线程"); Thread thread3 = new Thread(() -&gt; &#123; Object o = new Object(); while (true) &#123; synchronized (o)&#123; try &#123; o.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, "等待线程"); thread1.start(); thread2.start(); thread3.start(); Thread.sleep(500); thread1.interrupt(); thread2.interrupt(); thread3.interrupt(); Thread.sleep(500); System.out.println("循环线程isInteryupt is " + thread1.isInterrupted()); System.out.println("睡眠线程isInteryupt is " + thread2.isInterrupted()); System.out.println("等待线程isInteryupt is " + thread3.isInterrupted()); &#125; &#125; 1234567891011121314执行结果：java.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.com.concurrenncy.InterruptTest.lambda$main$1(InterruptTest.java:20)at java.lang.Thread.run(Thread.java:748)java.lang.InterruptedExceptionat java.lang.Object.wait(Native Method)at java.lang.Object.wait(Object.java:502)at com.com.concurrenncy.InterruptTest.lambda$main$2(InterruptTest.java:32)at java.lang.Thread.run(Thread.java:748)循环线程isInteryupt is true睡眠线程isInteryupt is false等待线程isInteryupt is false]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管程含义]]></title>
    <url>%2F2019%2F06%2F14%2F%E9%94%81%2F%E7%AE%A1%E7%A8%8B%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[简单介绍管程 管程 解决互斥和同步 语义：管程的全拼就是 ‘管理共享变量以及共享变量的操作过程’，让他们支持并发， 管程的模型 模型的区别MESA,HASEN,HOARE的区别就是当条件满足，通知线程和执行的方式；&nbsp; MESAjava使用的管程模型就是MESA，当B线程执行notify或notifyAll通知A线程执行的时候，线程B还会继续执行，这时线程A会到 ‘就绪队列’ ,等待回去监视器(Monitor)锁后继续执行wait()后的方法，可以保证同一时间只有一个线程执行；&nbsp; HASENHASEN模型，要求notify或notifyALl放到放到最后执行，这样线程B执行代码全部执行完成后在执行notify通知线程A，线程A再继续执行wait()后的方法，也可以保证同一时间只有一个线程执行；&nbsp; HOAREHOARE模型,不限制notify或notifyAll的执行位置，但是线程B使用notify或notifyAll的时候，会阻塞线程B，然后执行线程A，线程A执行完成再通知线程B继续执行，同样可以保证同一时间只有一个线程在运行；]]></content>
      <categories>
        <category>管程</category>
      </categories>
      <tags>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock总结]]></title>
    <url>%2F2019%2F06%2F14%2F%E9%94%81%2FLock%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Lock在我们日常研发中经常会使用到，比如ReenTrantLock，ReentrantReadWriteLock，StampedLock (JDK1.8新增)， 下面就详细介绍一下它们的使用方法。 ReenTrantLockReenTrantLock支持公平锁和非公平锁,也是独占锁,下面来说一下ReenTrantLock下的方法和使用。 lock：获取阻塞锁。 123456789101112// 默认是费公平锁，可自定，在参数中增加 true-公平 false-非公平ReenTrantLock lockObjcet = new ReenTrantLock();try &#123; // 获取锁 ，如果获取不到则阻塞线程 lockObjcet.lock(); // 同步代码块&#125; catch (Exception e) &#123; &#125; finally &#123; // 释放锁 lockObjcet.unLock();&#125; tryLock：获取非阻塞锁，如果无法获取到锁，返回false，获取到了返回true。 123456ReenTrantLock lock = new ReenTrantLock(); if (lock.tryLock()) &#123; // 获取到了锁 &#125; else &#123; // 没有获取到锁 &#125; tryLock(time)：获取非阻塞超时锁，在time时间内如果获取到了锁，返回true，获取不到锁返回false。 1234567ReenTrantLock lock = new ReenTrantLock(); // 获取锁，如果在指定时间内还未获得，则返回false if (lock.tryLock(100)) &#123; // 获取到了锁 &#125; else &#123; // 没有获取到锁 &#125; lockInterruptibly()：获取可中断锁，和lock区别就是在获取锁的过程中可以中断线程。 unlock()：解锁 boolean isHeldByCurrentThread()：判断锁是否是当前线程持有，是返回true，不是返回false。 boolean isLocked()：判断锁是否被获取或占用。 boolean isFair()：是否是公平锁，是 返回true， 不是返回false。 Thread getOwner()：获取当前锁的拥有者， 如果有拥有者则返回拥有者，如果没有返回null。 boolean hasQueuedThreads()：判断是否有等待线程，如果有则返回true，反之false。 boolean hasQueuedThread(Thread thread)：判断入参的线程是否存在于等待队列中，如果存在则返回true，反之false。 int getQueueLength()：获取等待队列中线程总数。 Collection getQueuedThreads()：获取等待队列中的所有线程。 boolean hasWaiters(Condition condition)：否有线程在与此锁关联的给定条件上等待，有返回true 反之 false。 int getWaitQueueLength(Condition condition)：获取被参数条件等待的线程总数。 Collection getWaitingThreads(Condition condition)：获取当前锁的条件等待的所有线程. ReentrantReadWriteLock读写锁： 读锁可以多线程一起获取，写锁只有一个线程可以获取，读写锁支持公平锁和非公平锁，支持重入锁。 读锁： 可以被多个线程共同获取锁，同时进入代码块。 写锁：只允许一个线程获取，如果当前线程获取到写锁后，发现有线程获取了读锁，并且不是当前线程，这时当前线程就进入等待状态。 代码示例： 123456// 读写锁private ReadWriteLock rw = new ReentrantReadWriteLock();// 读锁 共享锁private Lock r = rw.readLock();// 写锁 排它锁private Lock w = rw.writeLock(); WriteLock lock()：写锁为独占锁，当线程A获取到了写锁时任何线程都不能获取到读锁和写锁，如果线程A获取到了写锁，但是读锁已经被线程B获取并且未释放，这时就需要将线程A状态改为等待，等待线程B释放了写锁再继续执行。 unlock()：解锁。 ReadLock lock()： 加锁。 unlock()： 解锁。 StampedLock (JDK1.8新增)StampedLock： 读写锁，但是StampedLock比ReenTrantReadWriteLock更块,但是StampedLock用于乐观读锁，悲观读锁，和写锁，StampedLock不支持重入锁，StampedLock 的悲观读锁、写锁都不支持条件变量。 tryOptimisticRead：乐观读。 readLock：悲观读。 writeLock：悲观写。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738/** * @Auther: lantao * @Date: 2019-05-05 17:55 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class StampedLockTest &#123; static StampedLock s =new StampedLock(); public static void main(String[] args) &#123; // 悲观读 long l = s.readLock(); // 释放悲观读 s.unlockRead(l); // 悲观写 long l1 = s.writeLock(); // 释放悲观写 s.unlockWrite(l1); // 乐观读 升级 悲观读 long l2 = s.tryOptimisticRead(); //验证是否被修改 如果返回false 会释放 l2，所以后续直接释放l3即可 if (!s.validate(l2))&#123; // 升级悲观读 long l3 = s.readLock(); s.unlockRead(l3); &#125; &#125;&#125; ConditionnCondition： Lock 的条件 ,其实初始化的是ConditionObject， ConditionObject是Condition的实现，singal和signlAll的时候需要在获取锁后。 await()： 线程等待，相当于Objcet的wait()方法。 awaitNanos(time)： 等待一定时间，如果超过则继续执行，相当于Object的wait(time)方法。 signal()： 随机唤醒一个被Condition.await()的线程，相当于Object的notify()方法。 signalAll()： 唤醒全部被Condition.await()的线程，相当于Object的notifyAll()方法。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @Auther: lantao * @Date: 2019-04-15 14:49 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁 执行singal和notify的时候也需要在等待获取锁 */public class LockCondition &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition a = lock.newCondition(); public static Condition b = lock.newCondition(); public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); a.await(); System.out.println(Thread.currentThread().getName() + " 的 a conndition 被唤醒了"); b.await(); System.out.println(Thread.currentThread().getName() + " 的 b conndition 被唤醒了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; Runnable runnable1 = () -&gt; &#123; try &#123; lock.lock(); System.out.println("线程" +Thread.currentThread().getName() + " 开始执行a condition sinalAll"); a.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; Runnable runnable2 = () -&gt; &#123; try &#123; lock.lock(); System.out.println("线程" +Thread.currentThread().getName() + " 开始执行b condition sinalAll"); b.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;; new Thread(runnable,"Thread1").start(); new Thread(runnable,"Thread2").start(); Thread.sleep(100); new Thread(runnable1,"Thread3").start(); Thread.sleep(100); new Thread(runnable2,"Thread4").start(); &#125;&#125;// 执行结果Thread1Thread2线程Thread3 开始执行a condition sinalAllThread1 的 a conndition 被唤醒了Thread2 的 a conndition 被唤醒了线程Thread4 开始执行b condition sinalAllThread1 的 b conndition 被唤醒了Thread2 的 b conndition 被唤醒了]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之注解扫描Component-scan]]></title>
    <url>%2F2019%2F03%2F16%2FSpring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8B%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8FComponent-scan%2F</url>
    <content type="text"><![CDATA[本文主要介绍Spring的component-scan标签，了解spring是如果实现扫描注解进行bean的注册，主要实现实在 NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 三个接口中，还需要配置 spring.handlers文件，在接下里的源码解析中会详细解析，在本篇博客中将使用ApplicationConntext作为起点，直接从差异开始讲解，如果想了解ApplicationContext 源码的全流程请看上篇博客。 GItHub:https://github.com/lantaoGitHub/spring-framework.git 这里解析解释一下他们之间的关系： NamespaceHandlerSupport 是 Abstract 修饰的抽象类 并 实现 NamespaceHandler 接口，继而实现了 NamespaceHandler接口的parser和docreate方法，自定的NamespaceHandler需要继承NamespaceHandlerSupport类并需要实现NamespaceHandler接口的init方法，init方法需要做解析类的注册操作，代码如下： 123456789101112131415161718192021222324252627282930&gt; package org.springframework.context.config;&gt; &gt; import org.springframework.beans.factory.xml.NamespaceHandlerSupport;&gt; import org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser;&gt; import org.springframework.context.annotation.ComponentScanBeanDefinitionParser;&gt; &gt; /**&gt; * &#123;@link org.springframework.beans.factory.xml.NamespaceHandler&#125;&gt; * for the '&#123;@code context&#125;' namespace.&gt; *&gt; * @author Mark Fisher&gt; * @author Juergen Hoeller&gt; * @since 2.5&gt; */&gt; public class ContextNamespaceHandler extends NamespaceHandlerSupport &#123;&gt; &gt; @Override&gt; public void init() &#123;&gt; registerBeanDefinitionParser("property-placeholder", new PropertyPlaceholderBeanDefinitionParser());&gt; registerBeanDefinitionParser("property-override", new PropertyOverrideBeanDefinitionParser());&gt; registerBeanDefinitionParser("annotation-config", new AnnotationConfigBeanDefinitionParser());&gt; registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());&gt; registerBeanDefinitionParser("load-time-weaver", new LoadTimeWeaverBeanDefinitionParser());&gt; registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());&gt; registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());&gt; registerBeanDefinitionParser("mbean-server", new MBeanServerBeanDefinitionParser());&gt; &#125;&gt; &gt; &#125;&gt; 123456789&gt; /**&gt; * Subclasses can call this to register the supplied &#123;@link BeanDefinitionParser&#125; to&gt; * handle the specified element. The element name is the local (non-namespace qualified)&gt; * name.&gt; */&gt; protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) &#123;&gt; this.parsers.put(elementName, parser);&gt; &#125;&gt; BeanDefinitionParser类是解析类的顶层接口，自定义的解析类需要实现BeanDefinitionParser类的Parser方法，解析类的注册就在NameSpaceHandler的init方法中年进行； 还是先看一下测试类： 12345678910package lantao.scan;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ScanTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-bean-scan.xml"); &#125;&#125; xml文件中use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller，@Component和@Repository 的注解的类进行扫描 ,如果定位为false的话，就需要进行自定义include-filter。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller和@Repository 的注解的类进行扫描 --&gt; &lt;context:component-scan base-package="lantao.scan" use-default-filters="false"&gt; &lt;!-- 只扫描 base-package 的 controller 注解 还有对应的 exclude-filter 标签 排除 ； use-default-filters="false" 和 include-filter 一起使用 和 exclude-filter一起回抛异常--&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 因为这里使用ApplicationContext，ApplicationContext在上篇文章已经进行了源码解读，接下来我们直接看差异点。 差异代码在DefaultBeanDefinitionDocumentReader类中的parseBeanDefinitions方法中： 123456789101112131415161718192021222324252627282930/** * Parse the elements at the root level in the document: * "import", "alias", "bean". * @param root the DOM root element of the document */protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; //验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //对默认标签处理 // 这里只处理 nade namespace 为 http://www.springframework.org/schema/beans 的标签 parseDefaultElement(ele, delegate); &#125; else &#123; //对自定义标签处理 会解析 &lt;context:component-scan base-package="lantao.scan"/&gt; 或者自定义 dubbo delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //对自定义标签处理 delegate.parseCustomElement(root); &#125;&#125; 主要差异就在 parseDefaultElement(ele, delegate) 和 delegate.parseCustomElement(ele) 方法上，parseDefaultElement方法仅仅会处理node的namespace是：http://www.springframework.org/schema/beans 的标签，其他标签和 自定义标签全部都是通过这个方法来解析的； delegate.parseCustomElement源码： 123456789101112131415161718192021222324@Nullablepublic BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;@Nullablepublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) &#123; // 获取node的 NameSpaceURI String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) &#123; return null; &#125; // 解析自定义标签 需要在 Meta-inf 文件加 增加 spring.handlers 文件 例如：http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler // 根据指定的 NameSpaceURI 获取 NamespaceHandler handler可以参考spring.handlers文件 // abstract NamespaceHandlerSupport 实现了 NamespaceHandler 接口，继而实现了 NamespaceHandler 的两个个方法（parser，docreate），自定义handler 需要实现 NamespaceHandlerSupport 类 // 进行 NamespaceHandler 类的 init 方法的 实现， 主要是做注册 BeanDefinitionParser（ registerBeanDefinitionParser ） ， 需要自定义解析类 继承 BeanDefinitionParser 类 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele); return null; &#125; // 解析操作 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 这里代码很简单，只做了一下三件事情： 1：获取Element的NamespaceUri； 2：通过命名空间处理解析器(NamespaceHandlerResolver)的resolver方法进行NameSpaceHandler的处理； 3：通过NameSpaceHandler的Parse方法进行标签解析； 我们直接看 resolve方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Locate the &#123;@link NamespaceHandler&#125; for the supplied namespace URI * from the configured mappings. * @param namespaceUri the relevant namespace URI * @return the located &#123;@link NamespaceHandler&#125;, or &#123;@code null&#125; if none found */@Override@Nullablepublic NamespaceHandler resolve(String namespaceUri) &#123; // 这里获取的是所有注册到 handlerMappings 中的 NamespaceHandler ， // 就是 resource/META-INF/spring.handler 中的类 key就是namespaceUri ， // 这些类都继承了 NamespaceHandlerSupport 实现了init方法 在init方法中进行 BeanDefinitionParse 的注册 Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); // 通过 namespaceUri 在 handlerMappings 中获取对应的处理器或者 className 如果是初始化过的就直接返回，反之进行类初始化工作 Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; try &#123; // 实例化 Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); // 判断实例化的类的超类或者超级接口 是否是 NamespaceHandler if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.class.getName() + "] interface"); &#125; NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); // 注册 自定义标签所对应的 解析策略类 解析策略类都继承了 BeanDefinitionParser ，比如 ComponentScanBeanDefinitionParser namespaceHandler.init(); // 放入缓存中 handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125; catch (ClassNotFoundException ex) &#123; throw new FatalBeanException("Could not find NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", ex); &#125; catch (LinkageError err) &#123; throw new FatalBeanException("Unresolvable class definition for NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", err); &#125; &#125;&#125; 这里主要做了一件事情，就是获取nameSpaceUri对应的NameSpaceHandler,首先会调动getHandlerMappings方法获取全部的NameSpaceHandler，然后通过namespaceUri获取对应的NameSpaceHandler，如果还未实例化则进行实例化操作执行init方法向parsers注册解析类，反之直接返回；getHandlerMappings方法获取的NameSpaceHandler是解析于resource/META-INF/spring.handler 文件下, key就是namespaceUri,value就是自定义的NameSpaceHandler； getHandlerMappings方法源码： 1234567891011121314151617181920212223242526272829303132/** * Load the specified NamespaceHandler mappings lazily. */private Map&lt;String, Object&gt; getHandlerMappings() &#123; Map&lt;String, Object&gt; handlerMappings = this.handlerMappings; if (handlerMappings == null) &#123; synchronized (this) &#123; handlerMappings = this.handlerMappings; if (handlerMappings == null) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Loading NamespaceHandler mappings from [" + this.handlerMappingsLocation + "]"); &#125; try &#123; // 这里的handlerMappingsLocation指定的地址就是 resources 中的 META-INF/spring.handlers Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader); if (logger.isTraceEnabled()) &#123; logger.trace("Loaded NamespaceHandler mappings: " + mappings); &#125; handlerMappings = new ConcurrentHashMap&lt;&gt;(mappings.size()); CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings); this.handlerMappings = handlerMappings; &#125; catch (IOException ex) &#123; throw new IllegalStateException( "Unable to load NamespaceHandler mappings from location [" + this.handlerMappingsLocation + "]", ex); &#125; &#125; &#125; &#125; return handlerMappings;&#125; getHandlerMappings就是解析spring.handler文件和执行NameSpaceHandler的init方法并放入缓存的操作，NameSpaceHandler获取到了以后我们看一下init注册的BeanDefinitionParser的parser方法； NameSpaceHandlerSupport的parse方法源码： 1234567891011/** * Parses the supplied &#123;@link Element&#125; by delegating to the &#123;@link BeanDefinitionParser&#125; that is * registered for that &#123;@link Element&#125;. */@Override@Nullablepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 在 NamespaceHandlerSupport 中的 parser 集合中获取 BeanDefinitionParser 的实现类 进行 parser BeanDefinitionParser parser = findParserForElement(element, parserContext); return (parser != null ? parser.parse(element, parserContext) : null);&#125; parse方法做了两件事情： 1：通过定义的标签属性(例如：**component-scan**)获取对应的BeanDefinitionParser解析类，源码如下： 1234567891011121314151617/** * Locates the &#123;@link BeanDefinitionParser&#125; from the register implementations using * the local name of the supplied &#123;@link Element&#125;. */@Nullableprivate BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; // 这里判断各种标签的解析策略 获取标签名字 String localName = parserContext.getDelegate().getLocalName(element); // 从 parsers 中获取对应的解析策略类 parsers 是在 NameSpaceHandler 的 init 方法是初始化的； BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( "Cannot locate BeanDefinitionParser for element [" + localName + "]", element); &#125; // 返回对应的策略类进行解析 return parser;&#125; 2：开始解析； parse方法源码： 1234567891011121314151617181920212223@Override@Nullablepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 获取 basePackage 的 路径 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); // 解析给定文本中的$&#123;.&#125;，将其替换为由&#123;@link #getProperty&#125;解析的相应属性值 就是可以使用 $&#123;&#125; 和 properties中的值对应 basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); //我们这里在设置 base-package 的值时, 可以通过上面指示的分隔符 ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS 进行多个package的指定. 可以使用”,” “;” “\t\n(回车符)”来分割多个包名 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. // 下面的代码就是 实际扫描bean定义并注册它们。 // 配置 ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // 扫描 并 注册 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 处理 annotation-config registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null;&#125; parse方法主要做了以下五件事情： 1：获取basePackage的值，就是xml中配置的路径地址； 2：basePackage可以配置多个，使用 ‘,’ ‘;’ 或者回车符 进行分割； 3：初始化ClassPathBeanDefinitionScanner，后边的解析操作有ClassPathBeanDefinitionScanner来完成； 4：扫描并注册bean； 5：处理annotation-config(这个后续会详细讲解，这里就不赘述了) 先看一下configureScanner方法源码： 123456789101112131415161718192021222324252627282930313233343536373839404142protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123; boolean useDefaultFilters = true; // 设置 use-default-filters 标签 use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller和@Repository 的注解的类进行扫描 if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123; useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); &#125; // Delegate bean definition registration to scanner class. // 将注册Bean的任务委托给ClassPathBeanDefinitionScanner类。初始化 ClassPathBeanDefinitionScanner ，ClassPathBeanDefinitionScanner 是解析conponentScanner 的类 ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); // set RESOURCE_PATTERN_ATTRIBUTE 设置 扫描Resource(资源) 路径 默认为 "**/*.class" if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123; scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); &#125; try &#123; // set name-generator // 初始化bean 名称生成器 parseBeanNameGenerator(element, scanner); &#125; catch (Exception ex) &#123; parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); &#125; try &#123; // 设置bean作用域 parseScope(element, scanner); &#125; catch (Exception ex) &#123; parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); &#125; // 设置扫描包含 和 排除的 注解 // 设置过滤器，即用于指定哪些类需要被处理，哪些类需要被忽略 // set INCLUDE_FILTER_ELEMENT and EXCLUDE_FILTER_ELEMENT parseTypeFilters(element, scanner, parserContext); return scanner;&#125; configureScanner方法主要做了以下五件事： 1：获取并设置use-default-filters，use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller和@Repository 的注解的类进行扫描，如果设置为false，则需要自行对include-filter添加； 2：初始化ClassPathBeanDefinitionScanner，如果use-default-filters为true则对include-filter进行add操作； 3：初始化bean 名称生成器； 4：设置bean作用域； 5：设置扫描包含 和 排除的 注解，include-filter和exclude-filter； 上述代码就不展现了，git上代码有对应的注释； 接下来看scanner.doScan方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Perform a scan within the specified base packages, * returning the registered bean definitions. * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor * but rather leaves this up to the caller. * @param basePackages the packages to check for annotated classes * @return set of beans registered if any for tooling registration purposes (never &#123;@code null&#125;) */protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, "At least one base package must be specified"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;(); // 循环扫描 for (String basePackage : basePackages) &#123; // 获取指定包下所有 BeanDefinition Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; // 获取一个ScopeMetadata对象，默认为AnnotationScopeMetadataResolver // 如果目标类未被@Scope注解，则返回一个默认的ScopeMetadata ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); // 使用bean名称生成器生成bean名称，默认生成器为AnnotationBeanNameGenerator // 首先是以注解的value为bean名称，如果注解的value没有值，则使用默认的名称 String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; // 处理定义在目标类上的注解，包括@Lazy, @Primary, @DependsOn, @Role, @Description // 这里会检查和 设置 AnnotatedBeanDefinition 的 @Lazy(懒加载) @Primary(主要，https://www.cnblogs.com/liaojie970/p/7885106.html) @DependsOn(需要依赖但不需要持有) 注解 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; // 检查beanName是否已经存在 BeanDefinitionRegistry 中存在。 if (checkCandidate(beanName, candidate)) &#123; //beanName 还没使用过 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); // 如果有必要，则创建作用域代理 // 如果创建了代理，则返回表示代理对象的BeanDefinitionHolder definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册Bean registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions;&#125; 看以下在doScan方法中都做了什么： 1：获取指定包下(指定的basePackage)所有 BeanDefinition； 2：获取一个ScopeMetadata对象，默认为AnnotationScopeMetadataResolver，如果目标类未被@Scope注解，则返回一个默认的ScopeMetadata； 3：使用bean名称生成器生成bean名称，默认生成器为AnnotationBeanNameGenerator，如果注解上的value值是null，则需要生成； 4：设置AutowireCandidate autowire-candidate=”false” 表示该对象不参与自动注入，借鉴：https://blog.csdn.net/shangboerds/article/details/72758095 5：处理定义在目标类上的注解，包括@Lazy, @Primary, @DependsOn, @Role, @Description，这里会检查和设置 AnnotatedBeanDefinition 的 @Lazy(懒加载) @Primary(主要，https://www.cnblogs.com/liaojie970/p/7885106.html) @DependsOn(需要依赖但不需要持有) 注解； 6：检查beanName是否已经存在 beanDefinitionMap 中存在； 7：如果设置了scopedProxyMode，则需要创建代理类和注册代理类； 8：调用registerBeanDefinition注册bean，就是put到beanDefinitionMap中； 这里只说核心的scanCandidateComponents方法，其他的方法都很简单，读者自行通过debug来做就可以了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); try &#123; // ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX = "classpath*:"; // 通过观察resolveBasePackage()方法的实现, 我们可以在设置basePackage时, 使用形如$&#123;&#125;的占位符, Spring会在这里进行替换 // this.resourcePattern 默认为 "**/*.class" resourcePattern 可以再xml中配置 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 使用上面拼接出的形如 "classpath*:xx/yyy/zzz/**/*.class", 将其检索为Spring内置的Resource对象(这样就统一化了资源的差异) // 使用ResourcePatternResolver的getResources方法获取 路径下全部 比如：classpath*:lantao/scan/**/*.class Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) &#123; if (traceEnabled) &#123; logger.trace("Scanning " + resource); &#125; // file是否可读 if (resource.isReadable()) &#123; try &#123; // 获取元数据 元数据就是用来定义数据的数据 就是定义 class 的 属性 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // 根据锅炉器来判断是否符合要求 做 includeFilters excludeFilters 的判断 if (isCandidateComponent(metadataReader)) &#123; // 实例化 ScannedGenericBeanDefinition ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); // 判断类必须是一个具体的实现类，并且它的实例化必须是独立的 if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug("Identified candidate component class: " + resource); &#125; candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug("Ignored because not a concrete top-level class: " + resource); &#125; &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace("Ignored because not matching any filter: " + resource); &#125; &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( "Failed to read candidate component class: " + resource, ex); &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace("Ignored because not readable: " + resource); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex); &#125; return candidates;&#125; 这里主要就是做了通过ResourcePatternResolver的getResource获取指定路径的资源文件，再通过资源文件Resource获取MetadataReader (元数据就是用来定义数据的数据 就是定义 class 的 属性),接下来通过isCandidateComponent方法来做核心处理，因为通过路径获取的资源是全部的，不是想要的，通过isCandidateComponent方法来做 ncludeFilters excludeFilters 的判断，再通过isCandidateComponent(sbd)判断BeanDefinition必须是一个实现类，不可以是接口等； 我们看一下核心判断方法isCandidateComponent： 12345678910111213141516171819202122/** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException &#123; // 判断 excludeFilters 的 TypeFilter for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, getMetadataReaderFactory())) &#123; return false; &#125; &#125; // 判断逻辑 includeFilters 中的 TypeFilter 默认包含的filter有 @components 和 引用他的 @service @controller @Repository for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, getMetadataReaderFactory())) &#123; // 判断 @Conditional ， @Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。 还有 @ConditionalOnXX 等注解 return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; 12345678910111213141516/** * Determine whether the given bean definition qualifies as candidate. * &lt;p&gt;The default implementation checks whether the class is not an interface * and not dependent on an enclosing class. * &lt;p&gt;Can be overridden in subclasses. * @param beanDefinition the bean definition to check * @return whether the bean definition qualifies as a candidate component */protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; AnnotationMetadata metadata = beanDefinition.getMetadata(); // metadata.isIndependent() 是独立的 &amp; // metadata.isConcrete() 是否是接口或者是抽象类 或 // 必须是抽象类 和 有@lookup 注解 return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() || (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));&#125; 到这里就已经讲完了Component-scan扫描注入的源码，这里涉及代理和annotation-config没有做详细的讲解，会在后续的文章中做，码字不易，转发请注明出处：https://blog.csdn.net/qq_30257149/article/details/88596355 博客地址：https://lantaogithub.github.io]]></content>
      <categories>
        <category>spring源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
        <tag>Component-scan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2019%2F03%2F14%2FJvm%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文简单介绍了Java内存模型丶Volatile和Synchronized的语义 volatile 语义:&nbsp; &nbsp; &nbsp; &nbsp; volatile具有和synchronized的一样的语义,被volatile修饰的变量在 ‘读’ 时JMM会将该线程所对应的’本地内存’置为失效，线程接下来会从 ‘主内存’ 中直接获取，在 ‘写’ volatile 修饰的变量时JMM会将该线程对应的本地内存的共享变量直接写入到 ‘主内存’ 中。 使用&nbsp; &nbsp; &nbsp; &nbsp; 被volatile修饰的变量将会 ‘禁用缓存’ , 并且禁止 ‘指令重排’（指令重排分为虚拟机重排和处理器重排）&nbsp; &nbsp; &nbsp; &nbsp; volatile 声明这个字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性。&nbsp; &nbsp; &nbsp; &nbsp; static 声明这个字段是静态的（可能被多个实例共享），在主存区上该类的所有实例的该字段为同一个变量，即唯一性。 代码1private volatile String a; synchroized 语义：&nbsp; &nbsp; &nbsp; &nbsp; 在进入synchronized修饰的方法或代码块时会进行lock操作，并且JMM会将线程本地内存清空,临界区内使用共享变量将从’主内存’中同步,在出synchronized修饰的方法或代码块时会进行unlock操作，并且JMM会将线程的本地内存的共享变量刷新到主内存中。&nbsp; 使用:&nbsp; &nbsp; &nbsp; &nbsp; synchronized是java内置锁,可以放在 ‘普通方法’ ‘静态方法’ 和 ‘代码块’ 上,如果是放在普通方法上则代表着 ‘锁的是当前对象’,放在静态方法上 ‘锁的是类(.class)’ ,如果是synchronized代码块写法则是synchronized(‘需要锁的对象或者是类’){‘临界区’}。注：synchronized锁的是一个对象而不是某个方法&nbsp; 代码：1234567891011//锁的是当前对象public synchronized void test()&#123;&#125;//锁的是类(.class)public static synchronized void test1()&#123;&#125;//这里锁的是this 也就是当前对象public void test3()&#123; synchronized (this)&#123; // 这里代表临界区 &#125; 可见性·原子性和有序性 语义&nbsp; &nbsp; &nbsp; &nbsp; 可见性 就是指线程A在修改共享变量后线程B你能立马看的到，称之为可见性。&nbsp; &nbsp; &nbsp; &nbsp; 原子性 就是指一个操作或一组操作不可中断，要么全部执行，要么全都不执行，称之为原子性。（操作的中间状态对外不可见）&nbsp; &nbsp; &nbsp; &nbsp; 有序性 就是指程序按照我们的代码顺序进行执行，称之为有序性(程序员以为是按照我们的代码顺序执行的，其实经过了虚拟机和处理器指令重排后的顺序执行的)。 java内存模型 运行时数据区域&nbsp; &nbsp; &nbsp; &nbsp; java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图：&nbsp;&nbsp; 虚拟机栈&nbsp; &nbsp; &nbsp; &nbsp;虚拟机栈是线程私有的，也可以称之为线程栈，虚拟机栈所描述的就是java执行方法的一个简易版内存模型，每个方法在执行时都会创建 ‘栈帧’ 用于存存储:局部变量表：存放方法参数和方法内部定义的局部变量操作数栈： 其实就是在执行每一行命令，操作记录动态链接:指向运行时常量池的引用,因为在方法执行的过程中有可能需要用到类中的常量方法出口:方法返回地址当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址’ 等信息’局部变量表：存储各种基本数据类型，包括 byte,short,int,long,float,dubbo,char,boolean 和 对象引用(引用类型不是对象本身，是一个指向对象的一个地址) &nbsp; 本地方法栈&nbsp; &nbsp; &nbsp; &nbsp;本地方法栈和虚拟机栈是一样的，区别就是虚拟机栈是为java方法(也就是字节码)服务的，本地方法栈是为虚拟机使用到的Native服务的。(可以理解为是操作系统的方法)&nbsp; 程序计数器&nbsp; &nbsp; &nbsp; &nbsp;程序计数器也是线程私有的，大白话意思就是存储线程的执行地址，因为java多线程是通过Cpu时间片轮询方式执行的，比如线程A执行到一半，Cpu时间片使用完了，这时线程A就会在自己的程序计数器中存储执行地址保证下次从这里开始继续执行，然后线程B开始执行。&nbsp; Java堆&nbsp; &nbsp; &nbsp; &nbsp; java堆就是存储所有对象的实例,数组(数组引用是存放在Java栈中的)和常量池，也是最大的一块内存，-xms 初始堆大小 和-xmx最大堆大小&nbsp; 方法区&nbsp; &nbsp; &nbsp; &nbsp; 方法区也是线程共享的区域，存储已经被虚拟机加载的类信息（包括类的名称、方法信息、字段信息），常量和静态变量，(在1.8之前也叫用永久代，之后称之为元空间,使用的是本地内存)&nbsp; 常量池 存在于方法区中&nbsp; &nbsp; &nbsp; &nbsp; 常量池 (jdk1.7 后常量池移到堆中)也可以说是String常量池，因为String是final修饰的，是常量且不可变。 代码： 12345678910111213// 以下代码JMM就会在常量池中查找"lantao"是否存在，如果存在则将地址赋值给a，如果不存在则先创建一个存储在常量池中然后将地址赋值给a； String a = "lantao";// 以下代码会创建你String对象，区别就是 //1-创建String对象；//2-在常量池中查；找"lantao"，如果存在则赋值给1，如果不存在则在常量池中创建'lantao'再将地址赋值给1；//3：String对象将地址赋值个变量b； String b = new String("lantao");// 所以 这里是 false ，因为地址不一样，// b的地址指向的是 heap 中的String，String对象在只指向常量池中的'lantao'// a的地址是直接指向 常量池中的'lanntao' System.out.println(a == b); //false 图片： java内存模型的8个操作1–lock(加锁)：用在主内存变量上，标记这个变量是一个线程独占状态，其他线程不可锁定；2–unlock(解锁)：用在主内存变量上，对已经加锁的变量进行解锁，释放锁后其他线程可进行对该变量的加锁；3–read(读取):用在主内存上，将主内存中的变量读取到线程本地内存中，以便后续的load操作；4–load(载入)：用在线程的本地内存上，将read读取到本地内存的变量载入到本地内存的变量副本中(这里个人理解是载入到虚拟机栈(线程栈)的栈帧中的局部变量表中)5–use(使用)：用在线程本地内存上，把本地内存的变量给执行引擎，每当需要使用这个变量的值字节码指令会执行这个操作(大白话就是使用变量);6–assign(赋值)：用在线程本地内存上，把执行引擎获取到的值赋值本地内存的变量，每当需要使用这个变量的值字节码指令会执行这个操作(大白话就是给变量赋值)7–store(存储)：用在本地内存上，将本地你内存中的变量的值存储到主内存中；8–write(写入)：用在主内存上，把store操作从本年内存获取的值放入到主内存的变量中；&nbsp; java内存模型操作的规则1–不允许read和load,store和write单独使用，需要组合使用;2–不允许线程丢弃它assign过的变量，意思就是只要是变量在本地内存中变更了，就一定要同步到主线程中；3–不允许线程在没有assign过变量，就将变量同步到主内存中，意思就是不允许线程在没有改变过变量的前提下，将变量store write到主内存中；4–一个新的变量只能在主内存中诞生，意思就是在使用变量必须是从主内存read load下来的;(原文意思：对一个变量实施use，store之前，必须要执行过assign和load)5–一个变量同一时间只可以让一个线程lock，并切可以让这个线程lock多次，但也需要unlock多次才可以解锁；6–一个变量被线程lock时，线程的本地内存将会被清空，在使用变量的时候需要进行load或assign操作来初始化；7–变量在为为lock的时候，不可以unlock，当然，也不可以unlock别的线程lock的变量；8–对一个变量unlock之前，需要将assign过的变量都store，write到主内存中；]]></content>
      <categories>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Srping源码之BeanFactory.getBean]]></title>
    <url>%2F2019%2F03%2F01%2FSpring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%2FSrping%E6%BA%90%E7%A0%81%E4%B9%8BBeanFactory.getBean%2F</url>
    <content type="text"><![CDATA[本文是针对Srping的BeanFactory.getBean来进行源码解析,如果您是第一次看请先看一下XMLBeanFactory解析：https://blog.csdn.net/qq_30257149/article/details/87972291， 可以更好的理解Spring的注册原理，本篇博客是跟源码一步步看spring怎么实现getBean源码，Spring版本为5.X,源码已经在每一行上加了注释，方便读者学习。** GItHub:https://github.com/lantaoGitHub/spring-framework.git 废话不多说，我们直接看源码： 12345678910111213141516package org.springframework.lantao;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class XmlBeanFactoryTest &#123; public static void main(String[] args) &#123; ClassPathResource classPathResource = new ClassPathResource("spring-bean.xml"); BeanFactory beanFactory = new XmlBeanFactory(classPathResource); UserBean userBean = (UserBean) beanFactory.getBean("userBean"); System.out.println(userBean.getName()); &#125;&#125; XMLBeanFactory解析就不多说了，如果没看过的可以去看我上一篇文章，这里直接看BeanFactory.getBean() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 /** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */@SuppressWarnings("unchecked")protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //获取实例名字 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 检查单例缓存中是否存在实例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.trace("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 原型 循环引用 抛异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else if (requiredType != null) &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; else &#123; return (T) parentBeanFactory.getBean(nameToLookup); &#125; &#125; if (!typeCheckOnly) &#123; // 将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存，以便重复创建指定的bean markBeanAsCreated(beanName); &#125; try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); &#125; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", ex); &#125; &#125; &#125; // Create bean instance. // 创建bean实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'"); &#125; try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return convertedBean; &#125; catch (TypeMismatchException ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; doGetBean的源码比较长，那它都做了哪些事情呢： 1：转换对应的beanname，可能有很多人不理解，传入进来的不就应该是beanName嘛，其实传入的可能是BeanFactory，也可能是别名，如果是BeanFactory,就要去除它的修饰符，比如传入进来的&amp;aa，就要转换成aa，但如果传入进来的是别名，就要取alias对应的最终的beanName，例如别名A指向了B的bean则返回B的beanName，如果别名A指向了别名B，别名B指向了C,则要返回C的BeanName； 2：检查单例中是否存在实例，会先从缓存中获取，下面会详细讲解； 3：判断原型实例是否存在循环依赖，比如A中有B，B中有A，这种情况只有单例模式才会尝试去创建，因为单例模式会提早包曝光实例，存在缓存中，原型模式是不允许的，会抛出类正在创建异常； 4：通过父BeanFactory获取bean； 5：将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存 6：获取RootBeanDefinition，在XmlBeanFactory解析的时候会将bean注册到beanDefinitionMap中，这里就是在beanDefinitionMap中get，如果不存在则会抛出bean not found异常，同时会将GenericBeanDefinition转换成RootBeanDefinition，因为存入时时GenericBeanDefinition； 7：检查BeanDefinition是否是abstract，如果是则抛出，bean is Aastract异常； 8：检查依赖，保证该bean所以依赖的bean都已经初始化，首先这里要了解depends-on用来表示一个bean A的实例化依靠另一个bean B的实例化， 但是A并不需要持有一个B的对象，如果需要的话就不用depends-on；不理解可以看这篇文章 9：判断bean的类型，是single还是proptotype，对应的创建bean，或者没有指定scope的判断，其中出现最多的方法就是getObjectForBeanInstance，后续会一点点的解析它的源码； 接下里我们先看单例缓存获取： 123456789101112131415161718192021222324252627282930313233/** * Return the (raw) singleton object registered under the given name. * &lt;p&gt;Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or &#123;@code null&#125; if none found */@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); //检查缓存中是否存在实例 isSingletonCurrentlyInCreation 该实例是否在创建中 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; //如果缓存中实例为null 则锁定全局变量singletonObjects并进行处理 synchronized (this.singletonObjects) &#123; //尝试从earlySingletonObjects (创建中提早曝光的beanFactory) 获取bean singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; //尝试从singletonFactories获取beanFactory ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; //返回获取到的bean singletonObject = singletonFactory.getObject(); //增加缓存 this.earlySingletonObjects.put(beanName, singletonObject); //删除缓存 this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125; 首先单例是只允许创建一次，并且单例支持解决循环依赖，第一步会从singletonObjectsMap中获取单例，如果发现不存在的话，再通过singletonsCurrentlyInCreation判断下当前bean是否在创建，如果是则从提前曝光的Map earlySingletonObjects中获取，如果依旧不能存在则在singletonFactories中获取BeanFactory，通过getBean进行返回，反之结束了，缓存没有，只能去重新创建了； 接下来看isPrototypeCurrentlyInCreation 12345678910/** * Return whether the specified prototype bean is currently in creation * (within the current thread). * @param beanName the name of the bean */ protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123; Object curVal = this.prototypesCurrentlyInCreation.get(); return (curVal != null &amp;&amp; (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName)))); &#125; 在这里判断了原型实例是否存在循环依赖，比如A中有B，B中有A，这种情况只有单例模式才会尝试去创建，因为单例模式会提早包曝光实例，存在缓存中，原型模式是不允许的，会抛出类正在创建异常 markBeanAsCreated方法源码： 1234567891011121314151617181920if (!typeCheckOnly) &#123; // 将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存 markBeanAsCreated(beanName); &#125;protected void markBeanAsCreated(String beanName) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; synchronized (this.mergedBeanDefinitions) &#123; if (!this.alreadyCreated.contains(beanName)) &#123; // Let the bean definition get re-merged now that we're actually creating // the bean... just in case some of its metadata changed in the meantime. clearMergedBeanDefinition(beanName); this.alreadyCreated.add(beanName); &#125; &#125; &#125;&#125; 在上述源码中我们可以看到，这段代码的含义就是讲指定的bean标记为已经在创建或者即将创建；在clearMergedBeanDefinition方法中可以看到，如果没有标记bean正在创建则会删除BeanDefinnition，接下来会重新创建； 继续看getMergedLocalBeanDefinition源码: 12345678910111213141516/** * Return a merged RootBeanDefinition, traversing the parent bean definition * if the specified bean corresponds to a child bean definition. * @param beanName the name of the bean to retrieve the merged definition for * @return a (potentially merged) RootBeanDefinition for the given bean * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @throws BeanDefinitionStoreException in case of an invalid bean definition */protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException &#123; // Quick check on the concurrent map first, with minimal locking. RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); if (mbd != null) &#123; return mbd; &#125; return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));&#125; 在getBeanDefinition方法中，spring是直接从DefaultListAbleBeanFactory中的beanDefinitionMap获取注册时的BeanDefinition； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Return a RootBeanDefinition for the given bean, by merging with the * parent if the given bean's definition is a child bean definition. * @param beanName the name of the bean definition * @param bd the original bean definition (Root/ChildBeanDefinition) * @param containingBd the containing bean definition in case of inner bean, * or &#123;@code null&#125; in case of a top-level bean * @return a (potentially merged) RootBeanDefinition for the given bean * @throws BeanDefinitionStoreException in case of an invalid bean definition */ protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException &#123; synchronized (this.mergedBeanDefinitions) &#123; RootBeanDefinition mbd = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) &#123; mbd = this.mergedBeanDefinitions.get(beanName); &#125; if (mbd == null) &#123; if (bd.getParentName() == null) &#123; // Use copy of given root bean definition. if (bd instanceof RootBeanDefinition) &#123; mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); &#125; else &#123; mbd = new RootBeanDefinition(bd); &#125; &#125; else &#123; // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try &#123; String parentBeanName = transformedBeanName(bd.getParentName()); if (!beanName.equals(parentBeanName)) &#123; pbd = getMergedBeanDefinition(parentBeanName); &#125; else &#123; BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) &#123; pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); &#125; else &#123; throw new NoSuchBeanDefinitionException(parentBeanName, "Parent name '" + parentBeanName + "' is equal to bean name '" + beanName + "': cannot be resolved without an AbstractBeanFactory parent"); &#125; &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, "Could not resolve parent bean definition '" + bd.getParentName() + "'", ex); &#125; // Deep copy with overridden values. mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); &#125; // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) &#123; mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON); &#125; // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123; mbd.setScope(containingBd.getScope()); &#125; // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null &amp;&amp; isCacheBeanMetadata()) &#123; this.mergedBeanDefinitions.put(beanName, mbd); &#125; &#125; return mbd; &#125; &#125; 在getMergedBeanDefinition方法中做了几件事情： 1：首先从缓存中mergedBeanDefinitions获取BeanDefinition 2：通过有参构造方法初始化RootBeanDefinition，这里的实例化涉及到一些参数的Set操作，具体代码就不展示了，在AbstractBeanDefinition的有参构造方法中； 3：指定bean的scope； 4：把RootBeanDefinition加入缓存mergedBeanDefinitions中； 在这里只是实例化就不多说了具体的DeBug一下就明白了，很简单； 我们继续看checkMergedBeanDefinition方法： 123456789101112131415/** * Check the given merged bean definition, * potentially throwing validation exceptions. * @param mbd the merged bean definition to check * @param beanName the name of the bean * @param args the arguments for bean creation, if any * @throws BeanDefinitionStoreException in case of validation failure */protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) throws BeanDefinitionStoreException &#123; if (mbd.isAbstract()) &#123; throw new BeanIsAbstractException(beanName); &#125;&#125; checkMergedBeanDefinition方法是判断BeanDefinition是否是Abstract，如果是则抛出beanIsAbstractException，这里就不过多解释了,学过java的都懂； 接下来就要看当前Bean的依赖，需要先实例化依赖： 12345678910111213141516171819// Guarantee initialization of beans that the current bean depends on.// 保证当前bean所依赖的bean的初始化。String[] dependsOn = mbd.getDependsOn();if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); &#125; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", ex); &#125; &#125;&#125; 在这个方法中，如果当前Bean是有依赖的话就会先去GetBean他的依赖，保证当前bean的所有依赖都是初始化过可用的，getBean大家都不陌生吧，就是BeanFactory的getBean； 下面我们看bean的创建流程singleton: 1234567891011121314// Create bean instance.// 创建bean实例if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125; 上述代码就是创建Bean的一个主方法，首先是调用了getSingleton，接着又用lambda执行了createBean方法，紧着这又调用了getObjectForBeanInstance方法； 先来看createBean再看getSingleton方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Creating instance of bean '" + beanName + "'"); &#125; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 锁定class根据class 属性或者className 来解析class Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. try &#123; // 方法注入准备 mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 给BeanPostProcessors一个返回代理而不是目标bean实例的机会 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex); &#125; try &#123; // 实例化 创建 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) &#123; logger.trace("Finished creating instance of bean '" + beanName + "'"); &#125; return beanInstance; &#125; catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123; // A previously detected exception with proper bean creation context already, // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry. throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex); &#125;&#125; 上述代码做了什么： 1：解析class，如果BeanDefinition中存在beanClass，则直接返回，反之需要通过ClassLoader加载，代码就不发了，可自行看源码； 2：方法注入，就是lookup-method的注入注入方式，这里就不多赘述了，可看上一遍文章； 3：spring的原文解释是给BeanPostProcessors一个返回代理而不是目标bean实例的机会，这里涉及Aop的代理，后续文章会详细解释； 4：调用doCreateBean进行创建，我们直接看doCreateBean方法： doCreateBean方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //使用对应的策略创建实例 比如工厂 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 是否需要提前暴露， 单例&amp;允许循环依赖&amp;当前bean正在创建中 singletonsCurrentlyInCreation在DefaultSingletonBeanRegistry 225行创建，在创建bean之前记录 正在创建bean boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; // 在bean未实例化之前加入到缓存中，单例支持循环依赖 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 对bean进行补充，属性注入，bean依赖 populateBean(beanName, mbd, instanceWrapper); //调用初始化方法 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); &#125; &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); //earlySingletonReference 再有在检查循环依赖的时候才不为空 if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " + "bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); &#125; return exposedObject;&#125; 上述代码中描述了创建bean的流程但是真正的createBean还不是在这个方法，在createBeanInstance中，我们先看看CreateBeann方法都做了什么： 1：使用对应的策略创建实例 createBeanInstance方法； 2：判断是否提前暴露，条件是（ 单例&amp;允许循环依赖&amp;当前bean正在创建中 singletonsCurrentlyInCreation在DefaultSingletonBeanRegistry 225行创建，在创建bean之前记录 正在创建bean），如果需要则调用addSingletonFactory方法在bean未实例化之前加入到缓存中，单例支持循环依赖； 3：对bean进行补充，属性注入，bean依赖；对ByName，ByType依赖进行初始化并注册依赖Bean； 4：调用初始化方法； 5：对依赖处理； 看一下createBeanInstance方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Create a new instance for the specified bean, using an appropriate instantiation strategy: * factory method, constructor autowiring, or simple instantiation. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a BeanWrapper for the new instance * @see #obtainFromSupplier * @see #instantiateUsingFactoryMethod * @see #autowireConstructor * @see #instantiateBean */protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 解析class Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); //确保class不为空，并且访问权限为public if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName()); &#125; //配置的一种特殊的callback回调方法，通过这个callback创建bean Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) &#123; return obtainFromSupplier(instanceSupplier, beanName); &#125; // 如果工厂方式不为空，则使用功能工厂方式进行解析 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // 一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器 // 在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，避免再次创建相同bean时再次解析 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; //判断构造器或工厂方法是否为null if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; //已经解析过class的构造器 autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; //构造函数自动注入 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; //使用默认构造器 return instantiateBean(beanName, mbd); &#125; &#125; // 需要根据参数解析、确定构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; return autowireConstructor(beanName, mbd, ctors, args); &#125; // Preferred constructors for default construction? // 默认构造的首选构造器？ ctors = mbd.getPreferredConstructors(); if (ctors != null) &#123; return autowireConstructor(beanName, mbd, ctors, null); &#125; // No special handling: simply use no-arg constructor. // 使用默认构造器 return instantiateBean(beanName, mbd);&#125; 上述方法： 1：解析class； 2：如果存在 Supplier 回调，则调用 obtainFromSupplier() 进行初始化，如果不等于null就直接返回； 3：如果工厂方式不为空，则使用功能工厂方式进行解析； 4：构造函数自动注入 autowireConstructor 5：默认构造器 instantiateBean 我们先看看 Supplier回调的使用： 12345//配置的一种特殊的callback回调方法，通过这个callback创建beanSupplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();if (instanceSupplier != null) &#123; return obtainFromSupplier(instanceSupplier, beanName);&#125; 1234567891011121314151617181920212223242526272829303132/** * Obtain a bean instance from the given supplier. * @param instanceSupplier the configured supplier * @param beanName the corresponding bean name * @return a BeanWrapper for the new instance * @since 5.0 * @see #getObjectForBeanInstance */protected BeanWrapper obtainFromSupplier(Supplier&lt;?&gt; instanceSupplier, String beanName) &#123; Object instance; String outerBean = this.currentlyCreatedBean.get(); this.currentlyCreatedBean.set(beanName); try &#123; instance = instanceSupplier.get(); &#125; finally &#123; if (outerBean != null) &#123; this.currentlyCreatedBean.set(outerBean); &#125; else &#123; this.currentlyCreatedBean.remove(); &#125; &#125; if (instance == null) &#123; instance = new NullBean(); &#125; BeanWrapper bw = new BeanWrapperImpl(instance); initBeanWrapper(bw); return bw;&#125; 1234567891011121314151617181920212223/** * Represents a supplier of results. * * &lt;p&gt;There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #get()&#125;. * * @param &lt;T&gt; the type of results supplied by this supplier * * @since 1.8 */@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; Supplier就一个get方法，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 setter 方法，如下： 123public void setInstanceSupplier(@Nullable Supplier&lt;?&gt; instanceSupplier) &#123; this.instanceSupplier = instanceSupplier;&#125; 该方法是AbsTractBeanDefinition类中的方法，在初始化RootBeanDefinition的时候会调用该方法；在源码的protected AbstractBeanDefinition(BeanDefinition original) 方法中； 下面开始解析工厂模式实例化Bean，后边还有构造函数和默认构造的实例方法…..累 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283public BeanWrapper instantiateUsingFactoryMethod( String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) &#123; // 实例化 BeanWrapperImpl BeanWrapperImpl bw = new BeanWrapperImpl(); //初始化 BeanWrapperImpl this.beanFactory.initBeanWrapper(bw); Object factoryBean; Class&lt;?&gt; factoryClass; boolean isStatic; // 获取工厂Bean 这里使用FactoryBean 县实例化 FactoryBean // 工厂名称不为空 如下处理 String factoryBeanName = mbd.getFactoryBeanName(); if (factoryBeanName != null) &#123; if (factoryBeanName.equals(beanName)) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, "factory-bean reference points back to the same bean definition"); &#125; factoryBean = this.beanFactory.getBean(factoryBeanName); if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) &#123; throw new ImplicitlyAppearedSingletonException(); &#125; factoryClass = factoryBean.getClass(); isStatic = false; &#125; else &#123; // 工厂名为空，则其可能是一个静态工厂 // It's a static factory method on the bean class. // 这里使用Factory-method factory-metohd 无需调用功能工厂类实例下就可以调用工厂功法 但非static不可以 需要调用上边的 if (!mbd.hasBeanClass()) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, "bean definition declares neither a bean class nor a factory-bean reference"); &#125; factoryBean = null; factoryClass = mbd.getBeanClass(); isStatic = true; &#125; // 需要使用的工厂方法 Method factoryMethodToUse = null; ArgumentsHolder argsHolderToUse = null; //要使用的工厂参数 Object[] argsToUse = null; // 工厂方法的参数 // 如果指定了构造参数则直接使用 // 在调用 getBean 方法的时候指定了方法参数 if (explicitArgs != null) &#123; argsToUse = explicitArgs; &#125; else &#123; // 没有指定，则尝试从配置文件中解析 Object[] argsToResolve = null; synchronized (mbd.constructorArgumentLock) &#123; // 获取构造函数或工厂方法 factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod; if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) &#123; // 获取构造参数 argsToUse = mbd.resolvedConstructorArguments; if (argsToUse == null) &#123; // 获取构造函数参数的包可见字段 argsToResolve = mbd.preparedConstructorArguments; &#125; &#125; &#125; if (argsToResolve != null) &#123; // 缓存中存在,则解析存储在 BeanDefinition 中的参数 // 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的("1","1")转换为 (1,1) // 缓存中的值可能是原始值也有可能是最终值 argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true); &#125; &#125; if (factoryMethodToUse == null || argsToUse == null) &#123; // Need to determine the factory method... // Try all methods with this name to see if they match the given arguments. // 需要确定工厂的方法.尝试所有具有此名称的方法，以查看它们是否与给定的参数匹配。 // 获取工厂方法的类全名称 factoryClass = ClassUtils.getUserClass(factoryClass); // 检索所有方法，这里是对方法进行过滤 Method[] rawCandidates = getCandidateMethods(factoryClass, mbd); List&lt;Method&gt; candidateList = new ArrayList&lt;&gt;(); for (Method candidate : rawCandidates) &#123; // 如果有static 且为工厂方法，则添加到 candidateSet 中 if (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123; candidateList.add(candidate); &#125; &#125; // 如果静态方法就一个 &amp; getBean参数null &amp; 没有构造参数值 直接初始化返回 if (candidateList.size() == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123; Method uniqueCandidate = candidateList.get(0); if (uniqueCandidate.getParameterCount() == 0) &#123; mbd.factoryMethodToIntrospect = uniqueCandidate; synchronized (mbd.constructorArgumentLock) &#123; mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate; mbd.constructorArgumentsResolved = true; mbd.resolvedConstructorArguments = EMPTY_ARGS; &#125; bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS)); return bw; &#125; &#125; Method[] candidates = candidateList.toArray(new Method[0]); // 排序构造函数 // public 构造函数优先参数数量降序，非public 构造函数参数数量降序 AutowireUtils.sortFactoryMethods(candidates); ConstructorArgumentValues resolvedValues = null; boolean autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR); int minTypeDiffWeight = Integer.MAX_VALUE; Set&lt;Method&gt; ambiguousFactoryMethods = null; int minNrOfArgs; if (explicitArgs != null) &#123; minNrOfArgs = explicitArgs.length; &#125; else &#123; // We don't have arguments passed in programmatically, so we need to resolve the // arguments specified in the constructor arguments held in the bean definition. // 判断 BeanDefinition中有没有构造参数值 // getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数 if (mbd.hasConstructorArgumentValues()) &#123; // 获取构造参数值 ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues(); resolvedValues = new ConstructorArgumentValues(); // 解析构造函数的参数 minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues); &#125; else &#123; minNrOfArgs = 0; &#125; &#125; LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null; // 循环方法找到 匹配的那个 for (Method candidate : candidates) &#123; // 获取方法参数 Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); if (paramTypes.length &gt;= minNrOfArgs) &#123; ArgumentsHolder argsHolder; // getbean给的参数 if (explicitArgs != null) &#123; // Explicit arguments given -&gt; arguments length must match exactly. // 参数不匹配 方法略过 if (paramTypes.length != explicitArgs.length) &#123; continue; &#125; // 根据参数创建参数持有者 argsHolder = new ArgumentsHolder(explicitArgs); &#125; else &#123; // Resolved constructor arguments: type conversion and/or autowiring necessary. try &#123; String[] paramNames = null; // 获取 ParameterNameDiscoverer 对象 // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器 ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer(); if (pnd != null) &#123; // 获取指定构造函数的参数名 paramNames = pnd.getParameterNames(candidate); &#125; //在已经解析的构造函数参数值的情况下，创建一个参数持有者对象 argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring, candidates.length == 1); &#125; catch (UnsatisfiedDependencyException ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Ignoring factory method [" + candidate + "] of bean '" + beanName + "': " + ex); &#125; // Swallow and try next overloaded factory method. if (causes == null) &#123; causes = new LinkedList&lt;&gt;(); &#125; causes.add(ex); continue; &#125; &#125; // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式 // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常 // 宽松模式：使用具有"最接近的模式"进行匹配 // typeDiffWeight：类型差异权重 int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes)); // Choose this factory method if it represents the closest match. // 代表最接近的类型匹配，则选择作为构造函数 if (typeDiffWeight &lt; minTypeDiffWeight) &#123; factoryMethodToUse = candidate; argsHolderToUse = argsHolder; argsToUse = argsHolder.arguments; minTypeDiffWeight = typeDiffWeight; ambiguousFactoryMethods = null; &#125; // Find out about ambiguity: In case of the same type difference weight // for methods with the same number of parameters, collect such candidates // and eventually raise an ambiguity exception. // However, only perform that check in non-lenient constructor resolution mode, // and explicitly ignore overridden methods (with the same parameter signature). else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp; !mbd.isLenientConstructorResolution() &amp;&amp; paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp; !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123; if (ambiguousFactoryMethods == null) &#123; ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;(); ambiguousFactoryMethods.add(factoryMethodToUse); &#125; ambiguousFactoryMethods.add(candidate); &#125; &#125; &#125; // 没有可执行的工厂方法，抛出异常 if (factoryMethodToUse == null) &#123; if (causes != null) &#123; UnsatisfiedDependencyException ex = causes.removeLast(); for (Exception cause : causes) &#123; this.beanFactory.onSuppressedException(cause); &#125; throw ex; &#125; List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs); if (explicitArgs != null) &#123; for (Object arg : explicitArgs) &#123; argTypes.add(arg != null ? arg.getClass().getSimpleName() : "null"); &#125; &#125; else if (resolvedValues != null) &#123; Set&lt;ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount()); valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values()); valueHolders.addAll(resolvedValues.getGenericArgumentValues()); for (ValueHolder value : valueHolders) &#123; String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : "null")); argTypes.add(argType); &#125; &#125; String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes); throw new BeanCreationException(mbd.getResourceDescription(), beanName, "No matching factory method found: " + (mbd.getFactoryBeanName() != null ? "factory bean '" + mbd.getFactoryBeanName() + "'; " : "") + "factory method '" + mbd.getFactoryMethodName() + "(" + argDesc + ")'. " + "Check that a method with the specified name " + (minNrOfArgs &gt; 0 ? "and arguments " : "") + "exists and that it is " + (isStatic ? "static" : "non-static") + "."); &#125; else if (void.class == factoryMethodToUse.getReturnType()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid factory method '" + mbd.getFactoryMethodName() + "': needs to have a non-void return type!"); &#125; else if (ambiguousFactoryMethods != null) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Ambiguous factory method matches found in bean '" + beanName + "' " + "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " + ambiguousFactoryMethods); &#125; if (explicitArgs == null &amp;&amp; argsHolderToUse != null) &#123; // 指定工厂方法 mbd.factoryMethodToIntrospect = factoryMethodToUse; // 将解析的构造函数加入缓存 argsHolderToUse.storeCache(mbd, factoryMethodToUse); &#125; &#125; Assert.state(argsToUse != null, "Unresolved factory method arguments"); bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse)); return bw;&#125; 上述这段代码，怎么说呢，为什么都写一起，为什么不分方法写，每个方法明确干什么，看这个方法需要毅力，读者好好看……. 先来看看这个方法都做了啥： 1：首先实例化 BeanWrapperImpl 2：初始化BeanWrapperImpl 3：获取FactoryBean Name，看这里之前读者如果不了解factory-bean和factory-mothod请点击，在这里会判断factoryBeannName是否为null，如果不是则初始化工厂bean，代码体现在factoryBean = this.beanFactory.getBean(factoryBeanName)这里，否则一定是一个static修饰的工厂方法，直接调用即可； 4：缓存中获取构造或工厂方法，构造参数，在线解释一下：； constructorArgumentLock：构造缓存使用的锁； resolvedConstructorOrFactoryMethod：构造函数或工厂方法； resolvedConstructorArguments：构造参数 如果缓存中存在，则需要调用 resolvePreparedArguments() 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。 5：如果缓存中或上送的参数没有则需要解析了，需要通过反射获取所有方法，如果获取的符合条件的static的方法就一个，并且还没有构造方法参数，则直接初始化返回；代码如下： 1234567891011121314// 如果静态方法就一个 &amp; getBean参数null &amp; 没有构造参数值 直接初始化返回if (candidateList.size() == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123; Method uniqueCandidate = candidateList.get(0); if (uniqueCandidate.getParameterCount() == 0) &#123; mbd.factoryMethodToIntrospect = uniqueCandidate; synchronized (mbd.constructorArgumentLock) &#123; mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate; mbd.constructorArgumentsResolved = true; mbd.resolvedConstructorArguments = EMPTY_ARGS; &#125; bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS)); return bw; &#125;&#125; 6:如果显示提供了参数（explicitArgs != null）,则直接使用，反之需要获取ConstructorArgumentValues值，并且解析构造函数，这里比较复杂，建议读者debug； 7：循环匹配，直到找到匹配的构造函数；如果找不到则抛出异常，无可用函数；代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 循环方法找到 匹配的那个 for (Method candidate : candidates) &#123; // 获取方法参数 Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); if (paramTypes.length &gt;= minNrOfArgs) &#123; ArgumentsHolder argsHolder; // getbean给的参数 if (explicitArgs != null) &#123; // Explicit arguments given -&gt; arguments length must match exactly. // 参数不匹配 方法略过 if (paramTypes.length != explicitArgs.length) &#123; continue; &#125; // 根据参数创建参数持有者 argsHolder = new ArgumentsHolder(explicitArgs); &#125; else &#123; // Resolved constructor arguments: type conversion and/or autowiring necessary. try &#123; String[] paramNames = null; // 获取 ParameterNameDiscoverer 对象 // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器 ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer(); if (pnd != null) &#123; // 获取指定构造函数的参数名 paramNames = pnd.getParameterNames(candidate); &#125; //在已经解析的构造函数参数值的情况下，创建一个参数持有者对象 argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring, candidates.length == 1); &#125; catch (UnsatisfiedDependencyException ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Ignoring factory method [" + candidate + "] of bean '" + beanName + "': " + ex); &#125; // Swallow and try next overloaded factory method. if (causes == null) &#123; causes = new LinkedList&lt;&gt;(); &#125; causes.add(ex); continue; &#125; &#125; // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式 // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常 // 宽松模式：使用具有"最接近的模式"进行匹配 // typeDiffWeight：类型差异权重 int typeDiffWeight = (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes)); // Choose this factory method if it represents the closest match. // 代表最接近的类型匹配，则选择作为构造函数 if (typeDiffWeight &lt; minTypeDiffWeight) &#123; factoryMethodToUse = candidate; argsHolderToUse = argsHolder; argsToUse = argsHolder.arguments; minTypeDiffWeight = typeDiffWeight; ambiguousFactoryMethods = null; &#125; // Find out about ambiguity: In case of the same type difference weight // for methods with the same number of parameters, collect such candidates // and eventually raise an ambiguity exception. // However, only perform that check in non-lenient constructor resolution mode, // and explicitly ignore overridden methods (with the same parameter signature). else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp; !mbd.isLenientConstructorResolution() &amp;&amp; paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp; !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123; if (ambiguousFactoryMethods == null) &#123; ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;(); ambiguousFactoryMethods.add(factoryMethodToUse); &#125; ambiguousFactoryMethods.add(candidate); &#125; &#125; &#125; // 没有可执行的工厂方法，抛出异常 if (factoryMethodToUse == null) &#123; if (causes != null) &#123; UnsatisfiedDependencyException ex = causes.removeLast(); for (Exception cause : causes) &#123; this.beanFactory.onSuppressedException(cause); &#125; throw ex; &#125; List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs); if (explicitArgs != null) &#123; for (Object arg : explicitArgs) &#123; argTypes.add(arg != null ? arg.getClass().getSimpleName() : "null"); &#125; &#125; else if (resolvedValues != null) &#123; Set&lt;ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount()); valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values()); valueHolders.addAll(resolvedValues.getGenericArgumentValues()); for (ValueHolder value : valueHolders) &#123; String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) : (value.getValue() != null ? value.getValue().getClass().getSimpleName() : "null")); argTypes.add(argType); &#125; &#125; String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes); throw new BeanCreationException(mbd.getResourceDescription(), beanName, "No matching factory method found: " + (mbd.getFactoryBeanName() != null ? "factory bean '" + mbd.getFactoryBeanName() + "'; " : "") + "factory method '" + mbd.getFactoryMethodName() + "(" + argDesc + ")'. " + "Check that a method with the specified name " + (minNrOfArgs &gt; 0 ? "and arguments " : "") + "exists and that it is " + (isStatic ? "static" : "non-static") + "."); &#125; 8：指定工厂那个方法，并且将解析的构造函数信息加入缓存中，代码如下： 12345678910111213141516171819if (explicitArgs == null &amp;&amp; argsHolderToUse != null) &#123; // 指定工厂方法 mbd.factoryMethodToIntrospect = factoryMethodToUse; // 将解析的构造函数加入缓存 argsHolderToUse.storeCache(mbd, factoryMethodToUse);&#125;public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) &#123; synchronized (mbd.constructorArgumentLock) &#123; mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod; mbd.constructorArgumentsResolved = true; if (this.resolveNecessary) &#123; mbd.preparedConstructorArguments = this.preparedArguments; &#125; else &#123; mbd.resolvedConstructorArguments = this.arguments; &#125; &#125;&#125; 10：通过反射实例化Bean，源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner, @Nullable Object factoryBean, final Method factoryMethod, Object... args) &#123; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; ReflectionUtils.makeAccessible(factoryMethod); return null; &#125;); &#125; else &#123; ReflectionUtils.makeAccessible(factoryMethod); &#125; Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get(); try &#123; currentlyInvokedFactoryMethod.set(factoryMethod); // 利用反射 Object result = factoryMethod.invoke(factoryBean, args); if (result == null) &#123; result = new NullBean(); &#125; return result; &#125; finally &#123; if (priorInvokedFactoryMethod != null) &#123; currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod); &#125; else &#123; currentlyInvokedFactoryMethod.remove(); &#125; &#125; &#125; catch (IllegalArgumentException ex) &#123; throw new BeanInstantiationException(factoryMethod, "Illegal arguments to factory method '" + factoryMethod.getName() + "'; " + "args: " + StringUtils.arrayToCommaDelimitedString(args), ex); &#125; catch (IllegalAccessException ex) &#123; throw new BeanInstantiationException(factoryMethod, "Cannot access factory method '" + factoryMethod.getName() + "'; is it public?", ex); &#125; catch (InvocationTargetException ex) &#123; String msg = "Factory method '" + factoryMethod.getName() + "' threw exception"; if (bd.getFactoryBeanName() != null &amp;&amp; owner instanceof ConfigurableBeanFactory &amp;&amp; ((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123; msg = "Circular reference involving containing bean '" + bd.getFactoryBeanName() + "' - consider " + "declaring the factory method as static for independence from its containing instance. " + msg; &#125; throw new BeanInstantiationException(factoryMethod, msg, ex.getTargetException()); &#125; &#125; 上述工厂模式实例化Bean写的不是很详细，尽量debug源码去一步步看才能理解，下面看构造器实例化autowireConstructor 工厂实例化和构造函数实例化这两个大方法都需要读者自己deBug，这样可更好的理解下面说一下都做了什么： 1：实例化BeanWrapperImpl 2：初始化BeanWrapperImpl 3：构造参数如果在getBean是传入则使用，反之需要从缓存中获取并解析参数类型： constructorArgumentLock：构造缓存使用的锁； resolvedConstructorOrFactoryMethod：构造函数或工厂方法； resolvedConstructorArguments：构造参数 代码如下： 12345678910111213141516171819&gt; Object[] argsToResolve = null;&gt; synchronized (mbd.constructorArgumentLock) &#123;&gt; //获取解析构造函数或工厂方法&gt; constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;&gt; //构造函数或工厂方法不为空 &amp; 存在构造方法（函数）&gt; if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) &#123;&gt; // Found a cached constructor...&gt; argsToUse = mbd.resolvedConstructorArguments;&gt; if (argsToUse == null) &#123;&gt; // 配置构造函数参数&gt; argsToResolve = mbd.preparedConstructorArguments;&gt; &#125;&gt; &#125;&gt; &#125;&gt; if (argsToResolve != null) &#123;&gt; // 解析参数类型，比如构造方法是 A(int, int)，通过此方法将（"1"，"1"）转换为（1，1）&gt; argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);&gt; &#125;&gt; 4：解析构造函数，如果中有上送，则使用，如果没有则从beanClass中获取，解析后加入缓存，代码是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&gt; if (constructorToUse == null || argsToUse == null) &#123;&gt; // 接受指定的构造函数(如果有的话)。.&gt; Constructor&lt;?&gt;[] candidates = chosenCtors;&gt; if (candidates == null) &#123;&gt; // 从class中获取&gt; Class&lt;?&gt; beanClass = mbd.getBeanClass();&gt; try &#123;&gt; // 从class获取构造器 判断是否是public&gt; candidates = (mbd.isNonPublicAccessAllowed() ?&gt; beanClass.getDeclaredConstructors() : beanClass.getConstructors());&gt; &#125;&gt; catch (Throwable ex) &#123;&gt; throw new BeanCreationException(mbd.getResourceDescription(), beanName,&gt; "Resolution of declared constructors on bean Class [" + beanClass.getName() +&gt; "] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);&gt; &#125;&gt; &#125;&gt; // 构造参数value == null 直接返回&gt; if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;&gt; Constructor&lt;?&gt; uniqueCandidate = candidates[0];&gt; if (uniqueCandidate.getParameterCount() == 0) &#123;&gt; synchronized (mbd.constructorArgumentLock) &#123;&gt; // 构造器或工厂方法&gt; mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;&gt; //构造函数参数解析&gt; mbd.constructorArgumentsResolved = true;&gt; // 构造函数参数&gt; mbd.resolvedConstructorArguments = EMPTY_ARGS;&gt; &#125;&gt; bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));&gt; return bw;&gt; &#125;&gt; &#125;&gt; &gt; // 需要解析构造函数参数&gt; boolean autowiring = (chosenCtors != null ||&gt; mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);&gt; ConstructorArgumentValues resolvedValues = null;&gt; &gt; int minNrOfArgs;&gt; if (explicitArgs != null) &#123;&gt; minNrOfArgs = explicitArgs.length;&gt; &#125;&gt; else &#123;&gt; ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();&gt; resolvedValues = new ConstructorArgumentValues();&gt; // 解析构造函数参数&gt; minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);&gt; &#125;&gt; &gt; AutowireUtils.sortConstructors(candidates);&gt; int minTypeDiffWeight = Integer.MAX_VALUE;&gt; Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;&gt; LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;&gt; &gt; for (Constructor&lt;?&gt; candidate : candidates) &#123;&gt; //获取构造方法参数类型&gt; Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();&gt; &gt; if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;&gt; // Already found greedy constructor that can be satisfied -&gt;&gt; // do not look any further, there are only less greedy constructors left.&gt; // 如果已经找到了可用的构造函数或者需要的参数个数小于当前当前函数的个数则终止&gt; break;&gt; &#125;&gt; if (paramTypes.length &lt; minNrOfArgs) &#123;&gt; //参数个数不相等&gt; continue;&gt; &#125;&gt; &gt; ConstructorResolver.ArgumentsHolder argsHolder;&gt; if (resolvedValues != null) &#123;&gt; try &#123;&gt; // 从注解上获取参数名称&gt; String[] paramNames = ConstructorResolver.ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);&gt; if (paramNames == null) &#123;&gt; // 参数名称探索期&gt; ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();&gt; if (pnd != null) &#123;&gt; //获取构造方法上的参数&gt; paramNames = pnd.getParameterNames(candidate);&gt; &#125;&gt; &#125;&gt; argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,&gt; getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);&gt; &#125;&gt; catch (UnsatisfiedDependencyException ex) &#123;&gt; if (logger.isTraceEnabled()) &#123;&gt; logger.trace("Ignoring constructor [" + candidate + "] of bean '" + beanName + "': " + ex);&gt; &#125;&gt; // Swallow and try next constructor.&gt; if (causes == null) &#123;&gt; causes = new LinkedList&lt;&gt;();&gt; &#125;&gt; causes.add(ex);&gt; continue;&gt; &#125;&gt; &#125;&gt; else &#123;&gt; // 无参构造&gt; // Explicit arguments given -&gt; arguments length must match exactly.&gt; if (paramTypes.length != explicitArgs.length) &#123;&gt; continue;&gt; &#125;&gt; argsHolder = new ConstructorResolver.ArgumentsHolder(explicitArgs);&gt; &#125;&gt; &gt; // 判断是否有不确定的构造&gt; int typeDiffWeight = (mbd.isLenientConstructorResolution() ?&gt; argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));&gt; // Choose this constructor if it represents the closest match.&gt; if (typeDiffWeight &lt; minTypeDiffWeight) &#123;&gt; constructorToUse = candidate;&gt; argsHolderToUse = argsHolder;&gt; argsToUse = argsHolder.arguments;&gt; minTypeDiffWeight = typeDiffWeight;&gt; ambiguousConstructors = null;&gt; &#125;&gt; else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;&gt; if (ambiguousConstructors == null) &#123;&gt; ambiguousConstructors = new LinkedHashSet&lt;&gt;();&gt; ambiguousConstructors.add(constructorToUse);&gt; &#125;&gt; ambiguousConstructors.add(candidate);&gt; &#125;&gt; &#125;&gt; &gt; if (constructorToUse == null) &#123;&gt; if (causes != null) &#123;&gt; UnsatisfiedDependencyException ex = causes.removeLast();&gt; for (Exception cause : causes) &#123;&gt; this.beanFactory.onSuppressedException(cause);&gt; &#125;&gt; throw ex;&gt; &#125;&gt; throw new BeanCreationException(mbd.getResourceDescription(), beanName,&gt; "Could not resolve matching constructor " +&gt; "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");&gt; &#125;&gt; else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;&gt; throw new BeanCreationException(mbd.getResourceDescription(), beanName,&gt; "Ambiguous constructor matches found in bean '" + beanName + "' " +&gt; "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " +&gt; ambiguousConstructors);&gt; &#125;&gt; &gt; if (explicitArgs == null &amp;&amp; argsHolderToUse != null) &#123;&gt; // 加入缓存&gt; argsHolderToUse.storeCache(mbd, constructorToUse);&gt; &#125;&gt; &#125;&gt; 5：实例化Bean，源码： 1234567891011121314151617181920&gt; @Override&gt; public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,&gt; final Constructor&lt;?&gt; ctor, Object... args) &#123;&gt; // 如果没使用lookuo 或 replace 则直接使用反射创建&gt; if (!bd.hasMethodOverrides()) &#123;&gt; if (System.getSecurityManager() != null) &#123;&gt; // use own privileged to change accessibility (when security is on)&gt; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;&gt; ReflectionUtils.makeAccessible(ctor);&gt; return null;&gt; &#125;);&gt; &#125;&gt; // 直接使用反射方式创建你&gt; return BeanUtils.instantiateClass(ctor, args);&gt; &#125;&gt; else &#123;&gt; return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);&gt; &#125;&gt; &#125;&gt; 下面说一下默认构造器instantiateBean实例化Bean： 123456789101112131415161718192021222324252627/** * Instantiate the given bean using its default constructor. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @return a BeanWrapper for the new instance */protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; try &#123; Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, parent), getAccessControlContext()); &#125; else &#123; beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) &#123; // Don't override the class with CGLIB if no overrides. if (!bd.hasMethodOverrides()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; //获取构造器 constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; // 获取clazz final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, "Specified class is an interface"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged( (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor); &#125; else &#123; // 获取公共构造器 constructorToUse = clazz.getDeclaredConstructor(); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, "No default constructor found", ex); &#125; &#125; &#125; // 实例化class return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; 上述代码是使用默认构造器实例化Bean的代码，这里我就不多赘述了，使用工厂模式和构造参数实例化Bean的代码都看过了，这里就很容易理解了；下面我们接着流程说getSingleton方法： getSingleton方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, "Bean name must not be null"); // 加锁，全局变量需要同步 synchronized (this.singletonObjects) &#123; //查看单例bean是否创建国如果有直接使用 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, "Singleton bean creation not allowed while singletons of this factory are in destruction " + "(Do not request a bean from a BeanFactory in a destroy method implementation!)"); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Creating shared instance of singleton bean '" + beanName + "'"); &#125; //记录加载状态 书中 99页 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;&gt;(); &#125; try &#123; singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException ex) &#123; // Has the singleton object implicitly appeared in the meantime -&gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw ex; &#125; &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; //删除加载状态 afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125;&#125; 这里我们直接说这个方法干了什么事情吧，如下： 1：首先是全局锁singletonObjects； 2：查看缓存中是否存在，如果有则判断获取的Bean是否在销毁阶段； 3：使用singletonsCurrentlyInCreation记录加载状态； 4：使用createBean方法返回的ObjectFactory获取bean，并指定这次创建是一个新的单例； 5：在singletonsCurrentlyInCreation中删除加载状态； 6：增加缓存，代码如下： 123456789101112131415&gt; /**&gt; * Add the given singleton object to the singleton cache of this factory.&gt; * &lt;p&gt;To be called for eager registration of singletons.&gt; * @param beanName the name of the bean&gt; * @param singletonObject the singleton object&gt; */&gt; protected void addSingleton(String beanName, Object singletonObject) &#123;&gt; synchronized (this.singletonObjects) &#123;&gt; this.singletonObjects.put(beanName, singletonObject);&gt; this.singletonFactories.remove(beanName);&gt; this.earlySingletonObjects.remove(beanName);&gt; this.registeredSingletons.add(beanName);&gt; &#125;&gt; &#125;&gt; 接下来就看一看getBean调用最多的方法getObjectForBeanInstance： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Get the object for the given bean instance, either the bean * instance itself or its created object in case of a FactoryBean. * @param beanInstance the shared bean instance * @param name name that may include factory dereference prefix * @param beanName the canonical bean name * @param mbd the merged bean definition * @return the object to expose for the bean */protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // Don't let calling code try to dereference the factory if the bean isn't a factory. // 如果指定的name是工厂相关的（&amp;前缀），并且beanInstance又不是FactoryBean类 则验证不通过 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it's a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. //如果我们有了个bean的实例，这个实例可能是bean可能是beanfactory，如果是FactoryBean我们使用它去创建实例，但是如果用户想要直接获取工厂实例而不是工厂的getObject方法所对应的实例， //那么传入的name应该加前缀&amp; if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //尝试从缓存中加载实例 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. // beanInstance一定是FactoryBean了 FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. //在beanDefinitionMap 获取beanDefition ,beanDefinitionMap是注册时候的Map if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; // 将xml解析时存入的GernericBeanDefinition 转换成 RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); &#125; //是否是用户定义而不是应用程序本身定义 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; 上述代码有两个判断： 1：如果指定的name是工厂相关的（&amp;前缀），并且beanInstance类型不是FactoryBean则抛出BeanIsNotAFactoryBean异常； 2：如果beanInstance不是FactoryBean 或者 指定的name是工厂相关的（&amp;前缀）则直接返回beanInstance; 这两个条件可以好好理解下，第一个应该没问题，如果指定的是工厂相关的，并且beanInstance类是不是FactoryBean则抛出异常，第二个就可以理解beanInstance如果不是FactoryBean就直接返回， 并且第二个条件的BeanFactoryUtils.isFactoryDereference(name)永远都不会是true，因为如果这一条件成立，则第一个条件则通不过会直接抛出异常，那么下边的代码就是在处理beanInstrace是BeanFactory，但是传入的name不是&amp;name； 3：下面的代码就很简单了，mbd这个参数不会为null，只有在获取缓存的时候会是null，这里就不做多解释了，直接将BeanInstance类型强转成FactoryBean，然后调用getObjectFromFactoryBean方法进行getObject返回； 4：FactoryBean不理解的可以看一下这篇文章，有例子：https://blog.csdn.net/qq_30257149/article/details/88028924 总结 总结一下，在getSinngnleton中不断的使用缓存就是因为是单例的不允许重复创建，说一下重点： 1：如果是单例则先从缓存中获取，没有在调用getSingleton方法创建； 2：检查bean是否是abstract 3：保证当前bean所依赖的bean的初始化，如果没有先初始化依赖； 4：获取BeanDefinition，BeanDefinition是在注册的时候实例化然后存入缓存的，这里直接取过来做一下类型转换即可； 5：如果是单例则调用getSingleton方法，如果是原型则调用isPrototype下面的代码块，如果都不是的话使用默认创建（原型）； 6：在bean创建前后会使用singletonsCurrentlyInCreation或prototypesCurrentlyInCreation标记类是否正在创建中，给后续判断使用； 7：bean实例化的方式，在创建实例之前做了一个判断，如果有则通过InstanceSupplier.et方法直接返回，工厂方法实例化(instantiateUsingFactoryMethod)，构造器实例化(autowireConstructor)，默认构造器实例化(instantiateBean)，这里是读者需要看源码的的重点， 8：bean在创建前会提前暴露实例并增加缓存，保证如果有别人依赖可以直接从缓存你中取，解决循环依赖问题； 9：对bean的赋值属性的注入(populateBean方法)； 10：调用初始化方法，initializeBean； 对于9和10在代码中没有做详细的讲解，但是在源码中做了一些注释，可以自行debug看一下很简单，主要是太多了，早知道就分开写了，很累…. 不知道作为读者的你能否能看下去； 码字不易，转你发请注明出处：https://mp.csdn.net/postedit/88016361 博客地址：https://lantaogithub.github.io]]></content>
      <categories>
        <category>spring源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
        <tag>XMLBeanFactory</tag>
        <tag>getBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Srping源码之XMLBeanFactory]]></title>
    <url>%2F2019%2F02%2F27%2FSpring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%2FString%E6%BA%90%E7%A0%81%E4%B9%8BXmlBeanFactory%2F</url>
    <content type="text"><![CDATA[本文是针对Srping的XMLBeanFactory来进行解析xml并将解析后的信息使用GenericBeanDefinition作为载体进行注册,xmlBeanFactory已经在Spring 3.1中被标记为不建议使用，但是我们分析源码不影响，因为源码并未改变， 并ApplicationContext依旧使用XmlBeanDefinitionReader和DefaultListableBeanFactory进行xml的解析和注册工作，本篇博客是跟源码一步步看spring怎么实现bean的注册，源码为spring5.X,源码已经在每一行上加了注释，方便读者学习。 GitHub:https://github.com/lantaoGitHub/spring-framework.git 首先我们从XMLBeanFactory入手,直接上代码： 123456789101112131415161718package org.springframework.lantao;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class XmlBeanFactoryTest &#123; public static void main(String[] args) &#123; // 资源加载 ClassPathResource classPathResource = new ClassPathResource("spring-bean.xml"); // XmlBeanFactory 加载资源并解析注册bean BeanFactory beanFactory = new XmlBeanFactory(classPathResource); // BeanFactory.getBean(); UserBean userBean = (UserBean) beanFactory.getBean("userBean"); System.out.println(userBean.getName()); &#125;&#125; XmlBeanFactory解析Xml是使用了XmlBeanDefinitionReader.loadBeanDefinition()方法,源码如下： 12345678910111213141516171819202122232425262728293031323334@Deprecated@SuppressWarnings(&#123;"serial", "all"&#125;)public class XmlBeanFactory extends DefaultListableBeanFactory &#123; private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); /** * Create a new XmlBeanFactory with the given resource, * which must be parsable using DOM. * @param resource the XML resource to load bean definitions from * @throws BeansException in case of loading or parsing errors */ public XmlBeanFactory(Resource resource) throws BeansException &#123; //调用构造方法 79行 this(resource, null); &#125; /** * Create a new XmlBeanFactory with the given input stream, * which must be parsable using DOM. * @param resource the XML resource to load bean definitions from * @param parentBeanFactory parent bean factory * @throws BeansException in case of loading or parsing errors */ public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; //ignoreDependencyInterface 忽略自动装配 //主要功能就是当有忽略的接口类，自动装配会忽略这部分类的初始化装配，因为某种情况下，此时的接口实现类不能初始化，列如BeanNameAware,要想装配这个接口的实现对象，可以实现这个接口。 super(parentBeanFactory); //这段代码是真正的资源加载 this.reader.loadBeanDefinitions(resource); &#125;&#125; 我们直接看loadBeanDefinition方法，源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Load bean definitions from the specified XML file. * @param resource the resource descriptor for the XML file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; // 对EncodedResource进行封装，设置String encoding, Charset charset return loadBeanDefinitions(new EncodedResource(resource));&#125;/** * Load bean definitions from the specified XML file. * @param encodedResource the resource descriptor for the XML file, * allowing to specify an encoding to use for parsing the file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; //encodedResource 不可以为空 Assert.notNull(encodedResource, "EncodedResource must not be null"); if (logger.isTraceEnabled()) &#123; logger.trace("Loading XML bean definitions from " + encodedResource); &#125; // 通过属性来记录已经加载的资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); &#125; try &#123; // 从encodedResource已经封装的Resource获取InputStream InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; //InputSource 并不是spring的，而是 org.xml.sax InputSource inputSource = new InputSource(inputStream); //如果encodedResource 中的 Encoding 不是 null 则同步设置 InputSource的 Encoding if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; //加载bean的Definitions 将xml中的信息加载到Definition中，并且在内存中注册的也是key+definitions return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( "IOException parsing XML document from " + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 上述源码可能看着比较长,但实际上这里并不是真正解析的地方，在这里做了如下： 1:从encodedResource已经封装的Resource获取InputStream； 2:如果encodedResource 中的 Encoding 不是 null 则同步设置 InputSource的 Encoding； 3:将解析动作委托给doLoadBeanDefinitions实现； 接下来我们继续看doLoadBeanDefinitions方法内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Actually load bean definitions from the specified XML file. * @param inputSource the SAX InputSource to read from * @param resource the resource descriptor for the XML file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #doLoadDocument * @see #registerBeanDefinitions */protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //加载 Document Document doc = doLoadDocument(inputSource, resource); //注册 bean int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) &#123; logger.debug("Loaded " + count + " bean definitions from " + resource); &#125; return count; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), "XML document from " + resource + " is invalid", ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "Parser configuration exception parsing XML from " + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "IOException parsing XML document from " + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "Unexpected exception parsing XML document from " + resource, ex); &#125;&#125; 当我们看着这个方法的时候，依旧不是真正的解析或注册的方法，在这里只是做了Document的加载，并将后续工作委托给了registerBeanDefinitions,registerBeanDefinitions方法的返回时注册Bean的个数； 我们继续看registerBeanDefinitions的源码： 1234567891011121314151617181920212223/** * Register the bean definitions contained in the given DOM document. * Called by &#123;@code loadBeanDefinitions&#125;. * &lt;p&gt;Creates a new instance of the parser class and invokes * &#123;@code registerBeanDefinitions&#125; on it. * @param doc the DOM document * @param resource the resource descriptor (for context information) * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of parsing errors * @see #loadBeanDefinitions * @see #setDocumentReaderClass * @see BeanDefinitionDocumentReader#registerBeanDefinitions */public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //实例化 BeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获取之前的beanDefinition加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); //加载xml及注册bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //记录本次加载个数 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 在registerBeanDefinitions方法具体实现： 1：通过BeanUtils.instantiateClass(this.documentReaderClass)的方法实例化BeanDefinitionDocumentReader； 2：通过DefaultListAbleBeanFactory中的beanDefinitionMap.size()获取之前注册bean的个数，（beanDefinitionMap是存储最终的xml解析后信息的载体，xml解析后信息是由GenericBeanDefinition进行存储，beanDefinitionMap的存储格式是key:String value:GenericBeanDefinition） 3:将解析xml和注册的工作委托给BeanDefinitionDocumentReader的registerBeanDefinitions方法； 4：记录本次加载个数并返回； 继续看BeanDefinitionDocumentReader的registerBeanDefinitions方法： 12345678910111213/** * This implementation parses bean definitions according to the "spring-beans" XSD * (or DTD, historically). * &lt;p&gt;Opens a DOM Document; then initializes the default settings * specified at the &#123;@code &lt;beans/&gt;&#125; level; then parses the contained bean definitions. */@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; //实例化 ReaderContext this.readerContext = readerContext; //注册 doRegisterBeanDefinitions(doc.getDocumentElement());&#125; registerBeanDefinitions并没有做什么，我们继续看doRegisterBeanDefinitions方法： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Register each bean definition within the given root &#123;@code &lt;beans/&gt;&#125; element. */@SuppressWarnings("deprecation") // for Environment.acceptsProfiles(String...)protected void doRegisterBeanDefinitions(Element root) &#123; // Any nested &lt;beans&gt; elements will cause recursion in this method. In // order to propagate and preserve &lt;beans&gt; default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); //验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI if (this.delegate.isDefaultNamespace(root)) &#123; //获取Attribute String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec + "] not matching: " + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; //解析前处理， 内容null 留个子类实现 preProcessXml(root); //解析 parseBeanDefinitions(root, this.delegate); //解析后处理， 内容null 留个子类实现 postProcessXml(root); this.delegate = parent;&#125; 在doRegisterBeanDefinitions烦那个发中验证xml的namespace,最重要的方法是parseBeanDefinitions，parseBeanDefinitions方法进行了解析操作； parseBeanDefinitions方法的源码： 1234567891011121314151617181920212223242526272829/** * Parse the elements at the root level in the document: * "import", "alias", "bean". * @param root the DOM root element of the document */protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; //验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //对默认标签处理 parseDefaultElement(ele, delegate); &#125; else &#123; //对自定义标签处理 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //对自定义标签处理 delegate.parseCustomElement(root); &#125;&#125; parseBeanDefinitions方法中已经开始对标签进行解析，区分默认标签和自定义标签，我们本次只对默认标签的源码进行解析，自定义标签自行DeBug， parseDefaultElement方法的源码： 12345678910111213141516171819private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //解析import标签 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //解析alias标签并注册 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; //解析bean标签并注册 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; //解析beans标签 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 到这里我们可以看到，spring对import/bean/alias/beans的解析过程，对于beans的解析无法就是解析beans中的bean标签，spring直接又重新调用了doRegisterBeanDefinitions方法，我们接下来进行对bean标签的解析； processBeanDefinition方法： 123456789101112131415161718192021222324252627/** * Process the given bean element, parsing the bean definition * and registering it with the registry. */protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; //委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析并返回 //BeanDefinitionHolder实例，BeanDefinitionHolder已经包含了配置文件中的各种属性 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); //当BeanDefinitionHolder返回不null的情况，弱存在默认标签下的子标签再有自定义的属性，还需要再次解析 if (bdHolder != null) &#123; //解析默认标签中的自定义标签 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. // 进行实例注册注册操作是BeanDefinitionReaderUtisl.registerBeanDefinition进行处理 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error("Failed to register bean definition with name '" + bdHolder.getBeanName() + "'", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 在processBeanDefinition方法中，spring做了两件事情： 1：委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析并返回BeanDefinitionHolder实例，BeanDefinitionHolder已经包含了配置文件中的各种属性 2：通过上获得的BeanDefinitionHolder进行bean的注册操作，通BeanDefinitionReaderUtils.registerBeanDefinition方法； 通过delegate.parseBeanDefinitionElement方法进行xml解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Parses the supplied &#123;@code &lt;bean&gt;&#125; element. May return &#123;@code null&#125; * if there were errors during parse. Errors are reported to the * &#123;@link org.springframework.beans.factory.parsing.ProblemReporter&#125;. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; //解析id属性 String id = ele.getAttribute(ID_ATTRIBUTE); //解析name属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //分割name属性 List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isTraceEnabled()) &#123; logger.trace("No XML 'id' specified - using '" + beanName + "' as bean name and " + aliases + " as aliases"); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; //将信息封装到 beanDefinition中 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; //beanname不存在则使用默认规则创建 if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace("Neither XML 'id' nor 'name' specified - " + "using generated bean name [" + beanName + "]"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null; &#125; 在parseBeanDefinitionElement方法中做了三件事： 1：解析id/name； 2：检查name的唯一性； 3：将信息封装到 beanDefinition中，接下来直接看parseBeanDefinitionElement方法； parseBeanDefinitionElement源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Parse the bean definition itself, without regard to name or aliases. May return * &#123;@code null&#125; if problems occurred during the parsing of the bean definition. */ @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; //解析classname属性 if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; String parent = null; //解析parent属性 if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; //创建用于承载属性的AbstractBeanDefinition类型的 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //解析bean的各种属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //提取description bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //解析meta （元数据） parseMetaElements(ele, bd); //解析Lookup-method 书中53页有使用方法 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //解析replaced-method 书中55页有使用方法 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //构造函数 参数 //解析constructor-arg 书中replaced-method后边 parseConstructorArgElements(ele, bd); //解析Property 书中replaced-method后边 parsePropertyElements(ele, bd); //解析Qualifier 书中Property后边 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error("Bean class [" + className + "] not found", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error("Class that bean class [" + className + "] depends on not found", ele, err); &#125; catch (Throwable ex) &#123; error("Unexpected failure during bean definition parsing", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null; &#125; 通过上述代码我们可以看到这里首先是实例化了一个AbstractBeanDefinition来承载各种xml属性，接下来通过parseBeanDefinitionAttributes方法解析了xml中的各种你属性值，然后在解析lookUp-method(方法注入)，replaced-method(替换方法或方法返回值)，构造函数参数constructor-arg，property属性，Qualifier属性等；上述方法的源码就不一一展示了，无非都是通过Element进行解析； 接下来看真正注册的代码 BeanDefinitionReaderUtils.registerBeanDefinition 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; //beanName不可为空 Assert.hasText(beanName, "Bean name must not be empty"); //beanDefinition不可为空 Assert.notNull(beanDefinition, "BeanDefinition must not be null"); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; //校验 MethodOverrides，MethodOverrides在解析并组装beanDefinition时有提到 ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, "Validation of bean definition failed", ex); &#125; &#125; //beanDefinitionMap 存储实例的全局Map 使用ConcurrentHashMap 线程安全 BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); //如果已经注册 处理内容 if (existingDefinition != null) &#123; //是否覆盖 if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); &#125; else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) &#123; logger.info("Overriding user-defined bean definition for bean '" + beanName + "' with a framework-generated bean definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]"); &#125; &#125; else if (!beanDefinition.equals(existingDefinition)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Overriding bean definition for bean '" + beanName + "' with a different definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]"); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Overriding bean definition for bean '" + beanName + "' with an equivalent definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]"); &#125; &#125; this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; //判断是否已经至少创建过一次 使用AbstractBeanFactory.alreadyCreated来判断 if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // 仍处于启动注册阶段 // 注册 beanDefinitionMap 新实例 beanName + beanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 增加beanDefinitionNames this.beanDefinitionNames.add(beanName); // 清除缓存 this.manualSingletonNames.remove(beanName); &#125; // 清除缓存 this.frozenBeanDefinitionNames = null; &#125; if (existingDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125; &#125; 上述代码中首先验证了beanName和BeannDefinition不可为空,然后继续校验了MethodOverridesMethodOverrides在解析并组装beanDefinition时lookup-method和recpse-method的源码中有提到，继续判断beanDefinitionMap是否存在该bean，如果bean已经存在，通过allowBeanDefinitionOverriding属性判断是否可覆盖，反之则抛出异常；如果不存在则需要判断本次是否是第一次注册bean，如果是则初始化beanDefinitionMap后进行put操作，反之直接put beanDefinitionMap完成注册； 至此我们已经看完了整个XmlBeanFactory的xml解析和注册的源码部分，相信看本篇文章无法真正理解，还需要读者下载源码使用debug运行，再结合本篇文章的注释，相信会很容易理解，码字不易，转发请注明出处：https://blog.csdn.net/qq_30257149/article/details/87972291 博客地址：https://lantaogithub.github.io]]></content>
      <categories>
        <category>spring源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
        <tag>XMLBeanFactory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之ApplicationContext]]></title>
    <url>%2F2019%2F02%2F27%2FSpring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BApplicationContext%2F</url>
    <content type="text"><![CDATA[​ 本文是针对Srping的ClassPathXMLApplicationContext来进行源码解析,在本篇博客中将不会讲述spring Xml解析注册代码，因为ApplicationContext是BeanFactory的扩展版本， ApplicationContext的GetBean和xml解析注册BeanDefinition都是用一套代码，如果您是第一次看请先看一下XMLBeanFactory解析和BeanFactory.GetBean源码解析： XMLBeanFactory源码解析地址：https://blog.csdn.net/qq_30257149/article/details/87972291 BeanFactory.getBean源码解析地址：https://blog.csdn.net/qq_30257149/article/details/88016361 作者整理了spring-framework 5.x的源码注释，代码已经上传者作者的GitHub了，可以让读者更好的理解，地址： GItHub:https://github.com/lantaoGitHub/spring-framework.git 接下来我们你直接上源码： 123456789101112131415package lantao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.lantao.UserBean;public class ApplicationContextTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-bean.xml"); UserBean userBean = (UserBean) applicationContext.getBean("userBean"); System.out.println(userBean.getName()); &#125;&#125; 在这里直接使用ClassPathXmlApplicationContext进行xml解析，在这里xml解析的代码和GetBean的代码就不过多的描述了，ApplicationContext是BeanFactory的扩展，所以想要看这两部分源码的请看作者的上两篇博客Sprin源码解析； 接下来我们看一下ClassPathXmlApplicationContext的源码： 12345678910111213141516171819202122/** * Create a new ClassPathXmlApplicationContext with the given parent, * loading the definitions from the given XML files. * @param configLocations array of resource locations * @param refresh whether to automatically refresh the context, * loading all bean definitions and creating all singletons. * Alternatively, call refresh manually after further configuring the context. * @param parent the parent context * @throws BeansException if context creation failed * @see #refresh() */public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123; super(parent); // 支持解析多文件 setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125;&#125; 在setConfigLocations方法中将资源文件放入configLocations全局变量中，，并且支持多文件解析，接下来我们你看一下重点，refresh方法； 源码refresh方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备刷新上下文 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 对beanFactory的各种功能填充，加载beanFactory，经过这个方法 applicationContext就有了BeanFactory的所有功能 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 对beanFactory进行各种功能填充 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 允许在context子类中对BeanFactory进行post-processing。 // 允许在上下文子类中对Bean工厂进行后处理 // 可以在这里进行 硬编码形式的 BeanFactoryPostProcessor 调用 addBeanFactoryPostProcessor postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 激活各种BeanFactory处理器 BeanFactoryPostProcessors是在实例化之前执行 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册 拦截Bean创建 的Bean处理器，这里只是注册，真正地调用在getBean的时候 BeanPostProcessors实在init方法前后执行 doCreateBean方法中的 实例化方法中执行 // BeanPostProcessor执行位置：doCreateBean --&gt; initializeBean --&gt; applyBeanPostProcessorsBeforeInitialization 和 applyBeanPostProcessorsAfterInitialization registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //为上下文初始化Message源，（比如国际化处理） 这里没有过多深入 initMessageSource(); // Initialize event multicaster for this context. //初始化应用消息广播，并放入 applicationEventMulticaster bean中 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //留给子类来初始化其它的bean onRefresh(); // Check for listener beans and register them. //在所有注册的bean中查找Listener bean，注册到消息广播器中 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //初始化剩下的单实例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //完成刷新过程，通知生命周期护处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人（LifecycleProcessor 用来与所有声明的bean的周期做状态更新） finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 对于ApplicationContext来说，refresh方法几乎涵盖了所有的基础和扩展功能，接下来看一下这个方法都做了什么； 刷新上下文，初始化前的准备工作； 加载beanFactory，经过这个方法 applicationContext就有了BeanFactory的所有功能 对beanFactory进行各种功能填充 允许在这里对BeanFactory的二次加工，例如：可以在这里进行硬编码方法的对BeanFactory进行BeanFactoryPostProcessor或BeanPostProcessor的操作；在这里简单说一下BeanFactoryPostProcessor是在bean实例化之前执行的，BeanPostProcessor是在初始化方法前后执行的，BeanFactoryPostProcessor操作的是BeanFactoryBeanPostProcessor操作的是Bean，其次这里还涉及了一个扩展BeanDefinitionRegistryPostProcessor它是继承了BeanFactoryPostProcessor，并且还有自己的定义方法 postProcessBeanDefinitionRegistry，这个方法可以操作BeanDefinitionRegistry，BeanDefinitionRegistry有个最主要的方法就是registerBeanDefinition，可以注册BeanDefinition，可以用这方法来处理一下不受spring管理的一下bean； 处理所有的BeanFactoryPostProcessor，也可以说是激活BeanFactory处理器，在这个方法里会先处理BeanDefinitionRegistryPostProcessor，在处理BeanFactoryPostProcessor，因为BeanDefinitionRegistryPostProcessor有自己的定义，所以先执行； 注册BeanPostProcessors ，这里只是注册，真正地调用在getBean的时候 BeanPostProcessors实在init方法前后执行 BeanPostProcessor执行位置：doCreateBean –&gt; initializeBean –&gt; applyBeanPostProcessorsBeforeInitialization 和 applyBeanPostProcessorsAfterInitialization方法中； 为上下文初始化Message源，（比如国际化处理） 这里没有过多深入； 初始化应用消息广播，初始化 applicationEventMulticaster ，判断使用自定义的还是默认的； 留给子类来初始化其它的bean； 在所有注册的bean中查找 ApplicationListener bean，注册到消息广播器中； 初始化剩下的单实例（非懒加载），这里会是涉及conversionService，LoadTimeWeaverAware，冻结BeanFactory，初始化Bean等操作； 完成刷新过程，包括 清除 下文级资源(例如扫描的元数据)，通知生命周期护处理器lifecycleProcessor并strat，同时publish Event发出ContextRefreshEvent通知别人； 先来看prepareRefresh方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Prepare this context for refreshing, setting its startup date and * active flag as well as performing any initialization of property sources. */protected void prepareRefresh() &#123; // Switch to active. this.startupDate = System.currentTimeMillis(); // 标志，指示是否已关闭此上下文 this.closed.set(false); // 指示此上下文当前是否处于活动状态的标志 this.active.set(true); if (logger.isDebugEnabled()) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Refreshing " + this); &#125; else &#123; logger.debug("Refreshing " + getDisplayName()); &#125; &#125; // Initialize any placeholder property sources in the context environment. // 对上下文环境中的任何属性源进行分类。 initPropertySources(); // Validate that all properties marked as required are resolvable: // see ConfigurablePropertyResolver#setRequiredProperties， //验证标示为必填的属性信息是否都有了 ConfigurablePropertyResolver#setRequiredProperties 方法 getEnvironment().validateRequiredProperties(); // Store pre-refresh ApplicationListeners... if (this.earlyApplicationListeners == null) &#123; this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); &#125; else &#123; // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); &#125; // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();&#125; 一眼望去，可能觉得这个方法没有做什么，其实这方法中除了Closed和Active最终要的是initPropertySources和getEnvironment().validateRequiredProperties()方法； initPropertySources证符合Spring的开放式结构设计，给用户最大扩展Spring的能力。用户可以根据自身的需要重写initPropertySourece方法，并在方法中进行个性化的属性处理及设置。 validateRequiredProperties则是对属性进行验证，那么如何验证呢？举个融合两句代码的小例子来理解。 例如现在有这样一个需求，工程在运行过程中用到的某个设置（例如VAR）是从系统环境变量中取得的，而如果用户没有在系统环境变量中配置这个参数，工程不会工作。这一要求也各种各样许有的解决办法，在Spring中可以这么做，可以直接修改Spring的源码，例如修改ClassPathXmlApplicationContext.淡然，最好的办法是对源码进行扩展，可以自定义类： 12345678910&gt; public class MyClassPathXmlApplicationContext extends ClassPathXmlApplicationContext&#123;&gt; public MyClassPathXmlApplicationContext(String.. configLocations)&#123;&gt; super(configLocations);&gt; &#125;&gt; protected void initPropertySources()&#123;&gt; //添加验证要求&gt; getEnvironment().setRequiredProterties("VAR")；&gt; &#125;&gt; &#125;&gt; 自定义了继承自ClassPathXmlApplicationContext的MyClassPathXmlApplicationContext,并重写了initPropertySources方法，在方法中添加了个性化需求，那么在验证的时候也就是程序走到getEnvironment().validateRequiredProperties()代码的时候，如果系统并没有检测到对应VAR的环境变量，将抛出异常。当然我们还需要在使用的时候替换掉原有的ClassPathXmlApplicationContext: 12345&gt;public static void main(Stirng[] args)&#123;&gt; ApplicationContext bf = new MyClassPathXmlApplicationContext("myTest.xml")；&gt; User user = (User)bf.getBean("testBean");&gt; &#125;&gt; 上述案例来源于：Spring源码深度解析（第二版）141页； 接下来看一下obtainFreshBeanFactory方法，在这里初始化DefaultListAbleBeanFactory并解析xml： 12345678910/** * Tell the subclass to refresh the internal bean factory. * @return the fresh BeanFactory instance * @see #refreshBeanFactory() * @see #getBeanFactory() */protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; refreshBeanFactory(); return getBeanFactory();&#125; 1234567891011121314151617181920212223242526272829/** * This implementation performs an actual refresh of this context's underlying * bean factory, shutting down the previous bean factory (if any) and * initializing a fresh bean factory for the next phase of the context's lifecycle. */@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; // createBeanFactory方法直接新建一个DefaultListableBeanFactory，内部使用的是DefaultListableBeanFactory实例 DefaultListableBeanFactory beanFactory = createBeanFactory(); // 设置序列化id beanFactory.setSerializationId(getId()); // 定制beanFactory工厂 customizeBeanFactory(beanFactory); // 加载BeanDefinition loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; // 使用全局变量记录BeanFactory this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); &#125;&#125; 看一下上述方法都做了什么： 判断BeanFactory是否存在，如果存在则销毁所有Bean，然后关闭BeanFactory； 使用createBeanFactory方法直接新建一个DefaultListableBeanFactory，内部使用的是DefaultListableBeanFactory实例； 设置BeanFactory的设置序列化id 定制beanFactory工厂，也就是给allowBeanDefinitionOverriding(是否允许覆盖同名称的Bean)和allowCircularReferences(是否允许bean存在循环依赖)，可通过setAllowBeanDefinitionOverriding和setAllowCircularReferences赋值,这里就可通过商编初始化方法中的initPropertySources方法来进行赋值； 123456789101112131415161718&gt; package lantao;&gt; import org.springframework.context.support.ClassPathXmlApplicationContext;&gt;&gt; public class MyApplicationContext extends ClassPathXmlApplicationContext &#123;&gt;&gt; public MyApplicationContext(String... configLocations)&#123;&gt; super(configLocations);&gt; &#125;&gt; protected void initPropertySources()&#123;&gt; //添加验证要求&gt; getEnvironment().setRequiredProperties("VAR");&gt; &gt; // 在这里添加set&gt; super.setAllowBeanDefinitionOverriding(true);&gt; super.setAllowCircularReferences(true);&gt; &#125;&gt; &#125;&gt; 加载BeanDefinition，就是解析xml，循环解析，这里就不看了，如果不了解看作者上篇博客； 下面看一下prepareBeanFactory方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context's class loader etc. // 设置BeanFactory的classLoader为当前context的classloader beanFactory.setBeanClassLoader(getClassLoader()); // Spel语言解析器 // 设置BeanFactory的表达式语言处理器 Spring3中增加了表达式语言的支持 // 默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值 // 在Bean实例化的时候回调用 属性填充的方法(doCreateBean 方法中的 populateBean 方法中的 applyPropertyValues 方法中的 evaluateBeanDefinitionString ) 就会判断beanExpressionResolver是否为null操作 beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 为BeanFactory增加一个默认的 PropertyEditor 这个主要对bean的属性等设置管理的一个工具 增加属性注册编辑器 例如：bean property 类型 date 则需要这里 // beanFactory会在初始化 BeanWrapper（initBeanWrapper）中调用 ResourceEditorRegistrar 的 registerCustomEditors 方法 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. // ApplicationContextAwareProcessor --&gt; postProcessBeforeInitialization // 注册 BeanPostProcessor BeanPostProcessor 实在实例化前后执行的 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 设置几个忽略自动装配的接口 在addBeanPostProcessor方法中已经对下面几个类做了处理，他们就不是普通的bean了，所以在这里spring做bean的依赖的时候忽略 // doCreateBean 方法中的 populateBean 方法中的 autowireByName 或 autowireByType 中的 unsatisfiedNonSimpleProperties 中的 !isExcludedFromDependencyCheck(pd) 判断， // 在属性填充的时候回判断依赖，如果存在下属几个则不做处理 对于下面几个类可以做implements操作 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. // 设置几个注册依赖 参考spring源码深度解析原文：当注册依赖解析后，例如但那个注册了对BeanFactory。class的解析依赖后，当bean的属性注入的时候，一旦检测到属性为BeanFactory的类型变回将beanFactory 实例注入进去 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. // 寄存器早期处理器，用于检测作为ApplicationListener的内部bean。 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. // 增加了对AxpectJ的支持 if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. // 添加默认的系统环境bean if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 不说废话，直接看这个方法都做了什么: 设置BeanFactory的classLoader为当前context的classloader; 设置BeanFactory的表达式语言处理器 Spring3中增加了Spel表达式语言的支持, 默认可以使用#{bean.xxx}的形式来调用相关属性值， 在Bean实例化的时候回调用 属性填充的方法(doCreateBean 方法中的 populateBean 方法中的 applyPropertyValues 方法中的 evaluateBeanDefinitionString ) 就会判断beanExpressionResolver是否为null操作，如果不是则会使用Spel表达式规则解析 1234567891011121314151617181920212223&gt; &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&gt; &lt;beans&gt; xmlns="http://www.springframework.org/schema/beans"&gt; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; xsi:schemaLocation="http://www.springframework.org/schema/beans&gt; http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&gt; &gt; &lt;bean id="testOneBean" class="lantao.bean.TestOneBean"&gt;&gt; &lt;property name="testTwoBean" value="#&#123;testTWoBean&#125;"/&gt;&gt; &lt;/bean&gt;&gt; &gt; &lt;bean id="testTWoBean" class="lantao.bean.TestTwoBean"/&gt;&gt; &gt; &lt;!-- 上面 相当于 下边 --&gt;&gt; &gt; &lt;bean id="testOneBean1" class="lantao.bean.TestOneBean"&gt;&gt; &lt;property name="testTwoBean" ref="testTWoBean1"/&gt;&gt; &lt;/bean&gt;&gt; &gt; &lt;bean id="testTWoBean1" class="lantao.bean.TestTwoBean"/&gt;&gt; &gt; &lt;/beans&gt;&gt; 为BeanFactory增加一个默认的 PropertyEditor 这个主要对bean的属性等设置管理的一个工具 增加属性注册编辑器 例如：User类中 startDate 类型 date 但是xml property的value是2019-10-10，在启动的时候就会报错，类型转换不成功，这里可以使用继承PropertyEditorSupport这个类机型重写并注入即可使用；beanFactory会在初始化BeanWrapper (initBeanWrapper)中调用 ResourceEditorRegistrar 的 registerCustomEditors 方法进行初始化； 配置BeanPostProcessor，这里配置的是ApplicationContextAwareProcessor，上边我们说了，BeanPostProcessor是在初始化方法Init前后执行，看一下ApplicationContextAwareProcessor的Before和After方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt;@Override&gt; @Nullable&gt; public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;&gt; AccessControlContext acc = null;&gt; &gt; // 该方法也会在 BeanFactory 实例化bean 中调用 doCreateBean --&gt; initializeBean --&gt; applyBeanPostProcessorsBeforeInitialization --&gt; postProcessBeforeInitialization&gt; // 如果实例化的类实现了 invokeAwareInterfaces 方法中的判断类 则会调用初始方法赋值&gt; if (System.getSecurityManager() != null &amp;&amp;&gt; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||&gt; bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||&gt; bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;&gt; acc = this.applicationContext.getBeanFactory().getAccessControlContext();&gt; &#125;&gt; &gt; if (acc != null) &#123;&gt; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;&gt; invokeAwareInterfaces(bean);&gt; return null;&gt; &#125;, acc);&gt; &#125;&gt; else &#123;&gt; invokeAwareInterfaces(bean);&gt; &#125;&gt; return bean;&gt; &#125;&gt; private void invokeAwareInterfaces(Object bean) &#123;&gt; if (bean instanceof Aware) &#123;&gt; if (bean instanceof EnvironmentAware) &#123;&gt; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());&gt; &#125;&gt; if (bean instanceof EmbeddedValueResolverAware) &#123;&gt; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);&gt; &#125;&gt; if (bean instanceof ResourceLoaderAware) &#123;&gt; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);&gt; &#125;&gt; if (bean instanceof ApplicationEventPublisherAware) &#123;&gt; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);&gt; &#125;&gt; if (bean instanceof MessageSourceAware) &#123;&gt; ((MessageSourceAware) bean).setMessageSource(this.applicationContext);&gt; &#125;&gt; if (bean instanceof ApplicationContextAware) &#123;&gt; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; @Override&gt; public Object postProcessAfterInitialization(Object bean, String beanName) &#123;&gt; return bean;&gt; &#125;&gt; 在Before方法中调用了invokeAwareInterfaces方法，在invokeAwareInterfaces方法中做了类型 instanceof 的判断，意思就是如果这个Bean实现了上述的Aware，则会初始会一下资源，比如实现了ApplicationContextAware，就会setApplicationContext，这里相信大家都用过，就不多说了； 设置几个忽略自动装配的接口 在addBeanPostProcessor方法中已经对下面几个类做了处理，他们就不是普通的bean了，所以在这里spring做bean的依赖的时候忽略，在doCreateBean 方法中的 populateBean 方法中的 autowireByName 或 autowireByType 中的 unsatisfiedNonSimpleProperties 中的 !isExcludedFromDependencyCheck(pd) 判断，如果存在则不做依赖注入了； 设置几个注册依赖 参考spring源码深度解析原文：当注册依赖解析后，例如当注册了对BeanFactory的解析依赖后，当bean的属性注入的时候，一旦检测到属性为BeanFactory的类型便会将beanFactory 实例注入进去； 添加BeanPostProcessor，这里是添加ApplicationListener，是寄存器早期处理器；这里可以看作者的源码测试，在spring-context的test测试类下有； 增加了对AxpectJ的支持 注册默认的系统环境bean，environment ，systemProperties，systemEnvironment； 上述就是对BeanFactory的功能填充，下面看postProcessBeanFactory: postProcessBeanFactory方法是个空方法，允许在上下文子类中对Bean工厂进行后处理，例如：可以在这里进行 硬编码形式的 BeanFactoryPostProcessor 调用 addBeanFactoryPostProcessor，进行addBeanFactoryPostProcessor或者是BeanPostProcessor； 接下来看一下invokeBeanFactoryPostProcessors方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123; // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); // 对 BeanDefinitionRegistry 类型处理 if (beanFactory instanceof BeanDefinitionRegistry) &#123; // 强转 BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // 普通的处理器 List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); //注册处理器 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); // 这里就是硬编码处理 因为这里是从 getBeanFactoryPostProcessors()方法获取的 可以硬编码从addBeanFactoryPostProcessor（）方法添加 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; // 对于 BeanDefinitionRegistryPostProcessor 类型 在 BeanFactoryPostProcessor 的基础上还有自己的定义，需要先调用 BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; // 执行 继承 BeanDefinitionRegistryPostProcessor 类的 postProcessBeanDefinitionRegistry 方法 registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; //上边的For循环只是调用了硬编码的 BeanDefinitionRegistryPostProcessor 中的 postProcessBeanDefinitionRegistry 方法， // 但是 BeanFactoryPostProcessor 中的 postProcessBeanFactory 方法还没有调用，是在方法的最后一行 // invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); // invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); 这两个方法中执行的， // 下面是自动处理器 获取类型是BeanDefinitionRegistryPostProcessor beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 获取的 // 当前注册处理器 List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. // 首先调用实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); // 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. // 下一个 ，调用实现 Ordered 的 BeanDefinitionRegistryPostProcessors postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); // 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. // 最后，调用所有其他BeanDefinitionRegistryPostProcessors，直到不再显示其他BeanDefinitionRegistryPostProcessors 无序的 boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); // 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); &#125; // 现在，调用到目前为止处理的所有处理器的 执行BeanFactoryPostProcessor 类的 postProcessBeanFactory 方法 // 这里执行的是 硬编码 和 非硬编码（自动）的 BeanFactoryPostProcessor 类的 postProcessBeanFactory 方法 分为硬编码处理器 和 普通处理器 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; else &#123; // 调用在上下文实例中注册的工厂处理器的postProcessBeanFactory方法。 就是硬编码 通过 addBeanFactoryPostProcessor 方法添加的BeanFactoryPostProcessor invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); &#125; // 自动处理 非硬编码 获取类型为是BeanFactoryPostProcessor beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. // 实现 priorityOrdered 的 List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); // 实现 Ordered 的 List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); // 无序的 List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache();&#125; 上述代码看起来很多，但是总计起来就三件事： 执行硬编码的和主动注入的BeanDefinitionRegistryPostProcessor,调用postProcessBeanDefinitionRegistry方法； 执行硬编码的和主动注入的BeanFactoryPostProcessor，调用postProcessBeanFactory方法； 自动注入的可继承Ordered排序，priorityOrdered排序或无序； 上述测试在作者的spring源码congtext中lantao包下有测试用例； registerBeanPostProcessors方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. // 使用 priorityOrdered保证顺序 List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); // MergedBeanDefinitionPostProcessor List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;(); // 使用order保证顺序 List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); // 无序的 List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); // 进行add操作 for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, register the BeanPostProcessors that implement PriorityOrdered. // 首先 注册实现PriorityOrdered的 BeanPostProcessors 先排序PostProcessors sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. // 下一个，注册实现Ordered的BeanPostProcessors List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(); for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. // 现在，注册所有常规注册。无序的 List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. // 最后，注册所有MergedBeanDefinitionPostProcessor类型的BeanPostProcessor,并非重复注册。 sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). // 添加 ApplicationListener探测器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125; registerBeanPostProcessors方法代码还是比较长的，它和invokeBeanFactoryPostProcessors方法最主要的区别就是registerBeanPostProcessors只在这里注册，但不在这里调用，做的事情和invokeBeanFactoryPostProcessors差不多： 使用priorityOrdered，Ordered或无序保证顺序； 通过beanFactory.addBeanPostProcessor(postProcessor)进行注册； 很简单，代码篇幅很长，但是很好理解，这里可以简单看一下； 接下来是initMessageSource方法，这里作者没有过多的看源码，后续补上吧…….(抱歉) initApplicationEventMulticaster源码： 12345678910111213141516171819202122232425/** * Initialize the ApplicationEventMulticaster. * Uses SimpleApplicationEventMulticaster if none defined in the context. * @see org.springframework.context.event.SimpleApplicationEventMulticaster */protected void initApplicationEventMulticaster() &#123; ConfigurableListableBeanFactory beanFactory = getBeanFactory(); // 使用自定义的 广播 if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123; this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isTraceEnabled()) &#123; logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]"); &#125; &#125; else &#123; // 使用spring 默认的广播 this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isTraceEnabled()) &#123; logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " + "[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]"); &#125; &#125;&#125; initApplicationEventMulticaster方法中主要就是判断是使用自定义的ApplicationEventMulticaster(广播器)还是使用呢Spring默认的SimpleApplicationEventMulticaster广播器； onRefresh 方法是留个子类重写的，内容是空； registerListeners方法： 1234567891011121314151617181920212223242526272829/** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */protected void registerListeners() &#123; // Register statically specified listeners first. // 注册 添加 ApplicationListener 这里通过硬编码 addApplicationListener 方法添加的 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! // 注册 添加 ApplicationListener 这里是自动注册添加的 String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // Publish early application events now that we finally have a multicaster... // 发布早期的事件 Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125;&#125; registerListeners方法做了三件事情： 添加 ApplicationListener 这里通过硬编码 addApplicationListener 方法添加的； 添加 ApplicationListener 是通过自动注册添加的 发布早起事件 finishBeanFactoryInitialization方法源码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Finish the initialization of this context's bean factory, * initializing all remaining singleton beans. */protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // Initialize conversion service for this context. // conversionService 用于类型转换 ，比如 String 转Date //判断BeanFactory中是否存在名称为“conversionService”且类型为ConversionService的Bean，如果存在则将其注入到beanFactory // 判断有无自定义属性转换服务接口，并将其初始化，我们在分析bean的属性填充过程中，曾经用到过该服务接口。在TypeConverterDelegate类的convertIfNecessary方法中 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); &#125; // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early. // 得到所有的实现了LoadTimeWeaverAware接口的子类名称，初始化它们 // 如果有LoadTimeWeaverAware类型的bean则初始化，用来加载Spring Bean时织入第三方模块,如AspectJ，我们在后面详细讲解。 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. // 停止使用临时类加载器 就是在这里不让使用呢 ClassLoader 了 beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. // 冻结所有bean定义，说明你注册的bean将不被修改或进行任何进一步的处理 就是不让改了 BeanDefinition beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. // 初始化所有非懒加载的 单例 bean 调用你getBean方法 beanFactory.preInstantiateSingletons();&#125; finishBeanFactoryInitialization方法做了五件事情： 设置BeanFactory的conversionService，conversionService用于类型转换使用, 例如：User类中 startDate 类型 date 但是xml property的value是2019-10-10，在启动的时候就会报错，类型转换不成功，可以使用conversionService；书中170页有具体代码； 添加BeanFactory的addEmbeddedValueResolver，读取配置信息放到这里，可以通过EmbeddedValueResolverAware来获取，参考：https://www.cnblogs.com/winkey4986/p/7001173.html 得到所有的实现了LoadTimeWeaverAware接口的子类名称，初始化它们，用来加载Spring Bean时织入第三方模块,如AspectJ，我们在后面详细讲解。 停止使用临时类加载器 就是在这里不让使用呢 ClassLoader 了 冻结所有bean定义，说明你注册的bean将不被修改或进行任何进一步的处理 就是不让改了 BeanDefinition 初始化所有非懒加载的 单例 bean 调用你getBean方法，循环所有bean并实例化 条件是：单例，非Abstract 非懒加载 最后的一个方法finishRefresh： 123456789101112131415161718192021222324252627/** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * &#123;@link org.springframework.context.event.ContextRefreshedEvent&#125;. */protected void finishRefresh() &#123; // Clear context-level resource caches (such as ASM metadata from scanning). // 清除 下文级资源(例如扫描的元数据)。 clearResourceCaches(); // Initialize lifecycle processor for this context. // 在当前context中初始化 lifecycle // lifecycle 有自己的 start/ stop方法，实现此接口后spring保证在启动的时候调用start方法开始生命周期 关闭的时候调用 stop方法结束生命周期 initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. // onRefresh 启动所有实现了 lifecycle 的方法 getLifecycleProcessor().onRefresh(); // Publish the final event. // 当ApplicationContext初始化完成发布后发布事件 处理后续事宜 publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. // 这里 没明白》。。 LiveBeansView.registerApplicationContext(this);&#125; finishRefresh方法是ApplicationContext初始化的最后一个方法了，他做了一些结尾的事情： 清除 下文级资源(例如扫描的元数据)。 在当前context中初始化 lifecycle，lifecycle 有自己的 start/ stop方法，实现此接口后spring保证在启动的时候调用start方法开始生命周期 关闭的时候调用 stop方法结束生命周期。 onRefresh 启动所有实现了 lifecycle 的方法，调用了start方法。 当ApplicationContext初始化完成发布事件 处理后续事宜。 LiveBeansView.registerApplicationContext(this)这个代码没有太明白，有大神可以留言； 至此ApplicationContext的源码就都已经分析完成了，其中有很多地方很难懂，大家可以对应着源码一起看，会好理解一些，如果其中有错误，欢迎大神指点，在下方留言，本篇博客是作者参考SPring 源码深度解析 + 自己的理解写出来的，算是一个学习后的的产出，最后，码字不易，转载请注明出处。 博客地址：https://lantaogithub.github.io]]></content>
      <categories>
        <category>spring源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
        <tag>ApplicationContext</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程的宏观和微观视角]]></title>
    <url>%2F2019%2F02%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8F%E8%A7%82%E5%92%8C%E5%BE%AE%E8%A7%82%E8%A7%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能； 微观视角 可见性: 一个线程对共享变量的修改，另外一个线程能够立刻感知到，我们称为可见性; 原子性： 一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性； 有序性： 就是我们代码的执行顺序，依赖等。(指令重排导致顺序被打乱); &#8195;&#8195;线程工作内存： 是指 Cpu 的 ‘寄存器’ 和 ‘高速缓存’，线程的 工作内存/本地内存 是指cpu的寄存器和高速缓存的抽象描述,数据读取顺序优先级 是：寄存器－&gt;高速缓存－&gt;内存 宏观视角 安全性： 安全性我认为其实是包含了原子性丶可见性和有序性的，是一个总的概念，在程序开发的时候首先要注重安全性，会在下面详细解释这三点； 活跃性活跃性告诉我们的是要避免死锁，饥饿和活锁；— 死锁：这个都不陌生，线程A持有1锁，等待获取2锁，线程B持有2锁，等待获取1锁，这就是个典型的死锁，就就是阻塞了。— 饥饿：饥饿当多线程获取锁都得时候，总有线程没有机会获取到锁，出现饥饿的三中情况：1-高优先级的线程吞噬了低优先级线程的CPU使用权 2-线程被一直阻塞(比如Thread.Sleep) 3-等待线程永远不被唤醒，也可以理解为锁的优先级，我们常用的synchronized就是非公平锁，例如线程A，B,C按顺序获取锁1，首先是A获取到了锁，执行完临界区代码释放了锁，这是线程D来了直接获取到了锁，这就是非公平锁；ReentrantLock()默认是非公平锁，可以在ReentractLock（true）创建公平锁； — 活锁：在生活中A和B同时进入左手门，为了不发生碰撞，A和B互相礼让同时进入了右手门，为了不发生碰撞又进入了左手们会一直循环下去，实例代码找到适用的场景在增加 性能1：延迟: 延迟就是指一个请求调用到返回所使用的时间，时间越短，程序的处理的就越快，性能也就会高；2：吞吐量: 吞吐量就是值在单位时间内(秒)处理的请求数量，吞吐量越大，程序处理的请求就越多，性能也越好； 可见性：线程工作空间导致可见性问题&#8195;&#8195;例如：线程A在主存中年将变量age=0拉去到自己的工作内存中，然后做了age = 5，当然这个操作是在cpu的寄存器中进行的，然后写会高速缓存中，这时线程A的高速缓存还未执行同步主内存的操作，线程B又将age=0从主存拉取到了线程B的工作内存中，导致A线程已经更新但是B线程看不到的可见性问题； 原子性：线程切换导致原子性问题 ++count&#8195;&#8195;例如：当线程A从主内存中将共享变量Count加载到线程A的工作内存后，发生了线程切换，这个时候线程B也将共享变量Count从主内存加载到了线程B的工作内存，这时线程A和B的工作内存中count都是0，线程B执行了Count = Count + 1,然后写回到主内存，这时候线程切换完成，回到了线程A再次执行 Count = Count + 1,再将线程A工作内存计算过的count写回主内存，现在我们得到的主内存呢中Count值是1而不是2。 有序性：指令重排导致有序性问题；在这里讲一个例子，就是获取单例双重检查锁(double-checked locking)判断： 123456789101112131415161718192021222324/** * @Auther: lantao * @Date: 2019-03-28 14:32 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: TODO */public class Test1 &#123; private DoMain doMain; public DoMain getDoMain()&#123; if(doMain == null)&#123; synchronized (this.getClass())&#123; if(doMain == null)&#123; doMain = new DoMain(&quot;&quot;); &#125; return doMain; &#125; &#125;else&#123; return doMain; &#125; &#125;&#125; &#8195;&#8195;在上边的代码中在synchronized内和外都有一个if判断，判断doMain是否为null操作，有很多人对synchronized中的if null判断不理解，其实可以这样想，线程A和线程B都执行到了synchronized这里进行竞争锁，结果A得到锁，判断if null，结果还未实例化，继续进行实例化，然后return对象并释放锁，这时线程B获取到了锁进入if null判断，发现doMain已经被线程A实例化过了，直接返回实例即可，第二个if null的作用就在这里； 看上去上边的代码是完美的，但是new的操作上我们理解是： 创建内存M 在内存M上初始化doMain对象 将内存M的地址指向变量doMain 但是实际上优化后(指令重排)的执行路径可能是这样的： 创建内存M 将内存M的地址指向变量doMain 将内存M的地址指向变量doMain]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>可见性/原子性/有序性</tag>
        <tag>安全性/活跃性/性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized升级过程总结]]></title>
    <url>%2F2019%2F02%2F04%2F%E9%94%81%2FSynchronized%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等,下面我们就来介绍一下Synchronized的流程和使用方法； Synchronized的升级过程(Java SE 1.6中为了减少获得锁和释放锁带来的 性能消耗而引入的偏向锁和轻量级锁) Synchronized的升级顺序是 无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁，顺内不可逆。 偏向锁 当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁，以后该线程在进入和退出该同步代码块时不需要花费 CAS 操作来加锁和解锁，而只需简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁(当前线程的线程ID)，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果偏向锁标识是1，则使用 CAS 进行锁获取，偏向锁标识不是1，则尝试使用 CAS 将对象头的偏向锁指向当前线程，上述两种CAS获取锁的操作，如果CAS操作成功则获取到了偏向锁，失败则代表出现了锁竞争，需要锁撤销操作。 锁撤销偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等待拥有偏向锁的线程到达全局安全点（在这个时间点上没有字节码正在执行），会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁的对象的对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行(判断是否需要持有锁)，遍历偏向对象的锁记录，查看使用情况，如果还需要持有偏向锁，则偏向锁升级为轻量级锁，如果不需要持有偏向锁了，则将锁对象恢复成无锁状态，最后唤醒暂停的线程。 轻量级锁线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，自旋有一定次数，如果超过设置自旋的次数则升级到重量级锁，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。 轻量级锁解锁轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 例如：T1线程持有锁，T2线程自旋，但是T2线程自旋最大次数已经过了，则自旋失败，进行锁升级到重量级锁，T2线程阻塞，这时T1执行完了同步代码块，进行轻量级锁解锁，但是这时Mark Word中的标志位已经从原来的00(偏向锁)变成了10(中练级锁)，解锁会CAS失败，T1会进行解锁(释放监视器，释放锁)，并唤醒线程T2. 重量级锁Synchronized是非公平锁,Synchronized在线程进入阻塞队列时，等待的线程会先尝试获取锁，如果获取不到就进入阻塞队列，这明显对于已经进入队列的线程是不公平的。 优缺点 锁 优点 缺点 场景 偏向锁 加解锁不需要过多的资源消耗，和非同步方法的相比仅仅是纳秒的差距 如果存在所竞争，会有额外的锁撤销操作 适用于只有一个线程访问的场景 轻量级锁 竞争线程不会阻塞，会自旋，减少了上线文切换。 如果始终得不到锁，会消耗cpu资源 追求响应时间，同步代码块多为计算，执行快的场景 重量级锁 没啥优点 线程阻塞响应时间慢 同步代码块执行时间较长的场景使用 流程图 Synchronized 方法1: Synchronized 是java的内置锁，也是排它锁和非公平锁，排它锁也就是当前线程获取锁后，其他线程都会阻塞挂起 ，非公平锁是在线程后去锁的时候会先尝试后去锁，获取不到在进行阻塞。 2: Synchronized 是如何保证 ‘原子性’ 的？是因为进入 Synchronized 块的内存语义是把 Synchronized 块内使用的 ‘工作内存清除’， 这样在使用共享变量时就会直接存主内存中获取并复制到工作你内存中，在退出 Synchronized 语句块时 会把 工作内存中计算过的 ‘共享变量’ 更新到主内存中。 3: 获取到 Synchronized 锁 ，都是 ‘对象锁’而非’代码块锁’ (锁的都是对象或类，而不是某个方法)，因此 Synchronized 是具有可重入性，在获取到该对象锁后可以不用再次获取该对象其他方法的锁，直接进入。 4: 如果是 Synchronized 用在 static 上， 就代表是类锁(.class)，无论创建多少个对象都不可行； 区别wait和sleep区别在于wait会释放锁， 但是sleep不会释放锁 ，sleep会导致线程阻塞挂起。 wait/wait(timeout)/notify/notifyAll 方法仅可以在获取到锁后才可以使用。 解释wait： 线程等待。 wait(time)： 线程等待，如果时间超过了设置的time，则继续执行。 notify： 随机唤醒一个等待的线程。 notifyAll： 唤醒全部等待线程。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @Auther: concurrenncy * @Date: 2019-03-25 16:43 * @Company: 随行付支付有限公司 * @maill: lan_tao@suixingpay.com * @Description: wait 和 sleep 区别在于 wait会释放锁， 但是 sleep 不会 ，sleep会导致线程阻塞挂起 */ public class WaitAndNotifyTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; // 创建线程 thread1 Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " begin wait..."); synchronized (obj) &#123; obj.wait(); &#125; System.out.println(Thread.currentThread().getName() + " end wait..."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "thread1"); // 创建线程 thread2 Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " begin wait..."); synchronized (obj) &#123; obj.wait(); &#125; System.out.println(Thread.currentThread().getName() + " end wait..."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "thread2"); // 启动 thread1.start(); thread2.start(); try &#123; // 睡眠一秒 Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常 synchronized (obj) &#123; // 唤醒 使用 obj 调用 wait 方法的其中一个线程 (随机) obj.notify(); // 唤醒 使用呢 obj 调用 wait 方法的所有线程 obj.notifyAll(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>偏向锁/轻量级锁/重量级锁</tag>
        <tag>synchronized使用</tag>
      </tags>
  </entry>
</search>
