<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七英里的旅行</title>
  
  <subtitle>最怕一生碌碌无为，还说平凡难得可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lantaoblog.site/"/>
  <updated>2019-08-14T07:40:35.748Z</updated>
  <id>https://www.lantaoblog.site/</id>
  
  <author>
    <name>兰涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring源码之Aop</title>
    <link href="https://www.lantaoblog.site/2019/08/14/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring%E6%BA%90%E7%A0%81%E4%B9%8BAop/"/>
    <id>https://www.lantaoblog.site/2019/08/14/Spring源码系列/Spring源码之Aop/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-14T07:40:35.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Spring的<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签，了解spring是如何实现扫描注解进行aop的，主要实现是在 AspectJAutoProxyBeanDefinitionParser的parser方法中，另外这里</p><a id="more"></a><p>还需要了解一下NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 的关系，如果不清楚的可以看一下<strong>Spring源码之ApplicationContext</strong>中的解释。</p><h2 id="1-Jdk动态代理和CGLIB代理"><a href="#1-Jdk动态代理和CGLIB代理" class="headerlink" title="1 Jdk动态代理和CGLIB代理"></a>1 Jdk动态代理和CGLIB代理</h2><p>​        在讲述aop源码之前，需要先了解一下 <strong>Jdk</strong> 动态代理和 <strong>CGLIB</strong> 代理的区别和使用。</p><ul><li><h3 id="Jdk动态代理"><a href="#Jdk动态代理" class="headerlink" title="Jdk动态代理"></a><strong>Jdk动态代理</strong></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>Jdk动态代理需要目标类至少实现一个接口，在运行时期生成代理类。</p></li><li><h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a><strong>CGLIB代理</strong></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>CGLIB代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但CGLIB会继承目标对象，需要重写方法，所以目标对象不能为<strong>final</strong>类。</p></li></ul><h2 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2 示例代码"></a>2 示例代码</h2><h3 id="2-1-AspetJTest注解"><a href="#2-1-AspetJTest注解" class="headerlink" title="2.1 AspetJTest注解"></a>2.1 AspetJTest注解</h3><p>示例是基于注解形式，AspetJTest类为注解类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AspetJTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Aop配置类"><a href="#2-2-Aop配置类" class="headerlink" title="2.2 Aop配置类"></a>2.2 Aop配置类</h3><p>Config为Aop的配置类，Pointcut(切点)配置为AspetJTest注解，则所有使用@AspetJTest注解的方法都会被代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Pointcut</span>(<span class="string">"@annotation(AspetJTest)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">Around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入Around方法"</span>);</span><br><span class="line">      Object proceed = point.proceed();</span><br><span class="line">      System.out.println(<span class="string">"退出Around方法"</span>);</span><br><span class="line">      <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入after方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"serviceAspect()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入before方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-注解使用类"><a href="#2-3-注解使用类" class="headerlink" title="2.3 注解使用类"></a>2.3 注解使用类</h3><p>TestService真正的业务类，例如输入插入/删除等，aop代理实现事物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 13:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@aspetJTest</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"进入了printInfo方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-测试类"><a href="#2-4-测试类" class="headerlink" title="2.4 测试类"></a>2.4 测试类</h3><p>TestAopMain就是测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-09 14:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAopMain</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-bean-aop.xml"</span>);</span><br><span class="line">      TestService bean = classPathXmlApplicationContext.getBean(TestService.class);</span><br><span class="line">      bean.printInfo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Aop-xml配置类"><a href="#2-5-Aop-xml配置类" class="headerlink" title="2.5 Aop xml配置类"></a>2.5 Aop xml配置类</h3><p>Xml配置类，在其中有<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签，使Aop生效，<a href="context:component-scan/" target="_blank" rel="noopener">context:component-scan/</a>开启注解扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller，@Component和@Repository 的注解的类进行扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"lantao.aop"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 只扫描 base-package 的 controller 注解 还有对应的 exclude-filter 标签 排除 ； use-default-filters="false" 和 include-filter 一起使用 和 exclude-filter一起回抛异常--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Component"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-执行结果"><a href="#2-6-执行结果" class="headerlink" title="2.6 执行结果"></a>2.6 执行结果</h3><p>以上代码的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入Around方法</span><br><span class="line">进入before方法</span><br><span class="line">进入了printInfo方法</span><br><span class="line">退出Around方法</span><br><span class="line">进入after方法</span><br></pre></td></tr></table></figure><p>在执行TestAopMain类中的main方法时，发现getBean方法返回的并不是目标类，而是目标类的<strong>代理类</strong></p><p><img src="/Users/lantao/Downloads/1.jpg" alt></p><h2 id="3-XMl标签解析源码讲解"><a href="#3-XMl标签解析源码讲解" class="headerlink" title="3 XMl标签解析源码讲解"></a>3 XMl标签解析源码讲解</h2><h3 id="3-1-解析Aop配置xml"><a href="#3-1-解析Aop配置xml" class="headerlink" title="3.1 解析Aop配置xml"></a>3.1 解析Aop配置xml</h3><p>这里直接从<strong>DefaultBeanDefinitionDocumentReader</strong>类的<strong>doRegisterBeanDefinitions</strong>方法开始讲解，因前边都是xml解析的代码，已经在<strong>Spring源码之XmlBeanFactory</strong>中讲过了，其中<strong>parseBeanDefinitions</strong>方法是做标签解析使用的</p><p><strong>DefaultBeanDefinitionDocumentReader . parseBeanDefinitions方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span></span>&#123;</span><br><span class="line">   <span class="comment">//验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">//对默认标签处理</span></span><br><span class="line">               <span class="comment">// 这里只处理 nade namespace 为 http://www.springframework.org/schema/beans 的标签</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//对自定义标签处理 非namespace 为 http://www.springframework.org/schema/beans 的标签 ，会解析 &lt;context:component-scan base-package="lantao.scan"/&gt; 或者自定义 dubbo</span></span><br><span class="line">               <span class="comment">// 或者 aop</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//对自定义标签处理</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接关注<strong>parseCustomElement</strong>方法，<strong>parseDefaultElement</strong>方法处理的是bean标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取node的 NameSpaceURI</span></span><br><span class="line">   String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">   <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析自定义标签 需要在 Meta-inf 文件加 增加 spring.handlers 文件 例如：http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span></span><br><span class="line">   <span class="comment">// 根据指定的 NameSpaceURI 获取 NamespaceHandler  handler可以参考spring.handlers文件</span></span><br><span class="line">   <span class="comment">// abstract NamespaceHandlerSupport 实现了 NamespaceHandler 接口，继而实现了 NamespaceHandler 的两个个方法（parser，docreate），自定义handler 需要实现 NamespaceHandlerSupport 类</span></span><br><span class="line">   <span class="comment">// 进行 NamespaceHandler 类的 init 方法的 实现， 主要是做注册 BeanDefinitionParser（ registerBeanDefinitionParser ） ， 需要自定义解析类 继承 BeanDefinitionParser 类</span></span><br><span class="line">   NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析操作</span></span><br><span class="line">   <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要的工作就是机械<strong>NamespaceHandler</strong>,这里通过<strong>NamespaceHandlerResolver的resolve方法</strong>来解析各种<strong>NamespaceHandler</strong>,<strong>最后进行调用解析类的parse方法进行解析</strong>，接下来看一下resolve方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里获取的是所有注册到 handlerMappings 中的  NamespaceHandler ，</span></span><br><span class="line">   <span class="comment">// 就是 resource/META-INF/spring.handler 中的  key就是namespaceUri ，</span></span><br><span class="line">   <span class="comment">// 这些类都继承了 NamespaceHandlerSupport 实现了init方法 在init方法中进行 BeanDefinitionParse 的注册</span></span><br><span class="line">   Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">   <span class="comment">// 通过 namespaceUri 在 handlerMappings 中获取对应的处理器或者 className 如果是初始化过的就直接返回，反之进行类初始化工作</span></span><br><span class="line">   Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">   <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">      <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      String className = (String) handlerOrClassName;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">         <span class="comment">// 判断实例化的类的超类或者超级接口 是否是 NamespaceHandler</span></span><br><span class="line">         <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line">                  <span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">         <span class="comment">// 注册 自定义标签所对应的 解析策略类  解析策略类都继承了 BeanDefinitionParser ，比如 ComponentScanBeanDefinitionParser</span></span><br><span class="line">         namespaceHandler.init();</span><br><span class="line">         <span class="comment">// 放入缓存中</span></span><br><span class="line">         handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">         <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Could not find NamespaceHandler class ["</span> + className +</span><br><span class="line">               <span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Unresolvable class definition for NamespaceHandler class ["</span> +</span><br><span class="line">               className + <span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>resolve方法</strong>中一共做了<strong>两件事情</strong></p><p>1: 调用<strong>getHandlerMappings</strong>方法解析<strong>resources 中的 META-INF/spring.handlers</strong>文件，读取<strong>各种处理类</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.handlers:</span><br><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>2：进行<strong>处理类的实例化</strong>操作，然后调用<strong>处理类</strong>的<strong>init</strong>方法，<strong>进行解析类(Parser)的注册</strong>，并将<strong>实例化的处理类进行缓存处理</strong>，以备下次使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>resolve</strong>方法理解后在回到<strong>主方法(parseDefaultElement)</strong>中,在实例化和解析操作后，调用了<strong>处理类的parse</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 在 NamespaceHandlerSupport 中的 parser 集合中获取 BeanDefinitionParser 的实现类 进行 parser</span></span><br><span class="line">   BeanDefinitionParser parser = findParserForElement(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> (parser != <span class="keyword">null</span> ? parser.parse(element, parserContext) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>findParserForElement</strong>方法中通过<strong>标签(aspectj-autoproxy)</strong>进行获取<strong>对应的处理类(AspectJAutoProxyBeanDefinitionParser)</strong>，<strong>处理类的注册在实例化处理类后调用init方法已经完成，</strong> 接下来看一下 解析类的 <strong>parse</strong> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">  <span class="comment">// 扩展BeanDefinition 处理 子节点 &lt;aop:include/&gt;</span></span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册 AnnotationAwareAspectJAutoProxyCreator"></a>注册 AnnotationAwareAspectJAutoProxyCreator</h3><p>在解析<strong>(parse)</strong>方法中,首先是注册了<strong>AnnotationAwareAspectJAutoProxyCreator</strong>类，这个类是处理注解拦截的代理类，然后又扩展了刚刚注册的<strong>AnnotationAwareAspectJAutoProxyCreator</strong>，对xml中<a href="aop:aspectj-autoproxy" target="_blank" rel="noopener">aop:aspectj-autoproxy</a>标签的子节点<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>进行了处理。</p><p>首先看一下注册AnnotationAwareAspectJAutoProxyCreator的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">   BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">   <span class="comment">// 处理 proxy-target-class 和  expose-proxy属性</span></span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">   <span class="comment">// 注册 BeanComponentDefinition</span></span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分为三个步骤</p><p>1：通过调用<strong>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</strong>方法进行注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>类。</p><p>2：处理<strong>aop:aspectj-autoproxy</strong>标签的 <strong>proxy-target-class</strong> 和 <strong>expose-proxy</strong> 属性。</p><p>3：注册 <strong>BeanComponentDefinition</strong> ，就是对 <strong>AnnotationAwareAspectJAutoProxyCreator</strong> 的封装。具体作用后续补上</p><p>先来看第一步注册的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">      BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">      <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">         <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">         <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">         <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">            apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">   beanDefinition.setSource(source);</span><br><span class="line">   beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">   <span class="comment">// 定义角色，完全内部使用</span></span><br><span class="line">   beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">   registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">   <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就没什么好说的，先判断一下是否已经注册，如果已经注册，则<strong>判断优先级</strong>，如果已注册优先级高则直接结束，反之直接创建<strong>RootBeanDefinition</strong>，通过调用<strong>DefaultListableBeanFactory的registerBeanDefinition方法进行bean注册</strong>。</p><p>优先级判断代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="comment">// Set up the escalation list...</span></span><br><span class="line">   APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">   APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">   APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPriorityForClass</span><span class="params">(@Nullable String className)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; APC_PRIORITY_LIST.size(); i++) &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = APC_PRIORITY_LIST.get(i);</span><br><span class="line">      <span class="keyword">if</span> (clazz.getName().equals(className)) &#123;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">         <span class="string">"Class name ["</span> + className + <span class="string">"] is not a known auto-proxy creator class"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册说完了继续看一下对 <strong>proxy-target-class</strong> 和 <strong>expose-proxy</strong> 属性的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, @Nullable Element sourceElement)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 对标签 proxy-target-class 的处理，使用方法 &lt;aop:config proxy-target-class = "true"&gt; 或 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 使用</span></span><br><span class="line">      <span class="comment">// 其作用是 强制使用 CGLIB 代理，设置&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;  ，或需要使用CGLIB 和 @Aspectj自动代理支持 属性 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</span></span><br><span class="line">      <span class="comment">// JDK动态代理需要至少实现一个借口  CGLIB 不需要实现接口</span></span><br><span class="line">      <span class="keyword">boolean</span> proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">      <span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">         AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对 expose-proxy 的处理 其作用是实现 目标对象内部方法调用可实现切面的增强</span></span><br><span class="line">      <span class="comment">// 例如 例如 A类中 c方法 调用 A类中的 d方法是无法实时切面增强的，需要设置 &lt;aop:aspectj-autoproxy expose-proxy="true"/&gt; 例如 d 方法 有 @Transaction 注解则失效</span></span><br><span class="line">         <span class="keyword">boolean</span> exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">      <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">         AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>proxy-target-class</strong>属性的作用是强制使用 CGLIB 代理。</p><p><strong>expose-proxy</strong>属性的作用是<strong>目标对象内部方法调用可实现切面的增强</strong>,例如Test类中的A，B方法，A调用B方法进行数据库save操作，B方法上有<strong>@Transactional</strong>注解，如果A直接调用B方法则事物是不起作用的，需要设置<strong>expose-proxy=true</strong>，然后使用 <strong>((A)AopContext.currentProxy()).b()</strong> 调用方式。</p><p>注册整体完成后，看一下主方法的<strong>extendBeanDefinition</strong>方法，扩展BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendBeanDefinition</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   BeanDefinition beanDef =</span><br><span class="line">      parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">   <span class="keyword">if</span> (element.hasChildNodes()) &#123;</span><br><span class="line">      addIncludePatterns(element, parserContext, beanDef);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIncludePatterns</span><span class="params">(Element element, ParserContext parserContext, BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line">   ManagedList&lt;TypedStringValue&gt; includePatterns = <span class="keyword">new</span> ManagedList&lt;&gt;();</span><br><span class="line">   NodeList childNodes = element.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">      Node node = childNodes.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">         Element includeElement = (Element) node;</span><br><span class="line">         TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(includeElement.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">         valueHolder.setSource(parserContext.extractSource(includeElement));</span><br><span class="line">         includePatterns.add(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!includePatterns.isEmpty()) &#123;</span><br><span class="line">      includePatterns.setSource(parserContext.extractSource(element));</span><br><span class="line">      beanDef.getPropertyValues().add(<span class="string">"includePatterns"</span>, includePatterns);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extendBeanDefinition</strong>方法主要是对注册的<strong>AnnotationAwareAspectJAutoProxyCreator</strong>就行扩充，如果<strong>aop:aspectj-autoproxy</strong>标签还有子标签，也就是<strong><a href="aop:include/" target="_blank" rel="noopener">aop:include/</a></strong>标签，则会作getPropertyValues.add的操作，这里的<strong><a href="aop:include/" target="_blank" rel="noopener">aop:include/</a></strong>标签如果存在对于解析@Aspect标注的类时有一个match的动作，这里的内容会在<strong>buildAspectJAdvisors</strong>方法中详细讲解。 好了到这里整个Xml的解析注册就完成了，接下来看一下具体的实现。</p><h2 id="4-SpringBoot-自动配置Aop"><a href="#4-SpringBoot-自动配置Aop" class="headerlink" title="4 SpringBoot 自动配置Aop"></a>4 SpringBoot 自动配置Aop</h2><h2 id="5-Aop实现源码分析"><a href="#5-Aop实现源码分析" class="headerlink" title="5 Aop实现源码分析"></a>5 Aop实现源码分析</h2><h3 id="5-1-术语定义"><a href="#5-1-术语定义" class="headerlink" title="5.1 术语定义"></a>5.1 术语定义</h3><ol><li>ClassFilter：类过滤器</li><li>Advisor：通知器</li><li>targetClass：目标类，或称被代理的原始类</li><li>Advice：通知，或称拦截器，也就是要增强的代码逻辑</li><li>MethodMatcher：方法匹配器</li><li>Pointcut：切点，由<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>组成</li></ol><p><code>ClassFilter</code>用于约束一个<code>Advisor(通知器)</code>，与指定的<code>targetClass</code>是否匹配,只有匹配的前提下,<code>Advisor</code>才能使用其内部持有的<code>Advice(增强器)</code>对<code>targetClass</code>进行增强。</p><p>​        <strong>Advisor</strong>分两大类：<strong>IntroductionAdvisor</strong>（引介通知器）和<strong>PointcutAdvisor</strong>（切点通知器）。两类<strong>Advisor</strong>都是为了增强<strong>targetClass</strong>，但是作用不一样。<strong>IntroductionAdvisor</strong>主要为了给<strong>targetClass</strong>追加接口（或者说追加更多的方法），这种增强属于<code>类级别</code>的增强；而<strong>PointcutAdvisor</strong>主要为了拦截方法，这种增强属于<code>方法级别</code>的增强。</p><p>​        正是由于两类Advisor的增强级别不同，而导致了对<strong>ClassFilter</strong>的使用方式不同。<strong>IntroductionAdvisor</strong>进行类级别增强，因此只需要直接持有<strong>ClassFilter</strong>即可；而<strong>PointcutAdvisor</strong>进行方法级别增强，因此需要同时使用<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>（方法匹配器）。PointcutAdvisor内部持有一个<strong>Pointcut</strong>，而<strong>Pointcut就是由ClassFilter和MethodMatcher组成的</strong>。</p><h3 id="5-2-AnnotationAwareAspectJAutoProxyCreator类解析"><a href="#5-2-AnnotationAwareAspectJAutoProxyCreator类解析" class="headerlink" title="5.2 AnnotationAwareAspectJAutoProxyCreator类解析"></a>5.2 AnnotationAwareAspectJAutoProxyCreator类解析</h3><p>​        在上面的xml解析<strong>aop:aspectj-autoproxy</strong>标签时，一直都在说注册<strong>AnnotationAwareAspectJAutoProxyCreator</strong>，其实它是继承了<strong>InstantiationAwareBeanPostProcessor -&gt; BeanPostProcessor</strong>的，继承了 <strong>InstantiationAwareBeanPostProcessor</strong> 会在<code>实例化之前执行</code><strong>postProcessBeforeInstantiation</strong>和<strong>postProcessAfterInstantiation</strong>方法，但同时它也<code>间接性</code>继承了<strong>BeanPostProcessor</strong>，也会在<code>初始化前后执行</code> <strong>postProcessBeforeInstantiation</strong> 和 <strong>postProcessAfterInitialization</strong> 方法，在<strong>createBean</strong>方法中有这么一方法<strong>resolveBeforeInstantiation</strong>，它就是在<code>实例化</code>之前执行的<strong>InstantiationAwareBeanPostProcessor</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">************</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">// 给BeanPostProcessors一个返回代理而不是目标bean实例的机会</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">**********</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-postProcessBeforeInstantiation方法解析"><a href="#5-2-1-postProcessBeforeInstantiation方法解析" class="headerlink" title="5.2.1 postProcessBeforeInstantiation方法解析"></a>5.2.1 postProcessBeforeInstantiation方法解析</h4><p>​        创建代理的真正方法就是<strong>AbstractAutoProxyCreator.postProcessAfterInitialization</strong>方法或 <strong>postProcessBeforeInstantiation</strong>方法。<strong>AbstractAutoProxyCreator</strong> 是 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>的超类。下面先看一下 <strong>AbstractAutoProxyCreator.postProcessBeforeInstantiation</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断beanName是否为空 和 targetSoucedBeans是否包含beanName</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种</span></span><br><span class="line"><span class="comment">// shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor所属的bean和入参bean是否是同一个，如果是则不用增强反之可以，</span></span><br><span class="line"><span class="comment">// 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有自定义的targetSouce 在这里就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化</span></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around 等</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据增强器创建代理</span></span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>postProcessBeforeInstantiation</code>方法主要做了一下几件事情：</p><p>1: 判断<strong>beanName</strong>是否为空 和 <strong>targetSoucedBeans</strong>是否包含<strong>beanName</strong>。</p><p>2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 <strong>shouldSkip</strong> ，这里通过调用子类 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> 的 <strong>shouldSkip</strong> 方法，通过获取全部的<strong>Advisor</strong>，来判断<strong>Advisor</strong>所属的<strong>bean</strong>和入参<strong>bean</strong>是否是同一个，如果是<strong>(如果是则就是代表该bean是配置类)</strong>则不可以增强反之可以，然后会调用 <strong>super.shouldSkip</strong> 排除尾部是 .ORIGINA 结尾的<strong>bean</strong>。</p><p>3: 获取自定义的TargetSouce ,如果存在就直接创建代理，不需要等到实例化的时候在创建，避免不必要的bean创建实例化。</p><p>4: 如果存在自定义的TargetSouce，则获取该bean可用的增强器 就是循环扫描配置类 ， 扫出所有的 before alter around ，找到符合该bean的增强器。</p><p>5: 根据查询出来的增强器创建代理并返回。</p><p>上述是对存在<strong>TargetSource</strong>情况的描述，下面我们看一下不存在的情况</p><h4 id="5-2-2-postProcessAfterInitialization方法解析"><a href="#5-2-2-postProcessAfterInitialization方法解析" class="headerlink" title="5.2.2 postProcessAfterInitialization方法解析"></a>5.2.2 postProcessAfterInitialization方法解析</h4><p>接下来看<strong>AbstractAutoProxyCreator</strong>类中的<strong>postProcessAfterInitialization</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">      <span class="comment">//防止 bean 多次被增强。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">        <span class="comment">// 如果需要 则创建代理</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 判断是否是 基础配置类或需要跳过的类。如果是则不增强 在下边的方法中会put</span></span><br><span class="line">   <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// isInfrastructureClass:是否是基础架构类 就是是否是 aop配置类， 如果是 则不可代理这种</span></span><br><span class="line"><span class="comment">// shouldSkip 这里通过调用子类 AspectJAwareAdvisorAutoProxyCreator 的 shouldSkip 方法，通过获取全部的Advisor，来判断Advisor 所属的 bean 和入参 bean 是否是同一个，如果是则不用增强反之可以，</span></span><br><span class="line"><span class="comment">// 然后会调用 super.shouldSkip 排除 bean 名称 尾部是 .ORIGINA 结尾的bean</span></span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">  <span class="comment">// 获取该bean的增强器，如果有</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果增强器不是空 则创建代理</span></span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">     <span class="comment">// 创建代理并返回</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">     <span class="comment">// 增加缓存</span></span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加缓存 如果不符合则话put，在上边的判断直接返回</span></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>来解析wrapIfNecessary方法都做了什么</strong>：</p><p>1: 判断是否是 基础配置类或需要跳过的类。</p><p>2: 判断是否是基础架构类，就是是否是aop配置类， 如果是则不可代理这种，直接返回，还会在判断 <strong>shouldSkip</strong> ，这里通过调用子类 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> 的 <strong>shouldSkip</strong> 方法，通过获取全部的<strong>Advisor</strong>，来判断<strong>Advisor</strong>所属的<strong>bean</strong>和入参<strong>bean</strong>是否是同一个，如果是<strong>(如果是则就是代表该bean是配置类)</strong>则不可以增强反之可以，然后会调用 <strong>super.shouldSkip</strong> 排除尾部是 .ORIGINA 结尾的<strong>bean</strong>。</p><p>3: 获取该bean符合的增强器。</p><p>4: 创建代理并返回。</p><p>5: 增加缓存。</p><p>6: 增加缓存 如果存在可用的增强器，则将该bean设置为false，在1中会进行判断。</p><h5 id="获取增强器"><a href="#获取增强器" class="headerlink" title="获取增强器"></a>获取增强器</h5><h6 id="5-2-2-1-findCandidateAdvisors方法获取全部增强器"><a href="#5-2-2-1-findCandidateAdvisors方法获取全部增强器" class="headerlink" title="5.2.2.1 findCandidateAdvisors方法获取全部增强器"></a>5.2.2.1 findCandidateAdvisors方法获取全部增强器</h6><p>在<strong>wrapIfNecessary</strong>中最重要的方法就是<strong>getAdvicesAndAdvisorsForBean</strong>方法,通过<strong>getAdvicesAndAdvisorsForBean</strong>方法可以获取到适合<strong>bean增强器</strong>，接下来就看看它吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">      Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取该bean可以使用的增强器</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取所有增强器</span></span><br><span class="line">   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">   <span class="comment">// 获取当前bean可以使用的增强器</span></span><br><span class="line">   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   extendAdvisors(eligibleAdvisors);</span><br><span class="line">   <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">      eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>findEligibleAdvisors</strong>方法中首先获取了<strong>所有的增强器</strong>，然后获取适合bean的增强器，先看一下<strong>findCandidateAdvisors</strong>方法。</p><p>这里首先执行<code>子类</code>的<strong>findCandidateAdvisors</strong>方法，也就是<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line"><span class="comment">// 调用父类 findCandidateAdvisors 方法</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 处理注解形式的</span></span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里首先调用了<code>父类</code>的<strong>findCandidateAdvisors</strong>方法，也就是处理<strong>xml形式的Aop配置</strong>，然后执行了<strong>buildAspectJAdvisors</strong>方法，处理<strong>注解形式的aop配置</strong>。</p><p>先看一下父类的findCandidateAdvisors方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">   <span class="comment">// 获取缓存的 aop配置类名字，也就是 advisorBeanNames 数组中的信息</span></span><br><span class="line">   String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">   <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">      <span class="comment">// 如果 cachedAdvisorBeanNames 不存在则通过BeanFactoryUtils 获取，条件是 根据类型获取</span></span><br><span class="line">      advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不存在配置类则返回空数组</span></span><br><span class="line">   <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反之理解析</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">      <span class="comment">// 是否是有资格的bean</span></span><br><span class="line">      <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">         <span class="comment">// bean是否正在创建</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">               logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 存入到advisors中</span></span><br><span class="line">               advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">               Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">               <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                  BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                  String bceBeanName = bce.getBeanName();</span><br><span class="line">                  <span class="keyword">if</span> (bceBeanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Skipping advisor '"</span> + name +</span><br><span class="line">                              <span class="string">"' with dependency on currently created bean: "</span> + ex.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// Ignore: indicates a reference back to the bean we're trying to advise.</span></span><br><span class="line">                     <span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类方法中主要做了两件事：</p><p>1: 首先先从缓存<strong>cachedAdvisorBeanNames</strong>中获取，看是否存在<strong>Aop的配置类</strong>，如果不存在则通过<strong>BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false)</strong> 方法获取Aop的配置类，赋值到缓存中。</p><p>2：循环解析<strong>BeanName</strong>，通过<strong>beanFactory.isCurrentlyInCreation</strong>方法判断<strong>beanName</strong>是否是正在创建状态，如果不是则add到advisors中。</p><p>接下来看一下<strong>buildAspectJAdvisors</strong>方法，<strong>处理注解形式aop的配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">         <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 获取所有的bean</span></span><br><span class="line">            String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                  <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 循环所有的bean 来获取增强器</span></span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">               <span class="comment">// 判断bean是否有资格 默认所有bean都是有资格的 也可以配置 正则表达式 来判断哪些@aspet bean 是资格的</span></span><br><span class="line">               <span class="comment">// 检查给定的bean是否有资格进行自动代理。</span></span><br><span class="line">               <span class="comment">// 如果没有使用&lt;aop：include&gt;元素，则将 includePatterns null 并指定所有bean都是有资格的。如果“includePatterns”为非null，则需要和include中的name机型匹配。</span></span><br><span class="line">               <span class="comment">// 例如 @Aspect标注的类是 config     &lt;aop:include name="config1"/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效</span></span><br><span class="line">               <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">               <span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">               <span class="comment">// 获取bean的type</span></span><br><span class="line">               Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">               <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 判断是否是 aop配置bean 也就是是否被@Aspect注解标注</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                  aspectNames.add(beanName);</span><br><span class="line">                  <span class="comment">// 构建成AspectMetadata类</span></span><br><span class="line">                  AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 判断@Aspect注解中标注的是否为singleton类型，默认的切面类都是singleton类型</span></span><br><span class="line">                  <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                     MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                           <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                     <span class="comment">// 获取增强器</span></span><br><span class="line">                     List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                     <span class="comment">// put cache</span></span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// add advisors</span></span><br><span class="line">                     advisors.addAll(classAdvisors);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// Per target or per this.</span></span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                              <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                           <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                     <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                     advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">            <span class="keyword">return</span> advisors;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">      List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">      <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">         advisors.addAll(cachedAdvisors);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">         advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>buildAspectJAdvisors</strong>方法中，主要做了以下事情：</p><p>1: 首先获取所有的bean，通过BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)。</p><p>2: 判断bean是否有资格，默认所有bean都是有资格的，也可以通过配置<code>includePatterns</code>来判断哪些@aspet bean 是资格的。</p><p><strong>配置includePatterns：</strong></p><p>使用<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>标签，如果配置<a href="aop:include/" target="_blank" rel="noopener">aop:include/</a>元素，<strong>includePatterns</strong> 为非null，则需要和include中的name机型匹配。</p><p>如果不配置，则 includePatterns 为 null 并指定所有bean都是有资格的。</p><p> 例如 <strong>@Aspect</strong>标注的类是 <strong>config</strong>  &lt;aop:include name=”config1”/&gt; include的name是 config1 则不匹配， 则@Aspect标注的不生效。</p><p>3: 判断bean是否是Aop配置类，也就是是否被@Aspect标识。</p><p>4: <strong>通过this.advisorFactory.getAdvisors(factory)方法获取bean的增强器</strong>。</p><p>5: 返回全部增强器， 其中2 3 4 5都是for循环中操作。</p><p>在<strong>buildAspectJAdvisors</strong>方法中，最重要的就是<code>步骤4</code>，获取每一个<strong>bean</strong>的增强器，接着看<strong>this.advisorFactory.getAdvisors(factory)</strong> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注Bean 类型</span></span><br><span class="line">   Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注Bean 名字</span></span><br><span class="line">   String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">   <span class="comment">// 进行bean验证</span></span><br><span class="line">   validate(aspectClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">   <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">   MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">         <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获取除了 标记有 Pointcut 注解 的所有方法</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">      <span class="comment">// 获取每个方法上的 增强器</span></span><br><span class="line">      Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">      <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// add</span></span><br><span class="line">         advisors.add(advisor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">   <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">      Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">      advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find introduction fields.</span></span><br><span class="line">   <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">      Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">      <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         advisors.add(advisor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>getAdvisors</strong>方法中，通过<strong>getAdvisorMethods</strong>方法获取到了除了标记有 <strong>Pointcut</strong> 注解的其他所有方法，然后通过<strong>getAdvisor</strong>方法获取每个<strong>方法</strong>上的增强器。</p><p><strong>getAdvisorMethods方法源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 获取除了 标记有 Pointcut 注解 的所有方法</span></span><br><span class="line">   ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">      <span class="comment">// Exclude pointcuts</span></span><br><span class="line">      <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         methods.add(method);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   methods.sort(METHOD_COMPARATOR);</span><br><span class="line">   <span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getAdvisor方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证</span></span><br><span class="line">   validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取切点</span></span><br><span class="line">   AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">         candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实例化 增强器 这里使用的是PointcutAdvisor通知器，是方法级别的</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">         <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>getAdvisor</strong>方法中首先做了<strong>bean类型的验证</strong>，然后获取<strong>切点</strong>，最后开始<strong>实例化增强器, 这里实例化增强器使用的是PointcutAdvisor(通知器)，实际上InstantiationModelAwarePointcutAdvisorImpl是PointcutAdvisor的一个实现，也就是<code>方法级别</code>的通知器</strong>。</p><p><strong>先看beanType的验证，validate方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Class&lt;?&gt; aspectClass)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// If the parent has the annotation and isn't abstract it's an error</span></span><br><span class="line">  <span class="comment">// 是否存在@Aspect注解 和 abstract判断</span></span><br><span class="line">   <span class="keyword">if</span> (aspectClass.getSuperclass().getAnnotation(Aspect.class) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         !Modifier.isAbstract(aspectClass.getSuperclass().getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"["</span> + aspectClass.getName() + <span class="string">"] cannot extend concrete aspect ["</span> +</span><br><span class="line">            aspectClass.getSuperclass().getName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AjType&lt;?&gt; ajType = AjTypeSystem.getAjType(aspectClass);</span><br><span class="line">   <span class="comment">// 判断bean类型是否是 Aspect</span></span><br><span class="line">   <span class="keyword">if</span> (!ajType.isAspect()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NotAnAtAspectException(aspectClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 判断 bean 的 kind 是否是 PERCFLOW PERCFLOWBELOW  这两种在AOP中是不支持的</span></span><br><span class="line">   <span class="keyword">if</span> (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOW) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(aspectClass.getName() + <span class="string">" uses percflow instantiation model: "</span> +</span><br><span class="line">            <span class="string">"This is not supported in Spring AOP."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOWBELOW) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(aspectClass.getName() + <span class="string">" uses percflowbelow instantiation model: "</span> +</span><br><span class="line">            <span class="string">"This is not supported in Spring AOP."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来看获取增强器切点信息getPointcut方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 判断增强器类型</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构建 AspectJExpressionPointcut 类</span></span><br><span class="line">   AspectJExpressionPointcut ajexp =</span><br><span class="line">         <span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">   ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>findAspectJAnnotationOnMethod</strong>方法获取到方法的增强器类型，然后构建<strong>AspectJExpressionPointcut</strong>类，</p><p><strong>最后看一下实例化增强器的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">   <span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">   <span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">   <span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">   <span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">   <span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">   <span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">   <span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">   <span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">      <span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">      Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line">      <span class="comment">// If it's not a dynamic pointcut, it may be optimized out</span></span><br><span class="line">      <span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line">      <span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line">            <span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">      <span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// A singleton aspect.</span></span><br><span class="line">      <span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line">      <span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 实例化增强器</span></span><br><span class="line">      <span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要关注<strong>instantiateAdvice</strong>方法，实际上它的作用就是<strong>实例化Advice</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 @Aspect 标注de bean的类型</span></span><br><span class="line">   Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证bean</span></span><br><span class="line">   validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取方法上的增强器</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line">   <span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line">   <span class="comment">// 检查 bean 是否是被 @Aspect标注</span></span><br><span class="line">   <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">            <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">            candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实例化 增强器 根据不同的类型实例化不通过的增强器</span></span><br><span class="line">   <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> AtPointcut:</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAround:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtBefore:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfter:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">            springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">         springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">         AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">            springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">               <span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now to configure the advice...</span></span><br><span class="line">   springAdvice.setAspectName(aspectName);</span><br><span class="line">   springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">   String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">   &#125;</span><br><span class="line">   springAdvice.calculateArgumentBindings();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里还是会首先<strong>验证bean的类型</strong>，通过<strong>validate</strong>方法，接下来获取<strong>method</strong>的增强器，依然是通过<strong>findAspectJAnnotationOnMethod</strong>方法，紧接着判断<strong>bean是否被@Aspect标注</strong>，最后通过<strong>switch</strong>语法<strong>实例化增强器</strong> 并赋值一些参数配置。</p><p>到这里我们已经<strong>获取到了上下文中所有的可用增强器</strong>，到此<strong>findCandidateAdvisors</strong>方法的代码就全部都解析完成了，如果还没有明白整体流程，可以看一下下方<strong>时序图</strong>。</p><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/AOP%E8%8E%B7%E5%8F%96%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt></p><h6 id="5-2-2-2-findAdvisorsThatCanApply匹配适用bean的增强器"><a href="#5-2-2-2-findAdvisorsThatCanApply匹配适用bean的增强器" class="headerlink" title="5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器"></a>5.2.2.2 findAdvisorsThatCanApply匹配适用bean的增强器</h6><p>接下来根据解析到的<strong>增强器进行匹配</strong>，查找出适用于需要<strong>实例化bean的增强器</strong>，<strong>findAdvisorsThatCanApply</strong>方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置当前代理对象名称</span></span><br><span class="line">   ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 删除当前代理对象名称</span></span><br><span class="line">      ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="comment">// 在这里对 IntroductionAdvisor 类型的 Advisor(通知器)做会处理， 因为IntroductionAdvisor 是处理类拦截级别的</span></span><br><span class="line"><span class="comment">// 仅需要使用classFilter 即可</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="comment">// 对 处理过Advisor 的做 跳过处理</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里对 PointcutAdvisor 类型的 Advisor(通知器) 进行处理，因为 PointcutAdvisor 是方法级别的拦截，需要做 ClassFilter 和 MethodMatcher 判断</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line"><span class="comment">// 将匹配的增强器 add </span></span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回bean匹配的增强器</span></span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，可以看到，这里会对<strong>Advisor(通知器)</strong>做判断处理，分别是<strong>IntroductionAdvisor</strong>和<strong>PointcutAdvisor</strong>,他们都分别继承了<strong>Advisor</strong>, 在本文中是使用<strong>PointcutAdvisor</strong>的实现类<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>。</p><p><strong>区别</strong>：</p><p>IntroductionAdvisor: <strong>IntroductionAdvisor</strong>主要为了给<strong>targetClass</strong>追加接口（或者说追加更多的方法），这种增强属于<code>类级别</code>的增强,所以只需要做<strong>ClassFilter</strong>判断。</p><p>PointcutAdvisor: <strong>PointcutAdvisor</strong>主要为了拦截方法，这种增强属于<code>方法级别</code>的增强，则需要做<strong>ClassFilter</strong>和<strong>MethodMatcher</strong>的判断。</p><p>在findAdvisorsThatCanApply方法中最重要的就是canApply方法，直接看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">   <span class="comment">// 首先ClassFilter 进行匹配</span></span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">      <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">   <span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">      classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">   &#125;</span><br><span class="line">   classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 循环匹配每一个方法</span></span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         <span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">               methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在canApply方法中首先做了<strong>ClassFilter的匹配</strong>判断，接下来获取到Class的全部public方法，遍历所有方法，进行MethodMatcher的<strong>匹配操作</strong>，最终将匹配到的<strong>Advisor</strong>全部返回，到这里<strong>findAdvisorsThatCanApply</strong>方法就全部解析完成了。</p><h3 id="6-创建代理"><a href="#6-创建代理" class="headerlink" title="6 创建代理"></a>6 创建代理</h3><p>在 <strong>5.2</strong> 中已经将适配于bean的增强器(Advice)获取到了, 接下来继续分析主流程<strong>wrapIfNecessary</strong>方法中的<strong>createProxy</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params"> @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曝光 目标类</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 是否设置了 ProxyTargetClass 是否使用CGLIB</span></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="comment">// 如果没有设置 ProxyTargetClass 则需要判断 beanClass 是否应该使用CGLIB  反之使用 JDK动态代理</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置bean的增强器和拦截器</span></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line"><span class="comment">// 设置目标类</span></span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法其实就是封装了<strong>ProxyFactory</strong>，真是创建代理的还是<strong>ProxyFactory</strong>，接下来看一下getProxy接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// 判断使用 CGLIB 还是 JDK动态代理</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// isOptimize ： 是否优化处理</span></span><br><span class="line">   <span class="comment">// isProxyTargetClass 是否使用CGLIB代理</span></span><br><span class="line">   <span class="comment">// hasNoUserSuppliedProxyInterfaces 是否实现了接口</span></span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">      <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">               <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是实现了接口 则 使用JDK代理</span></span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用CGLIB代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用JDK代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是调用getProxy方法进行CGLIB或者JDK代理创建了，然后返回代理类。</p><p>CBLIB 和 JDK 代理源码后续文章讲解。</p><p>GItHub : <a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></p><p>参考：<a href="https://my.oschina.net/lixin91/blog/684918" target="_blank" rel="noopener">https://my.oschina.net/lixin91/blog/684918</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Spring的&lt;a href=&quot;aop:aspectj-autoproxy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aop:aspectj-autoproxy/&lt;/a&gt;标签，了解spring是如何实现扫描注解进行aop的，主要实现是在 AspectJAutoProxyBeanDefinitionParser的parser方法中，另外这里&lt;/p&gt;
    
    </summary>
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/categories/spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="Aop" scheme="https://www.lantaoblog.site/tags/Aop/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://www.lantaoblog.site/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84/"/>
    <id>https://www.lantaoblog.site/2019/06/21/数据结构学习笔记/数组/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-06-26T01:30:40.533Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构课程学习笔记。</p><a id="more"></a><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p><strong>数组</strong>（Array）是一种<strong>线性表数据结构</strong>。它用一组<strong>连续</strong>的<strong>内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>, 并且<strong>不支持动态扩容。</strong></p><ul><li><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h3><p>线性表就是数据排成一条线一样的数据结构，每个线性表最多只有前后两个方向，数组，链表丶队列丶栈等都是线性表数据结构。</p></li><li><h3 id="非线性表"><a href="#非线性表" class="headerlink" title="非线性表"></a><strong>非线性表</strong></h3><p>非线性表就是数据不规则，与线性表是相对立的，比如二叉树丶堆丶等，在非线性表中，数据之间并不是简单的前后关系。</p></li></ul><h2 id="数组随机访问"><a href="#数组随机访问" class="headerlink" title="数组随机访问"></a><strong>数组随机访问</strong></h2><ul><li><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a><strong>公式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address[i] = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p><strong>address[i] :</strong> 下标 i 的地址值。</p><p><strong>base_address：</strong> 数组的<strong>首地址</strong>。</p><p><strong>data_type_size：</strong> 数组中每个元素的大小，也就是数据类型大小(字节)，例如int是4个字节。</p></li></ul><h2 id="数组的增加和删除"><a href="#数组的增加和删除" class="headerlink" title="数组的增加和删除"></a><strong>数组的增加和删除</strong></h2><p><strong>数组</strong> (Array) 在<strong>增删查</strong>这三个动作中，查询是高效的，但是增和删是低效的，查询高效是因为<strong>数组支持随机访问</strong>，时间复杂度是 <strong>O(1)</strong> ,这里就不多赘述了，但是在<strong>增加</strong>和<strong>删除</strong>的动作中，因为会涉及<strong>数据搬移</strong>，所以时间复杂度是 <strong>O(n)</strong> ，下面来详细讲解。</p><ul><li><h4 id="低效的”插入”和”删除”"><a href="#低效的”插入”和”删除”" class="headerlink" title="低效的”插入”和”删除”"></a><strong>低效的”插入”和”删除”</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] info = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h4><p>数组 <strong>info</strong> 是一个<strong>一维数组</strong>，其内容是 <strong>33,44,66,77,88</strong> 现在需要在<strong>下标 2</strong> 的位置<strong>插入</strong> <strong>55</strong> ，将其变成<strong>33 44 55 66 77 88</strong>的数组，这其中涉及将下标 <strong>2</strong> 到下标 <strong>4</strong> 的之间进行数据进行搬移，完成后在下标 <strong>2</strong> 的位置插入 <strong>55</strong> , <strong>其复杂度是 O(n)， 但如果是在最后进行插入的话其复杂度是 O(1)</strong>。</p><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><p>还拿<strong>数组 info</strong> 来举例，数组删除前其内容是 <strong>33,44,00,55,66,77</strong> 现在进行删除操作，删除下标为 <strong>2</strong> 内容，这其中涉及<strong>将下标 3 到 5 的内容向前搬移</strong>，其操作的时间复杂度是 <strong>O(n)</strong> ，如果是是<strong>删除最后一位且后面没有内容</strong>，则其时间复杂度是<strong>O(1)</strong> 。</p><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt></p><p>因<strong>插入和删除操作</strong>会涉及到<strong>数据搬移</strong>,所以说他是<strong>低效</strong>的。</p></li></ul><h4 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存**"></a>CPU缓存**</h4><p>  Cpu缓存的<strong>最小单位</strong>是<strong>Cpu缓存行</strong>，一个缓存行大小通常是<strong>64字节</strong>(取决于CPU)，试想一下你正在遍历一个长度为 16 的 long 数组 data[16]，原始数据自然存在于主内存中，访问过程描述如下：</p><p>  1：访问 data[0]，CPU core 尝试访问 CPU Cache，未命中。</p><p>  2：尝试访问主内存，操作系统一次访问的单位是一个 Cache Line 的大小 — 64 字节，这意味着：既从主内存中获取3：到了 data[0] 的值，同时将 data[0] ~ data[7] 加入到了 CPU Cache 之中，</p><p>  4：访问 data[1]~data[7]，CPU core 尝试访问 CPU Cache，命中直接返回。</p><p>  5：访问 data[8]，CPU core 尝试访问 CPU Cache，未命中, 尝试访问主存，重复步骤2。</p><h4 id="测试数组和Cpu缓存行"><a href="#测试数组和Cpu缓存行" class="headerlink" title="测试数组和Cpu缓存行"></a><strong>测试数组和Cpu缓存行</strong></h4><p>  因Cpu缓存最小单位是<strong>缓存行(64字节)</strong>，我么来测试一下二维数组的<strong>横向遍历</strong>和<strong>纵向遍历</strong>的具体时间和性能。</p><p>  <strong>代码</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.com.array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-06-24 15:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 横向遍历</span></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                sum += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop Time 横向遍历："</span> + (System.currentTimeMillis() - l) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 纵向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j++) &#123;</span><br><span class="line">                sum += arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop Time 纵向遍历："</span> + (System.currentTimeMillis() - l) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">Loop Time 横向遍历：<span class="number">14</span>ms</span><br><span class="line">Loop Time 纵向遍历：<span class="number">83</span>ms</span><br></pre></td></tr></table></figure><p>  <strong>总结：</strong> 因<strong>横向遍历</strong>遍历的是<strong>行</strong>，然后在循环<strong>行的每一列</strong>，Cpu缓存会<strong>缓存64字节大小的缓存行</strong>，所以可以减少<strong>cpu和主存之间的交互</strong>，<strong>直接和高速缓存交互，提升性能</strong>，纵向遍历因每次循环都是不同的行，所以使缓存行没有作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构课程学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.lantaoblog.site/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Array" scheme="https://www.lantaoblog.site/tags/Array/"/>
    
      <category term="数据结构" scheme="https://www.lantaoblog.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>String#intern方法详解</title>
    <link href="https://www.lantaoblog.site/2019/06/19/java%E5%9F%BA%E7%A1%80/String%E7%9A%84intern%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.lantaoblog.site/2019/06/19/java基础/String的intern方法详解/</id>
    <published>2019-06-18T16:00:00.000Z</published>
    <updated>2019-06-20T02:58:26.168Z</updated>
    
    <content type="html"><![CDATA[<p>记录创建String的两种方式，”” 和 new String()区别，String intern方法的使用和常量池。</p><a id="more"></a><ul><li><h2 id="String的使用-Jdk1-8"><a href="#String的使用-Jdk1-8" class="headerlink" title="String的使用 (Jdk1.8)"></a>String的使用 (Jdk1.8)</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.com.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-15 13:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 "" 创建  会直接存储在 常量池中</span></span><br><span class="line">        String a = <span class="string">"lantao"</span>;</span><br><span class="line">        <span class="comment">// 使用 new String 创建， 会将zahngsan存储到常量池中，然后在Heap中创建对象指向b</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">// 使用 字符串连接符拼接 ，会直接存储 'wangwuzhaoliu' 字符串在常量池中</span></span><br><span class="line">        String c = <span class="string">"wangwu"</span> + <span class="string">"zhaoliu"</span>;</span><br><span class="line">        <span class="comment">// 使用字符串 "引用" 拼接 ，不执行 intern 方法，不会存放到常量池中，但是会将 --- 存入到常量池中</span></span><br><span class="line">        String d = a + <span class="string">"---"</span>;</span><br><span class="line">        <span class="comment">// 使用 new String 拼接 ，不执行 intern 方法，不会存放到常量池中，但是会将wang 和 jiu 两个字符串存到常量池中</span></span><br><span class="line">        String f = <span class="keyword">new</span> String(<span class="string">"wang"</span>) + <span class="string">"jiu"</span>;</span><br><span class="line">        <span class="comment">// 使用 new String 拼接 ，不执行 intern 方法，不会存放到常量池中， 但是会将 zhao 和 ba 两个字符串存入到常量池中</span></span><br><span class="line">        String g = <span class="keyword">new</span> String(<span class="string">"zhao"</span>) + <span class="keyword">new</span> String(<span class="string">"ba"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><strong>变量a：</strong> “lantao” 是<strong>字符串常量</strong>，在<strong>编译期就被确定</strong>了，先检查<strong>字符串常量池中是否含有”lantao”字符串</strong>,若没有则<strong>添加</strong>“lantao”到字符串常量池中，并且直接指向它。所以a直接指向<strong>字符串常量池</strong>的”lantao”,也就是变量a指向的地址是<strong>常量池中的 lantao</strong>。</li><li><strong>变量b：</strong>用new String() 创建的字符串不是常量，<strong>不能在编译期就确定</strong>，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间<strong>(Java Heap 中)</strong>，<strong>变量b的引用的地址在Java Heap中</strong>。 但是”zhangsan”字符串常量在编译期也会被加入到字符串常量池（如果常量池不存在的话）。</li><li><strong>变量c：</strong>“wangwu”和”zhaoliu”也都是<strong>字符串常量</strong>，当<strong>一个字符串</strong>由<strong>多个字符串常量</strong>连接而成时，它自己<strong>肯定也是字符串常量</strong>，在编译器会被编译器优化成”wangwuzhaoliu”，所以c也同样在编译期就被解析为一个字符串常量，并且c是常量池中”wangwuzhaoliu”的一个引用，<strong>所以变量c的引用地址在常量池中</strong>。</li><li><strong>变量d：</strong> JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即`(a+”—“)</li><li><strong>变量f：</strong> 变量f同样不能在编译期确定，<strong>但是”wang”和”jiu”这两个字符串常量会添加到字符串常量池中</strong>，并且在堆中创建String对象。（字符串常量池并不会存放”wangjiu”这个字符串,除非执行f.intern()方法）</li><li><strong>变量g：</strong> 同理变量f。</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/String%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg" alt></p><h3 id="String-拼接"><a href="#String-拼接" class="headerlink" title="String 拼接"></a>String 拼接</h3><ul><li><p><strong>字符串拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"lan"</span> + <span class="string">"tao"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lan 和 tao 都是<strong>字符串</strong>，都是在编译器<strong>可知的</strong>，编译器会将这行代码优化，<strong>当一个字符串是由多个可知的字符串(非引用字符串)连接组成</strong>，将会优化为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String a = <span class="string">"lantao"</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM会将字符串”lantao”放入到String常量池中。</p></li><li><p><strong>引用拼接：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"lan"</span>;</span><br><span class="line">      String b = a + <span class="string">"tao"</span>;</span><br><span class="line">      <span class="comment">// 上下含义相同</span></span><br><span class="line">      String c = <span class="string">"zhang"</span>;</span><br><span class="line">      String d = <span class="string">"san"</span>;</span><br><span class="line">      String f = c + d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Java编译器遇到<strong>字符串引用</strong> 或 <strong>字符串引用和可知字符串</strong>拼接的时候，会创建一个<code>StringBuilder</code>对象，后面的append()。</p><p>因为有字符串引用存在，而引用的值在程序编译期是无法确定的。<strong>另外 “lan”、”tao” 都会编译器添加到字符串常量池中（如果没有的话）</strong>，因为它们都是编译期确定的字符串常量，<strong>但是最后的”lantao”并不会添加到字符串常量池, 除非执行b.intern() 方法</strong></p></li><li><p><strong>final拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String a = <span class="string">"lan"</span>;</span><br><span class="line">     <span class="keyword">final</span> String b = <span class="string">"tao"</span>;</span><br><span class="line">      String c = a + b + <span class="string">"2019"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final拼接和以上两者的区别就是在前边增加了final修饰，<strong>用final修饰的字符串就是在编译期可知的</strong>，编译期就会将以上代码优化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"lantao2019"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里 final 拼接的效果是和字符串拼接是一致的。</strong></p></li></ul></li></ul><ul><li><h2 id="String-intern方法"><a href="#String-intern方法" class="headerlink" title="String#intern方法"></a>String#intern方法</h2><h3 id="intern方法详解"><a href="#intern方法详解" class="headerlink" title="intern方法详解"></a>intern方法详解</h3><p>String.intern()是一个Native(本地)方法，它的作用是如果<strong>字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用</strong>, <strong>否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回</strong>。 </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>注意：基本数据类型之间的 ==  是比较值，引用数据类型 == 比较的是地址值</strong></p><ul><li><h4 id="常量池中存在字符串"><a href="#常量池中存在字符串" class="headerlink" title="常量池中存在字符串"></a><strong>常量池中存在字符串</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 基本数据类型之间的 ==  是比较值，引用数据类型 == 比较的是地址值</span></span><br><span class="line">      <span class="comment">// 1：在Java Heap中创建对象 2：在字符串常量池中添加 zhangsan</span></span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"zhangsan"</span>);</span><br><span class="line">      <span class="comment">// 调用 intern 方法，因上一步中已经将zhangsan存入常量池中，这里直接返回常量池 zhangsan 的引用地址</span></span><br><span class="line">        String b = a.intern();</span><br><span class="line">      <span class="comment">// a 的地址在Java Heap中 ， b的地址在 常量池中 ，所以结果是flase</span></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">      <span class="comment">// 因为常量池中已经包含zhangsan，所以直接返回</span></span><br><span class="line">        String c = <span class="string">"zhangsan"</span>;</span><br><span class="line">        <span class="comment">// b c 的地址一致，所以是true</span></span><br><span class="line">        System.out.println(b == c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>1：在<strong>Java Heap</strong>中<strong>创建对象</strong>然后在<strong>字符串常量</strong>池中<strong>添加</strong> zhangsan。</p><p>2：调用 <strong>intern</strong> 方法，因上一步中已经将zhangsan存入常量池中，这里直接返回常量池 zhangsan 的引用地址。</p><p>3：因 a 的地址在Heap中，b的地址在字符串常量池中。</p><p>4：因为常量池中已经包含zhangsan，所以直接返回</p><p>5： b c 的地址一致，所以是true</p><p>地址可以使用System.identityHashCode(a)方法获取</p></li><li><h4 id="常量池中不存在字符串"><a href="#常量池中不存在字符串" class="headerlink" title="常量池中不存在字符串"></a><strong>常量池中不存在字符串</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1： 首先会在Heap中创建对象，然后在常量池中放入zhagnsan 和 wangwu ，但是并不会放入zhagnsanwangwu</span></span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"zhangsan"</span>) + <span class="string">"wangwu"</span>;</span><br><span class="line">      <span class="comment">// 2：调用 intern ，因为字符串常量池中没有”zhangsanwangwu”这种拼接后的字符串，所以将堆中String对象的引用地址添加到字符串常量池中。jdk1.7后常量池引入到了Heap中，所以可以直接存储引用</span></span><br><span class="line">        String b = a.intern();</span><br><span class="line">      <span class="comment">// 3：因为 a 的地址和 b的地址一致，锁以是true</span></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//4：因常量池中已经存在 zhangsanwangwu 了，所以直接返回引用就是 a 类型 a ==b 锁 a==b==c</span></span><br><span class="line">        String c = <span class="string">"zhangsanwangwu"</span>;</span><br><span class="line">        System.out.println(a == c); <span class="comment">// true</span></span><br><span class="line">      System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 5：首先会在Heap中创建对象，然后会在常量池中存储 zhang 和 san</span></span><br><span class="line">      String d = <span class="keyword">new</span> String(<span class="string">"zhang"</span>) + <span class="string">"san"</span>;</span><br><span class="line">      <span class="comment">// 6： 返回的是 常量池中的 地址，因在a变量时已经将 zhangsan 放入到了常量池中</span></span><br><span class="line">      String f = d.inter();</span><br><span class="line">      System.out.println(d = f); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>1：首先会在<strong>Heap中创建对象a，然后在</strong>常量池中放入zhagnsan 和 wangwu** ，但是<strong>并不会放入</strong>zhagnsanwangwu。</p><p>2：调用 intern ，因为字符串常量池中没有”zhangsanwangwu”这种拼接后的字符串，所以将堆中<strong>String对象的引用地址添加到字符串常量池中</strong>。jdk1.7后常量池引入到了Heap中，所以可以直接存储引用。</p><p>3：因为 a 的地址和 b的地址一致，所以是true。</p><p>4：因常量池中<strong>已经存在 zhangsanwangwu</strong> 了，所以<strong>直接返回引用就是 a 类型</strong>， a ==b 所以 a==b==c。</p><p>5：首先会在<strong>Heap中创建对象d</strong>，然后会在<strong>常量池中存储 zhang 和 san</strong>。</p><p>6：因在创建对象a时，已经将 “zhangsan”放入到了常量池，所以<strong>返回的是常量池中的zhangsan地址</strong>，对象d的地址在Heap中，f的地址在常量池中，并不是一个，所以false；</p></li></ul></li></ul><p>参考：<a href="https://blog.csdn.net/qian520ao/article/details/78966179" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78966179</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录创建String的两种方式，”” 和 new String()区别，String intern方法的使用和常量池。&lt;/p&gt;
    
    </summary>
    
      <category term="String" scheme="https://www.lantaoblog.site/categories/String/"/>
    
    
      <category term="String" scheme="https://www.lantaoblog.site/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>随笔记</title>
    <link href="https://www.lantaoblog.site/2019/06/18/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.lantaoblog.site/2019/06/18/随笔记/</id>
    <published>2019-06-17T16:00:00.000Z</published>
    <updated>2019-06-20T01:37:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>随笔记，记录一些工作中遇到的问题和解决方案。</p><a id="more"></a><ul><li><h2 id="BeanFactory-和-FactoryBean-区别"><a href="#BeanFactory-和-FactoryBean-区别" class="headerlink" title="BeanFactory 和 FactoryBean 区别"></a><strong>BeanFactory 和 FactoryBean 区别</strong></h2><p><strong>BeanFactory:</strong> 是 Ioc 的核心接口，一般是内部使用，外部使用的话用ApplicationContext，具体实现有XMLBeanFactory/ClassPathXMLApplicationContext，是用来管理bean的实例化，定位、配置应用程序中的对象及建立这些对象间的依赖以及bean的生命周期。</p><p><strong>FactoryBean:</strong> FactoryBean也是接口，实现此接口的类也是一种Bean。Spring中共有二种bean，一种是普通bean（就是上面说的BeanFactory管理的bean），另一种是实现FactoryBean接口的Bean。它更加灵活，可以根据自己的需求灵活配置bean</p></li><li><h2 id="RestTemplate-的实现方式"><a href="#RestTemplate-的实现方式" class="headerlink" title="RestTemplate 的实现方式"></a>RestTemplate 的实现方式</h2><p>RestTemplate其默认实现是HttpURLConnection（集成了URLConnection），这是JDK自带的REST客户端实现,还可以实现别的Http源，RestTemplate有三个构造方法：</p><ol><li>RestTemplate()</li><li>RestTemplate(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</li><li>RestTemplate(ClientHttpRequestFactory requestFactory)。</li></ol><p>我们主要看第三个，ClientHttpRequestFactory 接口的实现，如下图：</p><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E4%BB%A3%E7%A0%811.png" alt="image-20190604155627634"></p><p>图中列出了RestTemplate的几种REST Client的封装。其中最常用的有以下三种：SimpleClientHttpRequestFactory（封装URLConnection）<br>HttpComponentsClientHttpRequestFactory（封装HttpClient）<br>OkHttp3ClientHttpRequestFactory (封装OKHttp)</p><p>可在里边设置超时时间等信息；</p></li><li><h2 id="String是否可以做对象锁"><a href="#String是否可以做对象锁" class="headerlink" title="String是否可以做对象锁"></a>String是否可以做对象锁</h2></li><li><h2 id="String为什么要设计成不可变的"><a href="#String为什么要设计成不可变的" class="headerlink" title="String为什么要设计成不可变的"></a><strong>String为什么要设计成不可变的</strong></h2></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随笔记，记录一些工作中遇到的问题和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://www.lantaoblog.site/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://www.lantaoblog.site/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java线程生命周期和锁的简单使用</title>
    <link href="https://www.lantaoblog.site/2019/06/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.lantaoblog.site/2019/06/14/多线程/Java线程的生命周期和锁的使用/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-24T01:19:12.720Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了java线程的生命周期，Synchronized的几个方法简单的使用。</p><a id="more"></a><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ul><li><h4 id="初始状态-New"><a href="#初始状态-New" class="headerlink" title="初始状态(New)"></a><strong>初始状态(New)</strong></h4><p>New Thread之后，<br>&nbsp;</p></li><li><h4 id="就绪状态-Ready"><a href="#就绪状态-Ready" class="headerlink" title="就绪状态(Ready)"></a><strong>就绪状态(Ready)</strong></h4><p>表示获取到了Cpu的执行时间片，也就是cpu的执行权，等待开始执行。<br>&nbsp;</p></li><li><h4 id="运行状态-Runable"><a href="#运行状态-Runable" class="headerlink" title="运行状态(Runable)"></a><strong>运行状态(Runable)</strong></h4><p> 执行start之后，开始运行。<br>&nbsp;</p></li><li><h4 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a><strong>阻塞状态(Blocked)</strong></h4><p> 在进入synchronized的临界区或者Lock的临界区，等待获取监视器(monitor)锁，线程会进入同步队列(SynchronizedQueue)中。<br>&nbsp;</p></li><li><h4 id="等待状态-Waiting"><a href="#等待状态-Waiting" class="headerlink" title="等待状态:(Waiting)"></a><strong>等待状态:(Waiting)</strong></h4><p>在执行await(),wait(),jion(),LockSupport.park()方法进入等待状态;<br>&nbsp;</p></li><li><h4 id="等待超时状态"><a href="#等待超时状态" class="headerlink" title="等待超时状态"></a><strong>等待超时状态</strong></h4><p> 在执行Object.await(time), Object.wait(time), Object.sellp(time), LockSupport.parkUntil,lockSupport.parkNanos 进入等待超时状态。<br>&nbsp;</p></li><li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a><strong>终止状态</strong></h4><p>线程执行完毕或者执行了Thread.interrupt() / Thread.stop()，不建议使用的Thread.stop() 因为 Thread.stop是直接<strong>强行</strong>结束，<strong>不会释放资源</strong> ；</p></li><li><h4 id="配图"><a href="#配图" class="headerlink" title="配图"></a><strong>配图</strong></h4><p> <img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p></li></ul><h3 id="锁的几个简单方法"><a href="#锁的几个简单方法" class="headerlink" title="锁的几个简单方法"></a>锁的几个简单方法</h3><ul><li><h4 id="wait-和-notify-notifyAll"><a href="#wait-和-notify-notifyAll" class="headerlink" title="wait 和 notify/notifyAll"></a><strong>wait 和 notify/notifyAll</strong></h4><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h5><p><strong>wait：</strong> 将线程状态置位 <strong>‘等待状态’</strong>，进入等待队列等待。<br><strong>notify/notifyAll：</strong> notify是随机唤醒一个线程进入 <strong>‘同步队列’</strong>,notifyAll是唤醒全部被监视器锁wait的线程进入 ‘同步队列’，等待获取监视器锁后继续执行。</p><p><strong>提示：</strong>wait，notify/notifyAll都需要在获取到监视器所(monitor)后才可以进行操作。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程 thread1</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程 thread2</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠一秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面我们加上 obj.notify() 就会先输出 begin wait  然后sellp 10秒，执行obj.notify() 唤醒 thread1 线程 , 输出end wait</span></span><br><span class="line">        <span class="comment">// obj 上可能会存在wait 多个线程， notify唤醒是随机的，不一定能唤醒哪一个线程</span></span><br><span class="line">        <span class="comment">// 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的其中一个线程 (随机)</span></span><br><span class="line">            obj.notify();</span><br><span class="line">            <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的所有线程</span></span><br><span class="line">            obj.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">thread2   begin wait...</span><br><span class="line">thread1   begin wait...</span><br><span class="line">thread1   end wait...</span><br><span class="line">thread2   end wait...</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await,signal/signalAll"></a><strong>await,signal/signalAll</strong></h4><h5 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>await,signal/signalAll方法是Lock Condition的方法，语义和Object的wait，notify/notifyAll是完全相同的。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-15 14:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁  执行singal和notify的时候也需要在等待获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> Condition a = lock.newCondition();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Runnable runnable = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        a.await();</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"被唤醒了"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> +Thread.currentThread().getName() + <span class="string">"开始执行sinal"</span>);</span><br><span class="line">                        a.signalAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread1"</span>).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread2"</span>).start();</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">new</span> Thread(runnable1,<span class="string">"Thread3"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">Thread1</span><br><span class="line">Thread2</span><br><span class="line">线程Thread3开始执行sinal</span><br><span class="line">Thread1被唤醒了</span><br><span class="line">Thread2被唤醒了</span><br></pre></td></tr></table></figure></li><li><h4 id="Join-和-Join-time"><a href="#Join-和-Join-time" class="headerlink" title="Join 和 Join(time)"></a><strong>Join 和 Join(time)</strong></h4><h5 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>等待<strong>调用Join的线程</strong>执行完成后<strong>再继续执行</strong>,或者<strong>等待时间超过了超时时间继续执行</strong>；</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Join 核心是等待指定线程运行完后再继续运行  Join(time) 就是等待线程执行的一个超时时间 超过了就继续执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                            System.out.println(<span class="string">"正常完成"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                thread1.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行 jion 等待线程 thread1 执行完后再继续执行</span></span><br><span class="line">                thread1.join();</span><br><span class="line"><span class="comment">//        thread1.join(1000);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这样最终执行的顺序是 1 2 3  如果不增加 thread1.join() 结果可能是 312 也可能是 132</span></span><br><span class="line">                <span class="comment">// Join 核心是等待指定线程运行完后再继续运行</span></span><br><span class="line">                System.out.println(<span class="string">"3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">正常完成</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h4><h5 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>yeid 方法的核心是<strong>让出 cpu 时间片</strong> ，也就是<strong>cpu执行权</strong>，线程会直接进入<strong>就绪状态</strong>,线程调度器会从线程就绪队列里获取一个线程优先级最高的线程来执行,当然也有可能直接会去到刚刚让出cpu执行权的线程，继续执行yield 后续的代码。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-03-25 17:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead1"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread1"</span>);</span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead2"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread2"</span>);</span><br><span class="line">                Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> / <span class="number">5</span> == i) &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行 yield "</span>);</span><br><span class="line">                                Thread.yield();</span><br><span class="line">                                System.out.println(<span class="string">"trhead3"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread3"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行三个线程， 正常当运行到yield 是 就会让出cpu执行权，线程到 就绪状态，线程调度器会从 线程就绪队列里获取一个线程优先级最高的线程来执行，</span></span><br><span class="line">                <span class="comment">// 当然也有可能直接会去到刚刚让出cpu的线程，继续执行yield 后续的代码</span></span><br><span class="line">                thread1.start();</span><br><span class="line">                thread3.start();</span><br><span class="line">                thread2.start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">thread1   开始执行 yield</span><br><span class="line">thread2   开始执行 yield</span><br><span class="line">thread3   开始执行 yield</span><br><span class="line">        trhead2</span><br><span class="line">trhead1</span><br><span class="line">trhead3</span><br></pre></td></tr></table></figure></li><li><h4 id="interrupt-和-stop"><a href="#interrupt-和-stop" class="headerlink" title="interrupt 和 stop"></a><strong>interrupt 和 stop</strong></h4><h5 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a><strong>解释</strong></h5><p>interrupt和stop都代表中断线程，区别是 interrupt 会释放资源而stop不会，interrupt也不会立马就中断；说道interrupt就得说一下isInterrupted方法，他是判断线程中断标志的，如果线程A执行了线程B的interrupt方法，线程B在自己的线程中也可以使用 isInterrupted 方法判断自己的中断标志。<br>&nbsp;<br><strong>注意：在使用 interrupt方法时，如果线程在sleep wait wait(time)状态， 抛出InterruptedException异常后会清除 isInterrupted 方法获取的中断标志位，反之则不会</strong></p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a><strong>代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-17 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 在使用 interrupt方法是，如果线程咋sleep wait wait(time) 在抛出InterruptedException异常后会 清除 isInterrupted 方法获取的标志位 其他则不会</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">                &#125;, <span class="string">"循环线程"</span>);</span><br><span class="line"></span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"睡眠线程"</span>);</span><br><span class="line"></span><br><span class="line">                Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                o.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"等待线程"</span>);</span><br><span class="line"></span><br><span class="line">                thread1.start();</span><br><span class="line">                thread2.start();</span><br><span class="line">                thread3.start();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                thread1.interrupt();</span><br><span class="line">                thread2.interrupt();</span><br><span class="line">                thread3.interrupt();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">"循环线程isInteryupt is "</span> + thread1.isInterrupted());</span><br><span class="line">                System.out.println(<span class="string">"睡眠线程isInteryupt is "</span> + thread2.isInterrupted());</span><br><span class="line">                System.out.println(<span class="string">"等待线程isInteryupt is "</span> + thread3.isInterrupted());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.com.concurrenncy.InterruptTest.lambda$main$<span class="number">1</span>(InterruptTest.java:<span class="number">20</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">at com.com.concurrenncy.InterruptTest.lambda$main$<span class="number">2</span>(InterruptTest.java:<span class="number">32</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">循环线程isInteryupt is <span class="keyword">true</span></span><br><span class="line">睡眠线程isInteryupt is <span class="keyword">false</span></span><br><span class="line">等待线程isInteryupt is <span class="keyword">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了java线程的生命周期，Synchronized的几个方法简单的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://www.lantaoblog.site/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://www.lantaoblog.site/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Lock总结</title>
    <link href="https://www.lantaoblog.site/2019/06/14/%E9%94%81/Lock%E6%80%BB%E7%BB%93/"/>
    <id>https://www.lantaoblog.site/2019/06/14/锁/Lock总结/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-20T02:11:02.398Z</updated>
    
    <content type="html"><![CDATA[<p>Lock在我们日常研发中经常会使用到，比如ReenTrantLock，ReentrantReadWriteLock，StampedLock (JDK1.8新增)，</p><a id="more"></a><p>下面就详细介绍一下它们的使用方法。</p><ul><li><h2 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h2><p>ReenTrantLock支持公平锁和非公平锁,也是独占锁,下面来说一下ReenTrantLock下的方法和使用。</p><ol><li><p><strong>lock：</strong>获取阻塞锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是费公平锁，可自定，在参数中增加 true-公平 false-非公平</span></span><br><span class="line">ReenTrantLock lockObjcet = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 获取锁 ，如果获取不到则阻塞线程</span></span><br><span class="line">  lockObjcet.lock();</span><br><span class="line">  <span class="comment">// 同步代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  lockObjcet.unLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>tryLock：</strong>获取非阻塞锁，如果无法获取到锁，返回false，获取到了返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReenTrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">  <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="comment">// 获取到了锁</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有获取到锁</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>tryLock(time)：</strong>获取非阻塞超时锁，在time时间内如果获取到了锁，返回true，获取不到锁返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReenTrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">  <span class="comment">// 获取锁，如果在指定时间内还未获得，则返回false</span></span><br><span class="line">  <span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获取到了锁</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有获取到锁</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>lockInterruptibly()：</strong>获取可中断锁，和<strong>lock</strong>区别就是在获取锁的过程中可以中断线程。</p></li><li><p><strong>unlock()：</strong>解锁</p></li><li><p><strong>boolean isHeldByCurrentThread()：</strong>判断锁是否是当前线程持有，是返回true，不是返回false。</p></li><li><p><strong>boolean isLocked()：</strong>判断锁是否被获取或占用。</p></li><li><p><strong>boolean isFair()：</strong>是否是公平锁，是 返回true， 不是返回false。</p></li><li><p><strong>Thread getOwner()：</strong>获取当前锁的拥有者， 如果有拥有者则返回拥有者，如果没有返回null。</p></li><li><p><strong>boolean hasQueuedThreads()：</strong>判断是否有等待线程，如果有则返回true，反之false。</p></li><li><p><strong>boolean hasQueuedThread(Thread thread)：</strong>判断入参的线程是否存在于等待队列中，如果存在则返回true，反之false。</p></li><li><p><strong>int getQueueLength()：</strong>获取等待队列中线程总数。</p></li><li><p><strong>Collection<thread> getQueuedThreads()：</thread></strong>获取等待队列中的所有线程。</p></li><li><p><strong>boolean hasWaiters(Condition condition)：</strong>否有线程在与此锁关联的给定条件上等待，有返回true 反之 false。</p></li><li><p><strong>int getWaitQueueLength(Condition condition)：</strong>获取被<strong>参数</strong>条件等待的线程总数。</p></li><li><p><strong>Collection<thread> getWaitingThreads(Condition condition)：</thread></strong>获取当前锁的条件等待的所有线程.</p></li></ol></li></ul><ul><li><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h2><p><strong>读写锁：</strong> 读锁可以多线程一起获取，写锁只有一个线程可以获取，<strong>读写锁支持公平锁和非公平锁</strong>，支持重入锁。</p><p><strong>读锁：</strong> 可以被<strong>多个线程共同获取锁</strong>，同时进入代码块。</p><p><strong>写锁：</strong>只允许一个线程获取，如果当前线程获取到<strong>写锁</strong>后，发现有线程获取了读锁，并且<strong>不是当前线程</strong>，这时当前线程就进入<strong>等待</strong>状态。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line"><span class="keyword">private</span>  ReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">// 读锁 共享锁</span></span><br><span class="line"><span class="keyword">private</span>  Lock r = rw.readLock();</span><br><span class="line"><span class="comment">// 写锁 排它锁</span></span><br><span class="line"><span class="keyword">private</span>  Lock w = rw.writeLock();</span><br></pre></td></tr></table></figure><ul><li><strong>WriteLock</strong><ol><li><strong>lock()：</strong>写锁为独占锁，当线程A获取到了写锁时任何线程都不能获取到读锁和写锁，如果线程A获取到了写锁，但是读锁已经被线程B获取并且未释放，这时就需要将线程A状态改为等待，等待线程B释放了写锁再继续执行。</li><li><strong>unlock()：</strong>解锁。</li></ol></li><li><strong>ReadLock</strong><ol><li><strong>lock()：</strong> 加锁。</li><li><strong>unlock()：</strong> 解锁。</li></ol></li></ul></li></ul><ul><li><h2 id="StampedLock-JDK1-8新增"><a href="#StampedLock-JDK1-8新增" class="headerlink" title="StampedLock (JDK1.8新增)"></a>StampedLock (JDK1.8新增)</h2><p><strong>StampedLock</strong>： 读写锁，但是<strong>StampedLock</strong>比<strong>ReenTrantReadWriteLock</strong>更块,但是<strong>StampedLock</strong>用于<strong>乐观读</strong>锁，<strong>悲观读</strong>锁，和写锁，StampedLock<strong>不支持重入锁</strong>，StampedLock 的<strong>悲观读锁、写锁都不支持条件变量</strong>。</p><ol><li><strong>tryOptimisticRead：</strong>乐观读。</li><li><strong>readLock：</strong>悲观读。</li><li><strong>writeLock：</strong>悲观写。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-05 17:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StampedLock s =<span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 悲观读</span></span><br><span class="line">        <span class="keyword">long</span> l = s.readLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放悲观读</span></span><br><span class="line">        s.unlockRead(l);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 悲观写</span></span><br><span class="line">        <span class="keyword">long</span> l1 = s.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放悲观写</span></span><br><span class="line">        s.unlockWrite(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乐观读 升级 悲观读</span></span><br><span class="line">        <span class="keyword">long</span> l2 = s.tryOptimisticRead();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证是否被修改 如果返回false 会释放 l2，所以后续直接释放l3即可</span></span><br><span class="line">        <span class="keyword">if</span> (!s.validate(l2))&#123;</span><br><span class="line">            <span class="comment">// 升级悲观读</span></span><br><span class="line">            <span class="keyword">long</span> l3 = s.readLock();</span><br><span class="line">            s.unlockRead(l3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Conditionn"><a href="#Conditionn" class="headerlink" title="Conditionn"></a>Conditionn</h2><p><strong>Condition：</strong> <strong>Lock 的条件 ,其实初始化的是ConditionObject， ConditionObject是Condition的实现，singal和signlAll的时候需要在获取锁后。</strong></p><ol><li><strong>await()：</strong> 线程等待，相当于<strong>Objcet的wait()</strong>方法。</li><li><strong>awaitNanos(time)：</strong> 等待一定时间，如果超过则继续执行，<strong>相当于Object的wait(time)方法</strong>。</li><li><strong>signal()：</strong> <strong>随机</strong>唤醒一个被Condition.await()的线程，<strong>相当于Object的notify()方法</strong>。</li><li><strong>signalAll()：</strong> <strong>唤醒全部</strong>被Condition.await()的线程，<strong>相当于Object的notifyAll()方法</strong>。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-04-15 14:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Condition 条件 有 singal signalAll 和 await 方法 和Object 的 notify notifyAll 和 wait 是一个意思同样会释放锁  执行singal和notify的时候也需要在等待获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition a = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition b = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                a.await();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">" 的 a conndition 被唤醒了"</span>);</span><br><span class="line"></span><br><span class="line">                b.await();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">" 的 b conndition 被唤醒了"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> +Thread.currentThread().getName() + <span class="string">" 开始执行a condition sinalAll"</span>);</span><br><span class="line">                a.signalAll();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> +Thread.currentThread().getName() + <span class="string">" 开始执行b condition sinalAll"</span>);</span><br><span class="line">                b.signalAll();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"Thread2"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable1,<span class="string">"Thread3"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable2,<span class="string">"Thread4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Thread1</span><br><span class="line">Thread2</span><br><span class="line">线程Thread3 开始执行a condition sinalAll</span><br><span class="line">Thread1 的 a conndition 被唤醒了</span><br><span class="line">Thread2 的 a conndition 被唤醒了</span><br><span class="line">线程Thread4 开始执行b condition sinalAll</span><br><span class="line">Thread1 的 b conndition 被唤醒了</span><br><span class="line">Thread2 的 b conndition 被唤醒了</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lock在我们日常研发中经常会使用到，比如ReenTrantLock，ReentrantReadWriteLock，StampedLock (JDK1.8新增)，&lt;/p&gt;
    
    </summary>
    
      <category term="锁" scheme="https://www.lantaoblog.site/categories/%E9%94%81/"/>
    
    
      <category term="Lock" scheme="https://www.lantaoblog.site/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>管程含义</title>
    <link href="https://www.lantaoblog.site/2019/06/14/%E9%94%81/%E7%AE%A1%E7%A8%8B%E5%90%AB%E4%B9%89/"/>
    <id>https://www.lantaoblog.site/2019/06/14/锁/管程含义/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-25T01:44:32.315Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍管程</p><a id="more"></a><h3 id="管程-解决互斥和同步"><a href="#管程-解决互斥和同步" class="headerlink" title="管程 解决互斥和同步"></a>管程 解决互斥和同步</h3><ul><li><p>语义：管程的全拼就是 <strong>‘管理共享变量以及共享变量的操作过程’</strong>，让他们支持并发，</p><h3 id="管程的模型"><a href="#管程的模型" class="headerlink" title="管程的模型"></a>管程的模型</h3></li><li><h4 id="模型的区别"><a href="#模型的区别" class="headerlink" title="模型的区别"></a><strong>模型的区别</strong></h4><p>MESA,HASEN,HOARE的区别就是当条件满足，通知线程和执行的方式；<br>&nbsp; </p></li><li><h4 id="MESA"><a href="#MESA" class="headerlink" title="MESA"></a><strong>MESA</strong></h4><p>java使用的管程模型就是MESA，当B线程执行notify或notifyAll通知A线程执行的时候，线程B还会继续执行，这时线程A会到 <strong>‘就绪队列’</strong> ,等待回去监视器(Monitor)锁后继续执行wait()后的方法，可以保证同一时间只有一个线程执行；<br>&nbsp; </p></li><li><h4 id="HASEN"><a href="#HASEN" class="headerlink" title="HASEN"></a><strong>HASEN</strong></h4><p>HASEN模型，要求notify或notifyALl放到放到最后执行，这样线程B执行代码全部执行完成后在执行notify通知线程A，线程A再继续执行wait()后的方法，也可以保证同一时间只有一个线程执行；<br>&nbsp; </p></li><li><h4 id="HOARE"><a href="#HOARE" class="headerlink" title="HOARE"></a><strong>HOARE</strong></h4><p>HOARE模型,不限制notify或notifyAll的执行位置，但是线程B使用notify或notifyAll的时候，会阻塞线程B，然后执行线程A，线程A执行完成再通知线程B继续执行，同样可以保证同一时间只有一个线程在运行；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍管程&lt;/p&gt;
    
    </summary>
    
      <category term="管程" scheme="https://www.lantaoblog.site/categories/%E7%AE%A1%E7%A8%8B/"/>
    
    
      <category term="管程" scheme="https://www.lantaoblog.site/tags/%E7%AE%A1%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码之注解扫描Component-scan</title>
    <link href="https://www.lantaoblog.site/2019/03/16/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring%E6%BA%90%E7%A0%81%E4%B9%8B%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8FComponent-scan/"/>
    <id>https://www.lantaoblog.site/2019/03/16/Spring源码系列/Spring源码之注解扫描Component-scan/</id>
    <published>2019-03-15T16:00:00.000Z</published>
    <updated>2019-06-20T01:55:38.925Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Spring的component-scan标签，了解spring是如果实现扫描注解进行bean的注册，主要实现实在 NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 三个接口中，还需要配置</p><a id="more"></a><p>spring.handlers文件，在接下里的源码解析中会详细解析，在本篇博客中将使用ApplicationConntext作为起点，直接从差异开始讲解，如果想了解ApplicationContext 源码的全流程请看上篇博客。</p><blockquote><p>GItHub:<a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></p></blockquote><blockquote><p><strong>这里解析解释一下他们之间的关系：</strong></p><p><strong>NamespaceHandlerSupport  是 Abstract 修饰的抽象类 并 实现 NamespaceHandler 接口，继而实现了 NamespaceHandler接口的parser和docreate方法，自定的NamespaceHandler需要继承NamespaceHandlerSupport类并需要实现NamespaceHandler接口的init方法，init方法需要做解析类的注册操作，代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> org.springframework.context.config;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.ComponentScanBeanDefinitionParser;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.xml.NamespaceHandler&#125;</span></span><br><span class="line"><span class="comment">&gt;  * for the '&#123;<span class="doctag">@code</span> context&#125;' namespace.</span></span><br><span class="line"><span class="comment">&gt;  *</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">&gt; registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Subclasses can call this to register the supplied &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; to</span></span><br><span class="line"><span class="comment">&gt;  * handle the specified element. The element name is the local (non-namespace qualified)</span></span><br><span class="line"><span class="comment">&gt;  * name.</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>BeanDefinitionParser类是解析类的顶层接口，自定义的解析类需要实现BeanDefinitionParser类的Parser方法，解析类的注册就在NameSpaceHandler的init方法中年进行；</strong></p></blockquote><ul><li>还是先看一下测试类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao.scan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-bean-scan.xml"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>xml文件中use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller，@Component和@Repository 的注解的类进行扫描 ,如果定位为false的话，就需要进行自定义include-filter。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans</span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">   xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">   xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">   http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- use-<span class="keyword">default</span>-filters 属性的默认值为 <span class="keyword">true</span>，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 <span class="meta">@Service</span>,<span class="meta">@Controller</span>和<span class="meta">@Repository</span> 的注解的类进行扫描 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"lantao.scan"</span> use-<span class="keyword">default</span>-filters=<span class="string">"false"</span>&gt;</span><br><span class="line">&lt;!-- 只扫描 base-<span class="keyword">package</span> 的 controller 注解 还有对应的 exclude-filter 标签 排除 ； use-<span class="keyword">default</span>-filters=<span class="string">"false"</span> 和 include-filter 一起使用 和 exclude-filter一起回抛异常--&gt;</span><br><span class="line">&lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span><br><span class="line">&lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Component"</span>/&gt;</span><br><span class="line">&lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span><br><span class="line">&lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>因为这里使用<a href="https://blog.csdn.net/qq_30257149/article/details/88224879" target="_blank" rel="noopener">ApplicationContext，ApplicationContext</a>在上篇文章已经进行了源码解读，接下来我们直接看<strong>差异点。</strong></p><ul><li>差异代码在DefaultBeanDefinitionDocumentReader类中的parseBeanDefinitions方法中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">//对默认标签处理</span></span><br><span class="line"><span class="comment">// 这里只处理 nade namespace 为 http://www.springframework.org/schema/beans 的标签</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//对自定义标签处理 会解析 &lt;context:component-scan base-package="lantao.scan"/&gt; 或者自定义 dubbo</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//对自定义标签处理</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要差异就在</strong> <strong>parseDefaultElement(ele, delegate) 和 delegate.parseCustomElement(ele) 方法上，parseDefaultElement方法仅仅会处理node的namespace是：</strong><a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> 的标签，<strong>其他标签</strong>和 <strong>自定义标签</strong>全部都是通过这个方法来解析的；</p><ul><li><strong>delegate.parseCustomElement源码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取node的 NameSpaceURI</span></span><br><span class="line">String namespaceUri = getNamespaceURI(ele);</span><br><span class="line"><span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析自定义标签 需要在 Meta-inf 文件加 增加 spring.handlers 文件 例如：http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span></span><br><span class="line"><span class="comment">// 根据指定的 NameSpaceURI 获取 NamespaceHandler  handler可以参考spring.handlers文件</span></span><br><span class="line"><span class="comment">// abstract NamespaceHandlerSupport 实现了 NamespaceHandler 接口，继而实现了 NamespaceHandler 的两个个方法（parser，docreate），自定义handler 需要实现 NamespaceHandlerSupport 类</span></span><br><span class="line"><span class="comment">// 进行 NamespaceHandler 类的 init 方法的 实现， 主要是做注册 BeanDefinitionParser（ registerBeanDefinitionParser ） ， 需要自定义解析类 继承 BeanDefinitionParser 类</span></span><br><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析操作</span></span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码很简单，只做了一下三件事情：</p><p>1：获取Element的NamespaceUri；</p><p>2：通过命名空间处理解析器(NamespaceHandlerResolver)的resolver方法进行NameSpaceHandler的处理；</p><p>3：通过NameSpaceHandler的Parse方法进行标签解析；</p><ul><li>我们直接看 resolve方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locate the &#123;<span class="doctag">@link</span> NamespaceHandler&#125; for the supplied namespace URI</span></span><br><span class="line"><span class="comment"> * from the configured mappings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespaceUri the relevant namespace URI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the located &#123;<span class="doctag">@link</span> NamespaceHandler&#125;, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里获取的是所有注册到 handlerMappings 中的  NamespaceHandler ， </span></span><br><span class="line"><span class="comment">// 就是 resource/META-INF/spring.handler 中的类  key就是namespaceUri ，</span></span><br><span class="line"><span class="comment">// 这些类都继承了 NamespaceHandlerSupport 实现了init方法 在init方法中进行 BeanDefinitionParse 的注册Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span></span><br><span class="line"><span class="comment">// 通过 namespaceUri 在 handlerMappings 中获取对应的处理器或者 className 如果是初始化过的就直接返回，反之进行类初始化工作</span></span><br><span class="line">Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line"><span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String className = (String) handlerOrClassName;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line"><span class="comment">// 判断实例化的类的超类或者超级接口 是否是 NamespaceHandler</span></span><br><span class="line"><span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line"><span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line">NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line"><span class="comment">// 注册 自定义标签所对应的 解析策略类  解析策略类都继承了 BeanDefinitionParser ，比如 ComponentScanBeanDefinitionParser</span></span><br><span class="line">namespaceHandler.init();</span><br><span class="line"><span class="comment">// 放入缓存中</span></span><br><span class="line">handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line"><span class="keyword">return</span> namespaceHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Could not find NamespaceHandler class ["</span> + className +</span><br><span class="line"><span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Unresolvable class definition for NamespaceHandler class ["</span> +</span><br><span class="line">className + <span class="string">"] for namespace ["</span> + namespaceUri + <span class="string">"]"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了一件事情，就是获取<strong>nameSpaceUri</strong>对应的<strong>NameSpaceHandler</strong>,首先会调动<strong>getHandlerMappings</strong>方法获取全部的<strong>NameSpaceHandler，</strong>然后通过<strong>namespaceUri</strong>获取对应的<strong>NameSpaceHandler，</strong>如果还未实例化则进行实例化操作执行init方法向parsers注册解析类，反之直接返回；<strong>getHandlerMappings</strong>方法获取的<strong>NameSpaceHandler</strong>是解析于<strong>resource/META-INF/spring.handler 文件下, key就是namespaceUri,value就是自定义的NameSpaceHandler；</strong></p><ul><li>getHandlerMappings方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the specified NamespaceHandler mappings lazily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getHandlerMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; handlerMappings = <span class="keyword">this</span>.handlerMappings;</span><br><span class="line"><span class="keyword">if</span> (handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">handlerMappings = <span class="keyword">this</span>.handlerMappings;</span><br><span class="line"><span class="keyword">if</span> (handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loading NamespaceHandler mappings from ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这里的handlerMappingsLocation指定的地址就是 resources 中的 META-INF/spring.handlers</span></span><br><span class="line">Properties mappings =</span><br><span class="line">PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loaded NamespaceHandler mappings: "</span> + mappings);</span><br><span class="line">&#125;</span><br><span class="line">handlerMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(mappings.size());</span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getHandlerMappings就是解析spring.handler文件和执行NameSpaceHandler的init方法并放入缓存的操作，NameSpaceHandler获取到了以后我们看一下init注册的BeanDefinitionParser的parser方法；</strong></p><ul><li>NameSpaceHandlerSupport的parse方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@link</span> Element&#125; by delegating to the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; that is</span></span><br><span class="line"><span class="comment"> * registered for that &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在 NamespaceHandlerSupport 中的 parser 集合中获取 BeanDefinitionParser 的实现类 进行 parser</span></span><br><span class="line">BeanDefinitionParser parser = findParserForElement(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> (parser != <span class="keyword">null</span> ? parser.parse(element, parserContext) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>parse方法做了两件事情：</strong></p><p><strong>1：通过定义的标签属性(例如：**</strong>component-scan<strong>**)获取对应的BeanDefinitionParser解析类，源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locates the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; from the register implementations using</span></span><br><span class="line"><span class="comment"> * the local name of the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里判断各种标签的解析策略 获取标签名字</span></span><br><span class="line">String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line"><span class="comment">// 从 parsers 中获取对应的解析策略类  parsers 是在 NameSpaceHandler 的 init 方法是初始化的；</span></span><br><span class="line">BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">parserContext.getReaderContext().fatal(</span><br><span class="line"><span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回对应的策略类进行解析</span></span><br><span class="line"><span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2：开始解析；</strong></p><ul><li><strong>parse方法源码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 basePackage 的 路径</span></span><br><span class="line">String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 解析给定文本中的$&#123;.&#125;，将其替换为由&#123;@link #getProperty&#125;解析的相应属性值 就是可以使用 $&#123;&#125; 和 properties中的值对应</span></span><br><span class="line">basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line"><span class="comment">//我们这里在设置 base-package 的值时, 可以通过上面指示的分隔符 ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS 进行多个package的指定. 可以使用”,” “;” “\t\n(回车符)”来分割多个包名</span></span><br><span class="line">String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line"><span class="comment">// 下面的代码就是 实际扫描bean定义并注册它们。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 ClassPathBeanDefinitionScanner</span></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line"><span class="comment">// 扫描 并 注册</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line"><span class="comment">// 处理 annotation-config</span></span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parse方法主要做了以下五件事情：</p><p>1：获取basePackage的值，就是xml中配置的路径地址；</p><p>2：basePackage可以配置多个，使用 ‘,’ ‘;’ 或者回车符 进行分割；</p><p>3：初始化ClassPathBeanDefinitionScanner，后边的解析操作有ClassPathBeanDefinitionScanner来完成；</p><p>4：扫描并注册bean；</p><p>5：处理annotation-config(这个后续会详细讲解，这里就不赘述了)</p><ul><li>先看一下configureScanner方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 设置 use-default-filters 标签  use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller和@Repository 的注解的类进行扫描</span></span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line"><span class="comment">// 将注册Bean的任务委托给ClassPathBeanDefinitionScanner类。初始化 ClassPathBeanDefinitionScanner  ，ClassPathBeanDefinitionScanner 是解析conponentScanner 的类</span></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line"><span class="comment">// set RESOURCE_PATTERN_ATTRIBUTE 设置 扫描Resource(资源) 路径 默认为 "**/*.class"</span></span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// set name-generator</span></span><br><span class="line"><span class="comment">// 初始化bean 名称生成器</span></span><br><span class="line">parseBeanNameGenerator(element, scanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置bean作用域</span></span><br><span class="line">parseScope(element, scanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置扫描包含 和 排除的 注解</span></span><br><span class="line"><span class="comment">// 设置过滤器，即用于指定哪些类需要被处理，哪些类需要被忽略</span></span><br><span class="line"><span class="comment">// set INCLUDE_FILTER_ELEMENT and EXCLUDE_FILTER_ELEMENT</span></span><br><span class="line">parseTypeFilters(element, scanner, parserContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configureScanner方法主要做了以下五件事：</p><p>1：获取并设置use-default-filters，use-default-filters 属性的默认值为 true，即使用默认的 Filter 进行包扫描，而默认的 Filter 对标有 @Service,@Controller和@Repository 的注解的类进行扫描，如果设置为false，则需要自行对include-filter添加；</p><p>2：初始化ClassPathBeanDefinitionScanner，如果use-default-filters为true则对include-filter进行add操作；</p><p>3：初始化bean 名称生成器；</p><p>4：设置bean作用域；</p><p>5：设置扫描包含 和 排除的 注解，include-filter和exclude-filter；</p><p>上述代码就不展现了，git上代码有对应的注释；</p><ul><li>接下来看scanner.doScan方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment"> * returning the registered bean definitions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment"> * but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 循环扫描</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">// 获取指定包下所有 BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">// 获取一个ScopeMetadata对象，默认为AnnotationScopeMetadataResolver</span></span><br><span class="line"><span class="comment">// 如果目标类未被@Scope注解，则返回一个默认的ScopeMetadata</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bean名称生成器生成bean名称，默认生成器为AnnotationBeanNameGenerator</span></span><br><span class="line"><span class="comment">// 首先是以注解的value为bean名称，如果注解的value没有值，则使用默认的名称</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 处理定义在目标类上的注解，包括@Lazy, @Primary, @DependsOn, @Role, @Description</span></span><br><span class="line"><span class="comment">// 这里会检查和 设置 AnnotatedBeanDefinition 的 @Lazy(懒加载) @Primary(主要，https://www.cnblogs.com/liaojie970/p/7885106.html) @DependsOn(需要依赖但不需要持有) 注解</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查beanName是否已经存在 BeanDefinitionRegistry 中存在。</span></span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">//beanName 还没使用过</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line"><span class="comment">// 如果有必要，则创建作用域代理</span></span><br><span class="line"><span class="comment">// 如果创建了代理，则返回表示代理对象的BeanDefinitionHolder</span></span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">// 注册Bean</span></span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看以下在doScan方法中都做了什么：</p><p>1：获取指定包下(指定的basePackage)所有 BeanDefinition；</p><p>2：获取一个ScopeMetadata对象，默认为AnnotationScopeMetadataResolver，如果目标类未被@Scope注解，则返回一个默认的ScopeMetadata；</p><p>3：使用bean名称生成器生成bean名称，默认生成器为AnnotationBeanNameGenerator，如果注解上的value值是null，则需要生成；</p><p>4：设置AutowireCandidate autowire-candidate=”false” 表示该对象不参与自动注入，借鉴：<a href="https://blog.csdn.net/shangboerds/article/details/72758095" target="_blank" rel="noopener">https://blog.csdn.net/shangboerds/article/details/72758095</a></p><p>5：处理定义在目标类上的注解，包括@Lazy, @Primary, @DependsOn, @Role, @Description，这里会检查和设置 AnnotatedBeanDefinition 的 @Lazy(懒加载) @Primary(主要，<a href="https://www.cnblogs.com/liaojie970/p/7885106.html" target="_blank" rel="noopener">https://www.cnblogs.com/liaojie970/p/7885106.html</a>) @DependsOn(需要依赖但不需要持有) 注解；</p><p>6：检查beanName是否已经存在 beanDefinitionMap 中存在；</p><p>7：如果设置了scopedProxyMode，则需要创建代理类和注册代理类；</p><p>8：调用registerBeanDefinition注册bean，就是put到beanDefinitionMap中；</p><ul><li>这里只说核心的scanCandidateComponents方法，其他的方法都很简单，读者自行通过debug来做就可以了：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX = "classpath*:";</span></span><br><span class="line"><span class="comment">// 通过观察resolveBasePackage()方法的实现, 我们可以在设置basePackage时, 使用形如$&#123;&#125;的占位符, Spring会在这里进行替换</span></span><br><span class="line"><span class="comment">// this.resourcePattern 默认为 "**/*.class" resourcePattern 可以再xml中配置</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line"><span class="comment">// 使用上面拼接出的形如 "classpath*:xx/yyy/zzz/**/*.class", 将其检索为Spring内置的Resource对象(这样就统一化了资源的差异)</span></span><br><span class="line"><span class="comment">// 使用ResourcePatternResolver的getResources方法获取 路径下全部  比如：classpath*:lantao/scan/**/*.class</span></span><br><span class="line">Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line"><span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file是否可读</span></span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取元数据  元数据就是用来定义数据的数据 就是定义 class 的 属性</span></span><br><span class="line">MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据锅炉器来判断是否符合要求 做  includeFilters excludeFilters 的判断</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line"><span class="comment">// 实例化 ScannedGenericBeanDefinition</span></span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line"><span class="comment">// 判断类必须是一个具体的实现类，并且它的实例化必须是独立的</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是做了通过ResourcePatternResolver的getResource获取指定路径的资源文件，再通过资源文件Resource获取MetadataReader (元数据就是用来定义数据的数据 就是定义 class 的 属性),接下来通过isCandidateComponent方法来做核心处理，因为通过路径获取的资源是全部的，不是想要的，通过isCandidateComponent方法来做 ncludeFilters excludeFilters 的判断，再通过isCandidateComponent(sbd)判断BeanDefinition必须是一个实现类，不可以是接口等；</p><ul><li><p>我们看一下核心判断方法isCandidateComponent：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment"> * and does match at least one include filter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 判断 excludeFilters 的 TypeFilter</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断逻辑 includeFilters 中的 TypeFilter 默认包含的filter有 @components 和 引用他的  @service @controller @Repository</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line"><span class="comment">// 判断 @Conditional ， @Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。 还有 @ConditionalOnXX 等注解</span></span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment"> * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line"><span class="comment">// metadata.isIndependent() 是独立的 &amp;</span></span><br><span class="line"><span class="comment">// metadata.isConcrete() 是否是接口或者是抽象类 或</span></span><br><span class="line"><span class="comment">// 必须是抽象类 和 有@lookup 注解</span></span><br><span class="line"><span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li></ul><p>  到这里就已经讲完了Component-scan扫描注入的源码，这里涉及代理和annotation-config没有做详细的讲解，会在后续的文章中做，码字不易，转发请注明出处：<a href="https://blog.csdn.net/qq_30257149/article/details/88596355" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/88596355</a></p><p>  博客地址：<a href="https://lantaogithub.github.io" target="_blank" rel="noopener">https://lantaogithub.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Spring的component-scan标签，了解spring是如果实现扫描注解进行bean的注册，主要实现实在 NamespaceHandler, NamespaceHandlerSupport 和 BeanDefinitionParser 三个接口中，还需要配置&lt;/p&gt;
    
    </summary>
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/categories/spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="Component-scan" scheme="https://www.lantaoblog.site/tags/Component-scan/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://www.lantaoblog.site/2019/03/14/Jvm/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.lantaoblog.site/2019/03/14/Jvm/Java内存模型/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-06-20T01:53:38.350Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了Java内存模型丶Volatile和Synchronized的语义</p><a id="more"></a><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li><h4 id="语义"><a href="#语义" class="headerlink" title="语义:"></a><strong>语义:</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; volatile具有和synchronized的一样的语义,被volatile修饰的变量在 ‘读’ 时JMM会将该线程所对应的’本地内存’置为失效，线程接下来会从 <strong>‘主内存’</strong> 中直接获取，在 ‘写’ volatile 修饰的变量时JMM会将该线程对应的本地内存的共享变量直接写入到 <strong>‘主内存’</strong> 中。</p></li><li><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 被volatile修饰的变量将会 <strong>‘禁用缓存’</strong> , 并且禁止 <strong>‘指令重排’</strong>（指令重排分为虚拟机重排和处理器重排）<br>&nbsp; &nbsp; &nbsp; &nbsp; <strong>volatile</strong> 声明这个字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性。<br>&nbsp; &nbsp; &nbsp; &nbsp; <strong>static</strong> 声明这个字段是静态的（可能被多个实例共享），在主存区上该类的所有实例的该字段为同一个变量，即唯一性。</p></li><li><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String a;</span><br></pre></td></tr></table></figure></li></ul><h3 id="synchroized"><a href="#synchroized" class="headerlink" title="synchroized"></a>synchroized</h3><ul><li><h4 id="语义："><a href="#语义：" class="headerlink" title="语义："></a><strong>语义：</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 在进入synchronized修饰的方法或代码块时会进行lock操作，<strong>并且JMM会将线程本地内存清空,临界区内使用共享变量将从’主内存’中同步</strong>,在出synchronized修饰的方法或代码块时会进行unlock操作，<strong>并且JMM会将线程的本地内存的共享变量刷新到主内存中。</strong><br>&nbsp; </p></li><li><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用:"></a><strong>使用:</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized是java内置锁,可以放在 <strong>‘普通方法’ ‘静态方法’ 和 ‘代码块’</strong> 上,如果是放在普通方法上则代表着 <strong>‘锁的是当前对象’</strong>,放在静态方法上 <strong>‘锁的是类(.class)’</strong> ,如果是synchronized代码块写法则是synchronized(‘需要锁的对象或者是类’){‘临界区’}。<br><strong>注：synchronized锁的是一个对象而不是某个方法</strong><br>&nbsp; </p></li><li><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁的是当前对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的是类(.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里锁的是this 也就是当前对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">      <span class="comment">// 这里代表临界区</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可见性·原子性和有序性"><a href="#可见性·原子性和有序性" class="headerlink" title="可见性·原子性和有序性"></a>可见性·原子性和有序性</h3><ul><li><h4 id="语义-1"><a href="#语义-1" class="headerlink" title="语义"></a><strong>语义</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>可见性</strong> 就是指线程A在修改共享变量后线程B你能立马看的到，称之为可见性。<br>&nbsp; &nbsp; &nbsp; &nbsp; <strong>原子性</strong> 就是指一个操作或一组操作不可中断，要么全部执行，要么全都不执行，称之为原子性。（操作的中间状态对外不可见）<br>&nbsp; &nbsp; &nbsp; &nbsp; <strong>有序性</strong> 就是指程序按照我们的代码顺序进行执行，称之为有序性(程序员以为是按照我们的代码顺序执行的，其实经过了虚拟机和处理器指令重排后的顺序执行的)。</p></li></ul><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><ul><li><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a><strong>运行时数据区域</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图：<br>&nbsp;<br><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="java内存模型.png"><br>&nbsp; </p></li><li><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp;虚拟机栈是线程私有的，也可以称之为线程栈，虚拟机栈所描述的就是java执行方法的一个简易版内存模型，每个方法在执行时都会创建 <strong>‘栈帧’</strong> 用于存存储:<br><strong>局部变量表：存放方法参数和方法内部定义的局部变量</strong><br><strong>操作数栈： 其实就是在执行每一行命令，操作记录</strong><br><strong>动态链接:指向运行时常量池的引用,因为在方法执行的过程中有可能需要用到类中的常量</strong><br><strong>方法出口:方法返回地址当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址’</strong> 等信息’<br><strong>局部变量表</strong>：存储各种基本数据类型，包括 <strong>byte,short,int,long,float,dubbo,char,boolean</strong> 和 对象引用(<strong>引用类型不是对象本身，是一个指向对象的一个地址</strong>)&nbsp; </p></li><li><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp;本地方法栈和虚拟机栈是一样的，区别就是<strong>虚拟机栈是为java方法(也就是字节码)服务的，本地方法栈是为虚拟机使用到的Native服务的。(可以理解为是操作系统的方法)</strong><br>&nbsp; </p></li><li><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp;程序计数器也是线程私有的，大白话意思就是存储线程的执行地址，因为java多线程是通过Cpu时间片轮询方式执行的，比如线程A执行到一半，Cpu时间片使用完了，这时线程A就会在自己的程序计数器中<strong>存储执行地址保证下次从这里开始继续执行</strong>，然后线程B开始执行。<br>&nbsp; </p></li><li><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; java堆就是存储所有对象的实例,数组(数组引用是存放在Java栈中的)和常量池，也是最大的一块内存，-xms 初始堆大小 和-xmx最大堆大小<br>&nbsp;</p></li><li><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 方法区也是线程共享的区域，存储已经被虚拟机加载的<strong>类信息（包括类的名称、方法信息、字段信息），常量和静态变量</strong>，(在1.8之前也叫用永久代，之后称之为元空间,使用的是本地内存)<br>&nbsp;</p></li><li><h4 id="常量池-存在于方法区中"><a href="#常量池-存在于方法区中" class="headerlink" title="常量池 存在于方法区中"></a><strong>常量池 存在于方法区中</strong></h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 常量池 (jdk1.7 后常量池移到堆中)也可以说是String常量池，因为String是final修饰的，是常量且不可变。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码JMM就会在常量池中查找"lantao"是否存在，如果存在则将地址赋值给a，如果不存在则先创建一个存储在常量池中然后将地址赋值给a；</span></span><br><span class="line">        String a = <span class="string">"lantao"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码会创建你String对象，区别就是 </span></span><br><span class="line"><span class="comment">//1-创建String对象；</span></span><br><span class="line"><span class="comment">//2-在常量池中查；找"lantao"，如果存在则赋值给1，如果不存在则在常量池中创建'lantao'再将地址赋值给1；</span></span><br><span class="line"><span class="comment">//3：String对象将地址赋值个变量b；</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"lantao"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以  这里是 false ，因为地址不一样，</span></span><br><span class="line"><span class="comment">// b的地址指向的是 heap 中的String，String对象在只指向常量池中的'lantao'</span></span><br><span class="line"><span class="comment">// a的地址是直接指向 常量池中的'lanntao'</span></span><br><span class="line">        System.out.println(a == b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>图片：</strong></p><p><img src="https://raw.githubusercontent.com/lantaoGitHub/photos/master/Concurrency/%E5%B8%B8%E9%87%8F%E6%B1%A01.png" alt></p></li></ul><ul><li><h4 id="java内存模型的8个操作"><a href="#java内存模型的8个操作" class="headerlink" title="java内存模型的8个操作"></a><strong>java内存模型的8个操作</strong></h4><p>1–lock(加锁)：用在主内存变量上，标记这个变量是一个线程独占状态，其他线程不可锁定；<br>2–unlock(解锁)：用在主内存变量上，对已经加锁的变量进行解锁，释放锁后其他线程可进行对该变量的加锁；<br>3–read(读取):用在主内存上，将主内存中的变量读取到线程本地内存中，以便后续的load操作；<br>4–load(载入)：用在线程的本地内存上，将read读取到本地内存的变量载入到本地内存的变量副本中(这里个人理解是载入到虚拟机栈(线程栈)的栈帧中的局部变量表中)<br>5–use(使用)：用在线程本地内存上，把本地内存的变量给执行引擎，每当需要使用这个变量的值字节码指令会执行这个操作(大白话就是使用变量);<br>6–assign(赋值)：用在线程本地内存上，把执行引擎获取到的值赋值本地内存的变量，每当需要使用这个变量的值字节码指令会执行这个操作(大白话就是给变量赋值)<br>7–store(存储)：用在本地内存上，将本地你内存中的变量的值存储到主内存中；<br>8–write(写入)：用在主内存上，把store操作从本年内存获取的值放入到主内存的变量中；<br>&nbsp;</p></li><li><h4 id="java内存模型操作的规则"><a href="#java内存模型操作的规则" class="headerlink" title="java内存模型操作的规则"></a><strong>java内存模型操作的规则</strong></h4><p>1–不允许<strong>read和load,store和write</strong>单独使用，需要组合使用;<br>2–不允许线程丢弃它assign过的变量，意思就是只要是变量在本地内存中变更了，就一定要同步到主线程中；<br>3–不允许线程在没有assign过变量，就将变量同步到主内存中，意思就是不允许线程在没有改变过变量的前提下，将变量store write到主内存中；<br>4–一个新的变量只能在主内存中诞生，意思就是在使用变量必须是从主内存read load下来的;(原文意思：对一个变量实施use，store之前，必须要执行过assign和load)<br>5–一个变量同一时间只可以让一个线程lock，并切可以让这个线程lock多次，但也需要unlock多次才可以解锁；<br>6–一个变量被线程lock时，线程的本地内存将会被清空，在使用变量的时候需要进行load或assign操作来初始化；<br>7–变量在为为lock的时候，不可以unlock，当然，也不可以unlock别的线程lock的变量；<br>8–对一个变量unlock之前，需要将assign过的变量都store，write到主内存中；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了Java内存模型丶Volatile和Synchronized的语义&lt;/p&gt;
    
    </summary>
    
      <category term="内存模型" scheme="https://www.lantaoblog.site/categories/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="内存模型" scheme="https://www.lantaoblog.site/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Srping源码之BeanFactory.getBean</title>
    <link href="https://www.lantaoblog.site/2019/03/01/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Srping%E6%BA%90%E7%A0%81%E4%B9%8BBeanFactory.getBean/"/>
    <id>https://www.lantaoblog.site/2019/03/01/Spring源码系列/Srping源码之BeanFactory.getBean/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-06-20T01:13:22.190Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对Srping的BeanFactory.getBean来进行源码解析,如果您是第一次看请先看一下XMLBeanFactory解析：<a href="https://blog.csdn.net/qq_30257149/article/details/87972291，" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/87972291，</a></p><a id="more"></a><p>可以更好的理解Spring的注册原理，本篇博客是跟源码一步步看spring怎么实现getBean源码，Spring版本为5.X,源码已经在每一行上加了注释，方便读者学习。**</p><blockquote><p>GItHub:<a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></p></blockquote><ul><li>废话不多说，我们直接看源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.lantao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-bean.xml"</span>);</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(classPathResource);</span><br><span class="line">        UserBean userBean = (UserBean) beanFactory.getBean(<span class="string">"userBean"</span>);</span><br><span class="line">        System.out.println(userBean.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>XMLBeanFactory解析就不多说了，如果没看过的可以去看我上一篇文章，这里直接看BeanFactory.getBean()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取实例名字</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">// 检查单例缓存中是否存在实例</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="comment">// 原型 循环引用 抛异常</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">// 将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存，以便重复创建指定的bean</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="comment">// 创建bean实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>doGetBean的源码比较长，那它都做了哪些事情呢：</p><p>1：转换对应的beanname，可能有很多人不理解，传入进来的不就应该是beanName嘛，其实传入的可能是BeanFactory，也可能是别名，如果是BeanFactory,就要去除它的修饰符，比如传入进来的&amp;aa，就要转换成aa，但如果传入进来的是别名，就要取alias对应的最终的beanName，例如别名A指向了B的bean则返回B的beanName，如果别名A指向了别名B，别名B指向了C,则要返回C的BeanName；</p><p>2：检查单例中是否存在实例，会先从缓存中获取，下面会详细讲解；</p><p>3：判断原型实例是否存在循环依赖，比如A中有B，B中有A，这种情况只有单例模式才会尝试去创建，因为单例模式会提早包曝光实例，存在缓存中，原型模式是不允许的，会抛出类正在创建异常；</p><p>4：通过父BeanFactory获取bean；</p><p>5：将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存</p><p>6：获取RootBeanDefinition，在XmlBeanFactory解析的时候会将bean注册到beanDefinitionMap中，这里就是在beanDefinitionMap中get，如果不存在则会抛出bean not found异常，同时会将GenericBeanDefinition转换成RootBeanDefinition，因为存入时时GenericBeanDefinition；</p><p>7：检查BeanDefinition是否是abstract，如果是则抛出，bean is Aastract异常；</p><p>8：检查依赖，保证该bean所以依赖的bean都已经初始化，首先这里要了解depends-on用来表示一个bean A的实例化依靠另一个bean B的实例化， 但是A并不需要持有一个B的对象，如果需要的话就不用depends-on；<a href="https://blog.csdn.net/qq_30257149/article/details/88350320" target="_blank" rel="noopener">不理解可以看这篇文章</a></p><p>9：判断bean的类型，是single还是proptotype，对应的创建bean，或者没有指定scope的判断，其中出现最多的方法就是getObjectForBeanInstance，后续会一点点的解析它的源码；</p></blockquote><ul><li>接下里我们先看单例缓存获取：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">//检查缓存中是否存在实例  isSingletonCurrentlyInCreation 该实例是否在创建中</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果缓存中实例为null 则锁定全局变量singletonObjects并进行处理</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">//尝试从earlySingletonObjects (创建中提早曝光的beanFactory) 获取bean</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">//尝试从singletonFactories获取beanFactory</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//返回获取到的bean</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">//增加缓存</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">//删除缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先单例是只允许创建一次，并且单例支持解决循环依赖，第一步会从<strong>singletonObjects</strong>Map中获取单例，如果发现不存在的话，再通过<strong>singletonsCurrentlyInCreation</strong>判断下当前bean是否在创建，如果是则从提前曝光的Map <strong>earlySingletonObjects</strong>中获取，如果依旧不能存在则在<strong>singletonFactories</strong>中获取BeanFactory，通过getBean进行返回，反之结束了，缓存没有，只能去重新创建了；</p></blockquote><ul><li>接下来看isPrototypeCurrentlyInCreation</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether the specified prototype bean is currently in creation</span></span><br><span class="line"><span class="comment"> * (within the current thread).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line"><span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里判断了原型实例是否存在循环依赖，比如A中有B，B中有A，这种情况只有单例模式才会尝试去创建，因为单例模式会提早包曝光实例，存在缓存中，原型模式是不允许的，会抛出类正在创建异常</p></blockquote><ul><li>markBeanAsCreated方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">// 将指定的bean标记为已经创建(或即将创建)。这允许bean工厂优化其缓存</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">markBeanAsCreated</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line"><span class="comment">// Let the bean definition get re-merged now that we're actually creating</span></span><br><span class="line"><span class="comment">// the bean... just in case some of its metadata changed in the meantime.</span></span><br><span class="line">clearMergedBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述源码中我们可以看到，这段代码的含义就是讲指定的bean标记为已经在创建或者即将创建；在clearMergedBeanDefinition方法中可以看到，如果没有标记bean正在创建则会删除BeanDefinnition，接下来会重新创建；</p></blockquote><ul><li>继续看getMergedLocalBeanDefinition源码:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a merged RootBeanDefinition, traversing the parent bean definition</span></span><br><span class="line"><span class="comment"> * if the specified bean corresponds to a child bean definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to retrieve the merged definition for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a (potentially merged) RootBeanDefinition for the given bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of an invalid bean definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在getBeanDefinition方法中，spring是直接从DefaultListAbleBeanFactory中的beanDefinitionMap获取注册时的BeanDefinition；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a RootBeanDefinition for the given bean, by merging with the</span></span><br><span class="line"><span class="comment"> * parent if the given bean's definition is a child bean definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bd the original bean definition (Root/ChildBeanDefinition)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingBd the containing bean definition in case of inner bean,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; in case of a top-level bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a (potentially merged) RootBeanDefinition for the given bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of an invalid bean definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line"><span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">BeanDefinition pbd;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line"><span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">BeanFactory parent = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line"><span class="string">"Parent name '"</span> + parentBeanName + <span class="string">"' is equal to bean name '"</span> + beanName +</span><br><span class="line"><span class="string">"': cannot be resolved without an AbstractBeanFactory parent"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Could not resolve parent bean definition '"</span> + bd.getParentName() + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">mbd.overrideFrom(bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line"><span class="comment">// Let's correct this on the fly here, since this might be the result of</span></span><br><span class="line"><span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line"><span class="comment">// definition will not have inherited the merged outer bean's singleton status.</span></span><br><span class="line"><span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">mbd.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line"><span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line"><span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在getMergedBeanDefinition方法中做了几件事情：</p><p>1：首先从缓存中mergedBeanDefinitions获取BeanDefinition</p><p>2：通过有参构造方法初始化RootBeanDefinition，这里的实例化涉及到一些参数的Set操作，具体代码就不展示了，在AbstractBeanDefinition的有参构造方法中；</p><p>3：指定bean的scope；</p><p>4：把RootBeanDefinition加入缓存mergedBeanDefinitions中；</p><p>在这里只是实例化就不多说了具体的DeBug一下就明白了，很简单；</p></blockquote><ul><li>我们继续看checkMergedBeanDefinition方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given merged bean definition,</span></span><br><span class="line"><span class="comment"> * potentially throwing validation exceptions.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the arguments for bean creation, if any</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of validation failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkMergedBeanDefinition</span><span class="params">(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.isAbstract()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsAbstractException(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>checkMergedBeanDefinition方法是判断BeanDefinition是否是Abstract，如果是则抛出beanIsAbstractException，这里就不过多解释了,学过java的都懂；</p></blockquote><ul><li>接下来就要看当前Bean的依赖，需要先实例化依赖：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"><span class="comment">// 保证当前bean所依赖的bean的初始化。</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个方法中，如果当前Bean是有依赖的话就会先去GetBean他的依赖，保证当前bean的所有依赖都是初始化过可用的，getBean大家都不陌生吧，就是BeanFactory的getBean；</p></blockquote><ul><li>下面我们看bean的创建流程singleton:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="comment">// 创建bean实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码就是创建Bean的一个主方法，首先是调用了getSingleton，接着又用lambda执行了createBean方法，紧着这又调用了getObjectForBeanInstance方法；</p></blockquote><ul><li>先来看createBean再看getSingleton方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">// 锁定class根据class 属性或者className 来解析class</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 方法注入准备</span></span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// 给BeanPostProcessors一个返回代理而不是目标bean实例的机会</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 实例化 创建</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line"><span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码做了什么：</p><p>1：解析class，如果BeanDefinition中存在beanClass，则直接返回，反之需要通过ClassLoader加载，代码就不发了，可自行看源码；</p><p>2：方法注入，<a href="https://blog.csdn.net/qq_30257149/article/details/87982391" target="_blank" rel="noopener">就是lookup-method的注入注入方式，这里就不多赘述了，可看上一遍文章；</a></p><p>3：spring的原文解释是给BeanPostProcessors一个返回代理而不是目标bean实例的机会，这里涉及Aop的代理，后续文章会详细解释；</p><p>4：调用doCreateBean进行创建，我们直接看doCreateBean方法：</p></blockquote><ul><li>doCreateBean方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking  &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//使用对应的策略创建实例  比如工厂</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">// 是否需要提前暴露， 单例&amp;允许循环依赖&amp;当前bean正在创建中  singletonsCurrentlyInCreation在DefaultSingletonBeanRegistry 225行创建，在创建bean之前记录 正在创建bean</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在bean未实例化之前加入到缓存中，单例支持循环依赖</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 对bean进行补充，属性注入，bean依赖</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">//调用初始化方法</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//earlySingletonReference 再有在检查循环依赖的时候才不为空</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中描述了创建bean的流程但是真正的createBean还不是在这个方法，在createBeanInstance中，我们先看看CreateBeann方法都做了什么：</p><p>1：使用对应的策略创建实例 createBeanInstance方法；</p><p>2：判断是否提前暴露，条件是（ 单例&amp;允许循环依赖&amp;当前bean正在创建中  singletonsCurrentlyInCreation在DefaultSingletonBeanRegistry 225行创建，在创建bean之前记录 正在创建bean），如果需要则调用addSingletonFactory方法在bean未实例化之前加入到缓存中，单例支持循环依赖；</p><p>3：对bean进行补充，属性注入，bean依赖；对ByName，ByType依赖进行初始化并注册依赖Bean；</p><p>4：调用初始化方法；</p><p>5：对依赖处理；</p></blockquote><ul><li>看一下createBeanInstance方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance for the specified bean, using an appropriate instantiation strategy:</span></span><br><span class="line"><span class="comment"> * factory method, constructor autowiring, or simple instantiation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #obtainFromSupplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="comment">// 解析class</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">//确保class不为空，并且访问权限为public</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置的一种特殊的callback回调方法，通过这个callback创建bean</span></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果工厂方式不为空，则使用功能工厂方式进行解析</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器</span></span><br><span class="line"><span class="comment">// 在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，避免再次创建相同bean时再次解析</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">//判断构造器或工厂方法是否为null</span></span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//已经解析过class的构造器</span></span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">//构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//使用默认构造器</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要根据参数解析、确定构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line"><span class="comment">// 默认构造的首选构造器？</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="comment">// 使用默认构造器</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述方法：</p><p>1：解析class；</p><p>2：如果存在 Supplier 回调，则调用 obtainFromSupplier() 进行初始化，如果不等于null就直接返回；</p><p>3：如果工厂方式不为空，则使用功能工厂方式进行解析；</p><p>4：构造函数自动注入 autowireConstructor</p><p>5：默认构造器 instantiateBean</p></blockquote><ul><li>我们先看看 Supplier回调的使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置的一种特殊的callback回调方法，通过这个callback创建bean</span></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a bean instance from the given supplier.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instanceSupplier the configured supplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the corresponding bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getObjectForBeanInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">obtainFromSupplier</span><span class="params">(Supplier&lt;?&gt; instanceSupplier, String beanName)</span> </span>&#123;</span><br><span class="line">Object instance;</span><br><span class="line"></span><br><span class="line">String outerBean = <span class="keyword">this</span>.currentlyCreatedBean.get();</span><br><span class="line"><span class="keyword">this</span>.currentlyCreatedBean.set(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">instance = instanceSupplier.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (outerBean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.currentlyCreatedBean.set(outerBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.currentlyCreatedBean.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(instance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span></span><br><span class="line"><span class="comment"> * time the supplier is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Supplier就一个get方法，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 <code>setter</code> 方法，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstanceSupplier</span><span class="params">(@Nullable Supplier&lt;?&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.instanceSupplier = instanceSupplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法是AbsTractBeanDefinition类中的方法，在初始化RootBeanDefinition的时候会调用该方法；在源码的protected AbstractBeanDefinition(BeanDefinition original) 方法中；</p></blockquote><ul><li>下面开始解析工厂模式实例化Bean，后边还有构造函数和默认构造的实例方法…..累</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 BeanWrapperImpl</span></span><br><span class="line">BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line"><span class="comment">//初始化 BeanWrapperImpl</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">Object factoryBean;</span><br><span class="line">Class&lt;?&gt; factoryClass;</span><br><span class="line"><span class="keyword">boolean</span> isStatic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取工厂Bean 这里使用FactoryBean 县实例化 FactoryBean</span></span><br><span class="line"><span class="comment">// 工厂名称不为空 如下处理</span></span><br><span class="line">String factoryBeanName = mbd.getFactoryBeanName();</span><br><span class="line"><span class="keyword">if</span> (factoryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"factory-bean reference points back to the same bean definition"</span>);</span><br><span class="line">&#125;</span><br><span class="line">factoryBean = <span class="keyword">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ImplicitlyAppearedSingletonException();</span><br><span class="line">&#125;</span><br><span class="line">factoryClass = factoryBean.getClass();</span><br><span class="line">isStatic = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 工厂名为空，则其可能是一个静态工厂</span></span><br><span class="line"><span class="comment">// It's a static factory method on the bean class.</span></span><br><span class="line"><span class="comment">// 这里使用Factory-method  factory-metohd 无需调用功能工厂类实例下就可以调用工厂功法 但非static不可以 需要调用上边的</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"bean definition declares neither a bean class nor a factory-bean reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line">factoryBean = <span class="keyword">null</span>;</span><br><span class="line">factoryClass = mbd.getBeanClass();</span><br><span class="line">isStatic = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用的工厂方法</span></span><br><span class="line">Method factoryMethodToUse = <span class="keyword">null</span>;</span><br><span class="line">ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//要使用的工厂参数</span></span><br><span class="line">Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法的参数</span></span><br><span class="line"><span class="comment">// 如果指定了构造参数则直接使用</span></span><br><span class="line"><span class="comment">// 在调用 getBean 方法的时候指定了方法参数</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 没有指定，则尝试从配置文件中解析</span></span><br><span class="line">Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">// 获取构造函数或工厂方法</span></span><br><span class="line">factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// 获取构造参数</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取构造函数参数的包可见字段</span></span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 缓存中存在,则解析存储在 BeanDefinition 中的参数</span></span><br><span class="line"><span class="comment">// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的("1","1")转换为 (1,1)</span></span><br><span class="line"><span class="comment">// 缓存中的值可能是原始值也有可能是最终值</span></span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Need to determine the factory method...</span></span><br><span class="line"><span class="comment">// Try all methods with this name to see if they match the given arguments.</span></span><br><span class="line"><span class="comment">// 需要确定工厂的方法.尝试所有具有此名称的方法，以查看它们是否与给定的参数匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取工厂方法的类全名称</span></span><br><span class="line">factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索所有方法，这里是对方法进行过滤</span></span><br><span class="line">Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);</span><br><span class="line">List&lt;Method&gt; candidateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line"><span class="comment">// 如果有static 且为工厂方法，则添加到 candidateSet 中</span></span><br><span class="line"><span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">candidateList.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果静态方法就一个 &amp; getBean参数null &amp; 没有构造参数值 直接初始化返回</span></span><br><span class="line"><span class="keyword">if</span> (candidateList.size() == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">Method uniqueCandidate = candidateList.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">mbd.factoryMethodToIntrospect = uniqueCandidate;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method[] candidates = candidateList.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 排序构造函数</span></span><br><span class="line"><span class="comment">// public 构造函数优先参数数量降序，非public 构造函数参数数量降序</span></span><br><span class="line">AutowireUtils.sortFactoryMethods(candidates);</span><br><span class="line"></span><br><span class="line">ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">Set&lt;Method&gt; ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minNrOfArgs;</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We don't have arguments passed in programmatically, so we need to resolve the</span></span><br><span class="line"><span class="comment">// arguments specified in the constructor arguments held in the bean definition.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 BeanDefinition中有没有构造参数值</span></span><br><span class="line"><span class="comment">// getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line"><span class="comment">// 获取构造参数值</span></span><br><span class="line">ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line"><span class="comment">// 解析构造函数的参数</span></span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">minNrOfArgs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环方法找到 匹配的那个</span></span><br><span class="line"><span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法参数</span></span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) &#123;</span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line"><span class="comment">// getbean给的参数</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line"><span class="comment">// 参数不匹配 方法略过</span></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据参数创建参数持有者</span></span><br><span class="line">argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String[] paramNames = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 获取 ParameterNameDiscoverer 对象</span></span><br><span class="line"><span class="comment">// ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器</span></span><br><span class="line">ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取指定构造函数的参数名</span></span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在已经解析的构造函数参数值的情况下，创建一个参数持有者对象</span></span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,</span><br><span class="line">paramTypes, paramNames, candidate, autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignoring factory method ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next overloaded factory method.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span></span><br><span class="line"><span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span><br><span class="line"><span class="comment">// 宽松模式：使用具有"最接近的模式"进行匹配</span></span><br><span class="line"><span class="comment">// typeDiffWeight：类型差异权重</span></span><br><span class="line"><span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this factory method if it represents the closest match.</span></span><br><span class="line"><span class="comment">//  代表最接近的类型匹配，则选择作为构造函数</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">factoryMethodToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find out about ambiguity: In case of the same type difference weight</span></span><br><span class="line"><span class="comment">// for methods with the same number of parameters, collect such candidates</span></span><br><span class="line"><span class="comment">// and eventually raise an ambiguity exception.</span></span><br><span class="line"><span class="comment">// However, only perform that check in non-lenient constructor resolution mode,</span></span><br><span class="line"><span class="comment">// and explicitly ignore overridden methods (with the same parameter signature).</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">!mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;</span><br><span class="line">!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousFactoryMethods == <span class="keyword">null</span>) &#123;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousFactoryMethods.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有可执行的工厂方法，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; argTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">argTypes.add(arg != <span class="keyword">null</span> ? arg.getClass().getSimpleName() : <span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">Set&lt;ValueHolder&gt; valueHolders = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line"><span class="keyword">for</span> (ValueHolder value : valueHolders) &#123;</span><br><span class="line">String argType = (value.getType() != <span class="keyword">null</span> ? ClassUtils.getShortName(value.getType()) :(value.getValue() != <span class="keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="string">"null"</span>));</span><br><span class="line">argTypes.add(argType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"No matching factory method found: "</span> +</span><br><span class="line">(mbd.getFactoryBeanName() != <span class="keyword">null</span> ?</span><br><span class="line"><span class="string">"factory bean '"</span> + mbd.getFactoryBeanName() + <span class="string">"'; "</span> : <span class="string">""</span>) +</span><br><span class="line"><span class="string">"factory method '"</span> + mbd.getFactoryMethodName() + <span class="string">"("</span> + argDesc + <span class="string">")'. "</span> +</span><br><span class="line"><span class="string">"Check that a method with the specified name "</span> +</span><br><span class="line">(minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">"and arguments "</span> : <span class="string">""</span>) +</span><br><span class="line"><span class="string">"exists and that it is "</span> +</span><br><span class="line">(isStatic ? <span class="string">"static"</span> : <span class="string">"non-static"</span>) + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">void</span>.class == factoryMethodToUse.getReturnType()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Invalid factory method '"</span> + mbd.getFactoryMethodName() +</span><br><span class="line"><span class="string">"': needs to have a non-void return type!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousFactoryMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Ambiguous factory method matches found in bean '"</span> + beanName + <span class="string">"' "</span> +</span><br><span class="line"><span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +</span><br><span class="line">ambiguousFactoryMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 指定工厂方法</span></span><br><span class="line">mbd.factoryMethodToIntrospect = factoryMethodToUse;</span><br><span class="line"><span class="comment">// 将解析的构造函数加入缓存</span></span><br><span class="line">argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">"Unresolved factory method arguments"</span>);</span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述这段代码，怎么说呢，为什么都写一起，为什么不分方法写，每个方法明确干什么，看这个方法需要毅力，读者好好看……. 先来看看这个方法都做了啥：</p><p>1：首先实例化 BeanWrapperImpl</p><p>2：初始化BeanWrapperImpl</p><p>3：获取FactoryBean Name，看这里之前读者如果不了解<a href="https://blog.csdn.net/qq_30257149/article/details/88036692" target="_blank" rel="noopener">factory-bean和factory-mothod请点击</a>，在这里会判断factoryBeannName是否为null，如果不是则初始化工厂bean，<strong>代码体现在factoryBean = this.beanFactory.getBean(factoryBeanName)</strong>这里，否则一定是一个static修饰的工厂方法，直接调用即可；</p><p>4：缓存中获取构造或工厂方法，构造参数，在线解释一下：；</p><ul><li>constructorArgumentLock：构造缓存使用的锁；</li><li>resolvedConstructorOrFactoryMethod：构造函数或工厂方法；</li><li>resolvedConstructorArguments：构造参数</li></ul><p>如果缓存中存在，则需要调用 <code>resolvePreparedArguments()</code> 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。</p><p>5：如果缓存中或上送的参数没有则需要解析了，需要通过反射获取所有方法，如果获取的符合条件的static的方法就一个，并且还没有构造方法参数，则直接初始化返回；代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果静态方法就一个 &amp; getBean参数null &amp; 没有构造参数值 直接初始化返回</span></span><br><span class="line"><span class="keyword">if</span> (candidateList.size() == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">Method uniqueCandidate = candidateList.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">mbd.factoryMethodToIntrospect = uniqueCandidate;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6:如果显示提供了参数（explicitArgs != null）,则直接使用，反之需要获取ConstructorArgumentValues值，并且解析构造函数，这里比较复杂，建议读者debug；</p><p>7：循环匹配，直到找到匹配的构造函数；如果找不到则抛出异常，无可用函数；代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环方法找到 匹配的那个</span></span><br><span class="line"><span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法参数</span></span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) &#123;</span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line"><span class="comment">// getbean给的参数</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line"><span class="comment">// 参数不匹配 方法略过</span></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据参数创建参数持有者</span></span><br><span class="line">argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String[] paramNames = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 获取 ParameterNameDiscoverer 对象</span></span><br><span class="line"><span class="comment">// ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器</span></span><br><span class="line">ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取指定构造函数的参数名</span></span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在已经解析的构造函数参数值的情况下，创建一个参数持有者对象</span></span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,</span><br><span class="line">paramTypes, paramNames, candidate, autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignoring factory method ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next overloaded factory method.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式</span></span><br><span class="line"><span class="comment">// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常</span></span><br><span class="line"><span class="comment">// 宽松模式：使用具有"最接近的模式"进行匹配</span></span><br><span class="line"><span class="comment">// typeDiffWeight：类型差异权重</span></span><br><span class="line"><span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this factory method if it represents the closest match.</span></span><br><span class="line"><span class="comment">//  代表最接近的类型匹配，则选择作为构造函数</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">factoryMethodToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find out about ambiguity: In case of the same type difference weight</span></span><br><span class="line"><span class="comment">// for methods with the same number of parameters, collect such candidates</span></span><br><span class="line"><span class="comment">// and eventually raise an ambiguity exception.</span></span><br><span class="line"><span class="comment">// However, only perform that check in non-lenient constructor resolution mode,</span></span><br><span class="line"><span class="comment">// and explicitly ignore overridden methods (with the same parameter signature).</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">!mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;</span><br><span class="line">!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousFactoryMethods == <span class="keyword">null</span>) &#123;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousFactoryMethods.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有可执行的工厂方法，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; argTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">argTypes.add(arg != <span class="keyword">null</span> ? arg.getClass().getSimpleName() : <span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">Set&lt;ValueHolder&gt; valueHolders = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line"><span class="keyword">for</span> (ValueHolder value : valueHolders) &#123;</span><br><span class="line">String argType = (value.getType() != <span class="keyword">null</span> ? ClassUtils.getShortName(value.getType()) :</span><br><span class="line">(value.getValue() != <span class="keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="string">"null"</span>));</span><br><span class="line">argTypes.add(argType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"No matching factory method found: "</span> +</span><br><span class="line">(mbd.getFactoryBeanName() != <span class="keyword">null</span> ?</span><br><span class="line"><span class="string">"factory bean '"</span> + mbd.getFactoryBeanName() + <span class="string">"'; "</span> : <span class="string">""</span>) +</span><br><span class="line"><span class="string">"factory method '"</span> + mbd.getFactoryMethodName() + <span class="string">"("</span> + argDesc + <span class="string">")'. "</span> +</span><br><span class="line"><span class="string">"Check that a method with the specified name "</span> +</span><br><span class="line">(minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">"and arguments "</span> : <span class="string">""</span>) +</span><br><span class="line"><span class="string">"exists and that it is "</span> +</span><br><span class="line">(isStatic ? <span class="string">"static"</span> : <span class="string">"non-static"</span>) + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>8：指定工厂那个方法，并且将解析的构造函数信息加入缓存中，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 指定工厂方法</span></span><br><span class="line">mbd.factoryMethodToIntrospect = factoryMethodToUse;</span><br><span class="line"><span class="comment">// 将解析的构造函数加入缓存</span></span><br><span class="line">argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeCache</span><span class="params">(RootBeanDefinition mbd, Executable constructorOrFactoryMethod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.resolveNecessary) &#123;</span><br><span class="line">mbd.preparedConstructorArguments = <span class="keyword">this</span>.preparedArguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mbd.resolvedConstructorArguments = <span class="keyword">this</span>.arguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>10：通过反射实例化Bean，源码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Object factoryBean, <span class="keyword">final</span> Method factoryMethod, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line"><span class="comment">// 利用反射</span></span><br><span class="line">Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">result = <span class="keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (priorInvokedFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">currentlyInvokedFactoryMethod.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod,</span><br><span class="line"><span class="string">"Illegal arguments to factory method '"</span> + factoryMethod.getName() + <span class="string">"'; "</span> +</span><br><span class="line"><span class="string">"args: "</span> + StringUtils.arrayToCommaDelimitedString(args), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod,</span><br><span class="line"><span class="string">"Cannot access factory method '"</span> + factoryMethod.getName() + <span class="string">"'; is it public?"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">String msg = <span class="string">"Factory method '"</span> + factoryMethod.getName() + <span class="string">"' threw exception"</span>;</span><br><span class="line"><span class="keyword">if</span> (bd.getFactoryBeanName() != <span class="keyword">null</span> &amp;&amp; owner <span class="keyword">instanceof</span> ConfigurableBeanFactory &amp;&amp;</span><br><span class="line">((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123;</span><br><span class="line">msg = <span class="string">"Circular reference involving containing bean '"</span> + bd.getFactoryBeanName() + <span class="string">"' - consider "</span> +</span><br><span class="line"><span class="string">"declaring the factory method as static for independence from its containing instance. "</span> + msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod, msg, ex.getTargetException());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述工厂模式实例化Bean写的不是很详细，尽量debug源码去一步步看才能理解，下面看构造器实例化autowireConstructor</li></ul><blockquote><p>工厂实例化和构造函数实例化这两个大方法都需要读者自己deBug，这样可更好的理解下面说一下都做了什么：</p><p>1：实例化BeanWrapperImpl</p><p>2：初始化BeanWrapperImpl</p><p>3：构造参数如果在getBean是传入则使用，反之需要从缓存中获取并解析参数类型：</p><ul><li>constructorArgumentLock：构造缓存使用的锁；</li><li>resolvedConstructorOrFactoryMethod：构造函数或工厂方法；</li><li>resolvedConstructorArguments：构造参数</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">&gt; <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">&gt; <span class="comment">//获取解析构造函数或工厂方法</span></span><br><span class="line">&gt; constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">&gt; <span class="comment">//构造函数或工厂方法不为空 &amp; 存在构造方法（函数）</span></span><br><span class="line">&gt; <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">&gt;     <span class="comment">// Found a cached constructor...</span></span><br><span class="line">&gt; argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">&gt; <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 配置构造函数参数</span></span><br><span class="line">&gt; argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 解析参数类型，比如构造方法是 A(int, int)，通过此方法将（"1"，"1"）转换为（1，1）</span></span><br><span class="line">&gt; argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="keyword">true</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>4：解析构造函数，如果中有上送，则使用，如果没有则从beanClass中获取，解析后加入缓存，代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 接受指定的构造函数(如果有的话)。.</span></span><br><span class="line">&gt; Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">&gt; <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 从class中获取</span></span><br><span class="line">&gt; Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; <span class="comment">// 从class获取构造器 判断是否是public</span></span><br><span class="line">&gt; candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">&gt; beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&gt; <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&gt; <span class="string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() +</span><br><span class="line">&gt; <span class="string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="string">"] failed"</span>, ex);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 构造参数value == null 直接返回</span></span><br><span class="line">&gt; <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">&gt; Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">&gt; <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">&gt; <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">&gt; <span class="comment">// 构造器或工厂方法</span></span><br><span class="line">&gt; mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">&gt; <span class="comment">//构造函数参数解析</span></span><br><span class="line">&gt; mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">&gt; <span class="comment">// 构造函数参数</span></span><br><span class="line">&gt; mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">&gt; <span class="keyword">return</span> bw;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 需要解析构造函数参数</span></span><br><span class="line">&gt; <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> ||</span><br><span class="line">&gt; mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">&gt; ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">&gt; <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; minNrOfArgs = explicitArgs.length;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">&gt; resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">&gt; <span class="comment">// 解析构造函数参数</span></span><br><span class="line">&gt; minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; AutowireUtils.sortConstructors(candidates);</span><br><span class="line">&gt; <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">&gt; Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">&gt; LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">&gt; <span class="comment">//获取构造方法参数类型</span></span><br><span class="line">&gt; Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">&gt; <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">&gt; <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">&gt; <span class="comment">// 如果已经找到了可用的构造函数或者需要的参数个数小于当前当前函数的个数则终止</span></span><br><span class="line">&gt; <span class="keyword">break</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">&gt; <span class="comment">//参数个数不相等</span></span><br><span class="line">&gt; <span class="keyword">continue</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; ConstructorResolver.ArgumentsHolder argsHolder;</span><br><span class="line">&gt; <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; <span class="comment">// 从注解上获取参数名称</span></span><br><span class="line">&gt; String[] paramNames = ConstructorResolver.ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line">&gt; <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 参数名称探索期</span></span><br><span class="line">&gt; ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">&gt; <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">//获取构造方法上的参数</span></span><br><span class="line">&gt; paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">&gt; getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">&gt; logger.trace(<span class="string">"Ignoring constructor ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">&gt; <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; causes.add(ex);</span><br><span class="line">&gt; <span class="keyword">continue</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; <span class="comment">// 无参构造</span></span><br><span class="line">&gt; <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">&gt; <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">&gt; <span class="keyword">continue</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; argsHolder = <span class="keyword">new</span> ConstructorResolver.ArgumentsHolder(explicitArgs);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 判断是否有不确定的构造</span></span><br><span class="line">&gt; <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">&gt; argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">&gt; <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">&gt; <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">&gt; constructorToUse = candidate;</span><br><span class="line">&gt; argsHolderToUse = argsHolder;</span><br><span class="line">&gt; argsToUse = argsHolder.arguments;</span><br><span class="line">&gt; minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&gt; ambiguousConstructors.add(constructorToUse);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; ambiguousConstructors.add(candidate);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">&gt; <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">&gt; <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">throw</span> ex;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&gt; <span class="string">"Could not resolve matching constructor "</span> +</span><br><span class="line">&gt; <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">&gt; <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">&gt; <span class="string">"Ambiguous constructor matches found in bean '"</span> + beanName + <span class="string">"' "</span> +</span><br><span class="line">&gt; <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +</span><br><span class="line">&gt; ambiguousConstructors);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// 加入缓存</span></span><br><span class="line">&gt; argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>5：实例化Bean，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="comment">// 如果没使用lookuo 或 replace 则直接使用反射创建</span></span><br><span class="line">&gt; <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">&gt; <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">&gt; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">&gt; ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 直接使用反射方式创建你</span></span><br><span class="line">&gt; <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote><ul><li>下面说一下默认构造器instantiateBean实例化Bean：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取clazz</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取公共构造器</span></span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化class</span></span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码是使用默认构造器实例化Bean的代码，这里我就不多赘述了，使用工厂模式和构造参数实例化Bean的代码都看过了，这里就很容易理解了；下面我们接着流程说getSingleton方法：</p></blockquote><ul><li>getSingleton方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name,</span></span><br><span class="line"><span class="comment"> * creating and registering a new one if none registered yet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonFactory the ObjectFactory to lazily create the singleton</span></span><br><span class="line"><span class="comment"> * with, if necessary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="comment">// 加锁，全局变量需要同步</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">//查看单例bean是否创建国如果有直接使用</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录加载状态 书中 99页</span></span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除加载状态</span></span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们直接说这个方法干了什么事情吧，如下：</p><p>1：首先是全局锁singletonObjects；</p><p>2：查看缓存中是否存在，如果有则判断获取的Bean是否在销毁阶段；</p><p>3：使用singletonsCurrentlyInCreation记录加载状态；</p><p>4：使用createBean方法返回的ObjectFactory获取bean，并指定这次创建是一个新的单例；</p><p>5：在singletonsCurrentlyInCreation中删除加载状态；</p><p>6：增加缓存，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Add the given singleton object to the singleton cache of this factory.</span></span><br><span class="line"><span class="comment">&gt;  * &lt;p&gt;To be called for eager registration of singletons.</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> singletonObject the singleton object</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">&gt; <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">&gt; <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&gt; <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">&gt; <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>接下来就看一看getBean调用最多的方法getObjectForBeanInstance：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the object for the given bean instance, either the bean</span></span><br><span class="line"><span class="comment"> * instance itself or its created object in case of a FactoryBean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanInstance the shared bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name name that may include factory dereference prefix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the canonical bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object to expose for the bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line"><span class="comment">// 如果指定的name是工厂相关的（&amp;前缀），并且beanInstance又不是FactoryBean类 则验证不通过</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line"><span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line"><span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line"><span class="comment">//如果我们有了个bean的实例，这个实例可能是bean可能是beanfactory，如果是FactoryBean我们使用它去创建实例，但是如果用户想要直接获取工厂实例而不是工厂的getObject方法所对应的实例，</span></span><br><span class="line"><span class="comment">//那么传入的name应该加前缀&amp;</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//尝试从缓存中加载实例</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Return bean instance from factory.</span></span><br><span class="line"><span class="comment">// beanInstance一定是FactoryBean了</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="comment">//在beanDefinitionMap 获取beanDefition ,beanDefinitionMap是注册时候的Map</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 将xml解析时存入的GernericBeanDefinition 转换成 RootBeanDefinition</span></span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否是用户定义而不是应用程序本身定义</span></span><br><span class="line"><span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码有两个判断：</p><p>1：如果指定的name是工厂相关的（&amp;前缀），并且beanInstance类型不是FactoryBean则抛出BeanIsNotAFactoryBean异常；</p><p>2：如果beanInstance不是FactoryBean 或者 指定的name是工厂相关的（&amp;前缀）则直接返回beanInstance;</p><p>这两个条件可以好好理解下，第一个应该没问题，如果指定的是工厂相关的，并且beanInstance类是不是FactoryBean则抛出异常，第二个就可以理解beanInstance如果不是FactoryBean就直接返回， 并且第二个条件的BeanFactoryUtils.isFactoryDereference(name)永远都不会是true，因为如果这一条件成立，则第一个条件则通不过会直接抛出异常，那么下边的代码就是在处理beanInstrace是BeanFactory，但是传入的name不是&amp;name；</p><p>3：下面的代码就很简单了，mbd这个参数不会为null，只有在获取缓存的时候会是null，这里就不做多解释了，直接将BeanInstance类型强转成FactoryBean<t>，然后调用getObjectFromFactoryBean方法进行getObject返回；</t></p><p>4：FactoryBean不理解的可以看一下这篇文章，有例子：<a href="https://blog.csdn.net/qq_30257149/article/details/88028924" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/88028924</a></p></blockquote><p>总结</p><hr><blockquote><p><strong>总结一下</strong>，在getSinngnleton中不断的使用缓存就是因为是单例的不允许重复创建，说一下重点：</p><p>1：如果是单例则先从缓存中获取，没有在调用getSingleton方法创建；</p><p>2：检查bean是否是abstract</p><p>3：保证当前bean所依赖的bean的初始化，如果没有先初始化依赖；</p><p>4：获取BeanDefinition，BeanDefinition是在注册的时候实例化然后存入缓存的，这里直接取过来做一下类型转换即可；</p><p>5：如果是单例则调用getSingleton方法，如果是原型则调用isPrototype下面的代码块，如果都不是的话使用默认创建（原型）；</p><p>6：在bean创建前后会使用singletonsCurrentlyInCreation或prototypesCurrentlyInCreation标记类是否正在创建中，给后续判断使用；</p><p>7：bean实例化的方式，在创建实例之前做了一个判断，如果有则通过InstanceSupplier.et方法直接返回，工厂方法实例化(instantiateUsingFactoryMethod)，构造器实例化(autowireConstructor)，默认构造器实例化(instantiateBean)，这里是读者需要看源码的的重点，</p><p>8：bean在创建前会提前暴露实例并增加缓存，保证如果有别人依赖可以直接从缓存你中取，解决循环依赖问题；</p><p>9：对bean的赋值属性的注入(populateBean方法)；</p><p>10：调用初始化方法，initializeBean；</p><p>对于9和10在代码中没有做详细的讲解，但是在源码中做了一些注释，可以自行debug看一下很简单，主要是太多了，早知道就分开写了，很累…. 不知道作为读者的你能否能看下去；</p></blockquote><p>码字不易，转你发请注明出处：<a href="https://mp.csdn.net/postedit/88016361" target="_blank" rel="noopener">https://mp.csdn.net/postedit/88016361</a></p><p>博客地址：<a href="https://lantaogithub.github.io" target="_blank" rel="noopener">https://lantaogithub.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对Srping的BeanFactory.getBean来进行源码解析,如果您是第一次看请先看一下XMLBeanFactory解析：&lt;a href=&quot;https://blog.csdn.net/qq_30257149/article/details/87972291，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_30257149/article/details/87972291，&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/categories/spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="XMLBeanFactory" scheme="https://www.lantaoblog.site/tags/XMLBeanFactory/"/>
    
      <category term="getBean" scheme="https://www.lantaoblog.site/tags/getBean/"/>
    
  </entry>
  
  <entry>
    <title>Srping源码之XMLBeanFactory</title>
    <link href="https://www.lantaoblog.site/2019/02/27/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/String%E6%BA%90%E7%A0%81%E4%B9%8BXmlBeanFactory/"/>
    <id>https://www.lantaoblog.site/2019/02/27/Spring源码系列/String源码之XmlBeanFactory/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-06-20T01:10:55.042Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对Srping的XMLBeanFactory来进行解析xml并将解析后的信息使用GenericBeanDefinition作为载体进行注册,xmlBeanFactory已经在Spring 3.1中被标记为不建议使用，但是我们分析源码不影响，因为源码并未改变，</p><a id="more"></a><p>并ApplicationContext依旧使用XmlBeanDefinitionReader和DefaultListableBeanFactory进行xml的解析和注册工作，本篇博客是跟源码一步步看spring怎么实现bean的注册，源码为spring5.X,源码已经在每一行上加了注释，方便读者学习。</p><blockquote><p><strong>GitHub:</strong><a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></p></blockquote><ul><li>首先我们从XMLBeanFactory入手,直接上代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.lantao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 资源加载</span></span><br><span class="line">        ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-bean.xml"</span>);</span><br><span class="line">        <span class="comment">// XmlBeanFactory 加载资源并解析注册bean</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(classPathResource);</span><br><span class="line">        <span class="comment">// BeanFactory.getBean();</span></span><br><span class="line">        UserBean userBean = (UserBean) beanFactory.getBean(<span class="string">"userBean"</span>);</span><br><span class="line">        System.out.println(userBean.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>XmlBeanFactory解析Xml是使用了XmlBeanDefinitionReader.loadBeanDefinition()方法,源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"serial"</span>, <span class="string">"all"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment"> * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//调用构造方法  79行</span></span><br><span class="line"><span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment"> * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//ignoreDependencyInterface 忽略自动装配</span></span><br><span class="line"><span class="comment">//主要功能就是当有忽略的接口类，自动装配会忽略这部分类的初始化装配，因为某种情况下，此时的接口实现类不能初始化，列如BeanNameAware,要想装配这个接口的实现对象，可以实现这个接口。</span></span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line"><span class="comment">//这段代码是真正的资源加载</span></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们直接看loadBeanDefinition方法，源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// 对EncodedResource进行封装，设置String encoding, Charset charset</span></span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment"> * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//encodedResource 不可以为空</span></span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过属性来记录已经加载的资源</span></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从encodedResource已经封装的Resource获取InputStream</span></span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//InputSource 并不是spring的，而是 org.xml.sax</span></span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="comment">//如果encodedResource 中的 Encoding 不是 null 则同步设置 InputSource的 Encoding</span></span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载bean的Definitions 将xml中的信息加载到Definition中，并且在内存中注册的也是key+definitions</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述源码可能看着比较长,但实际上这里并不是真正解析的地方，在这里做了如下：</p><p>1:从encodedResource已经封装的Resource获取InputStream；</p><p>2:如果encodedResource 中的 Encoding 不是 null 则同步设置 InputSource的 Encoding；</p><p>3:将解析动作委托给doLoadBeanDefinitions实现；</p></blockquote><ul><li>接下来我们继续看doLoadBeanDefinitions方法内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//加载 Document</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">//注册 bean</span></span><br><span class="line"><span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们看着这个方法的时候，依旧不是真正的解析或注册的方法，在这里只是做了Document的加载，并将后续工作委托给了registerBeanDefinitions,registerBeanDefinitions方法的返回时注册Bean的个数；</p></blockquote><ul><li>我们继续看registerBeanDefinitions的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the bean definitions contained in the given DOM document.</span></span><br><span class="line"><span class="comment"> * Called by &#123;<span class="doctag">@code</span> loadBeanDefinitions&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Creates a new instance of the parser class and invokes</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> registerBeanDefinitions&#125; on it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor (for context information)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentReaderClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanDefinitionDocumentReader#registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//实例化 BeanDefinitionDocumentReader</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">//获取之前的beanDefinition加载个数</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//加载xml及注册bean</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="comment">//记录本次加载个数</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在registerBeanDefinitions方法具体实现：</p><p>1：通过BeanUtils.instantiateClass(this.documentReaderClass)的方法实例化BeanDefinitionDocumentReader；</p><p>2：通过DefaultListAbleBeanFactory中的beanDefinitionMap.size()获取之前注册bean的个数，（beanDefinitionMap是存储最终的xml解析后信息的载体，xml解析后信息是由GenericBeanDefinition进行存储，beanDefinitionMap的存储格式是key:String  value:GenericBeanDefinition）</p><p>3:将解析xml和注册的工作委托给BeanDefinitionDocumentReader的registerBeanDefinitions方法；</p><p>4：记录本次加载个数并返回；</p></blockquote><ul><li>继续看BeanDefinitionDocumentReader的registerBeanDefinitions方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the "spring-beans" XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化 ReaderContext</span></span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line">doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>registerBeanDefinitions并没有做什么，我们继续看doRegisterBeanDefinitions方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">//获取Attribute</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析前处理， 内容null 留个子类实现</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="comment">//解析后处理， 内容null 留个子类实现</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在doRegisterBeanDefinitions烦那个发中验证xml的namespace,最重要的方法是parseBeanDefinitions，parseBeanDefinitions方法进行了解析操作；</p></blockquote><ul><li>parseBeanDefinitions方法的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//验证xml namespace, BeanDefinitionParserDelegate.BEANS_NAMESPACE_URI</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">//对默认标签处理</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//对自定义标签处理</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//对自定义标签处理</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>parseBeanDefinitions方法中已经开始对标签进行解析，区分默认标签和自定义标签，我们本次只对默认标签的源码进行解析，自定义标签自行DeBug，</p></blockquote><ul><li>parseDefaultElement方法的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">//解析import标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析alias标签并注册</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析bean标签并注册</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析beans标签</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里我们可以看到，spring对import/bean/alias/beans的解析过程，对于beans的解析无法就是解析beans中的bean标签，spring直接又重新调用了doRegisterBeanDefinitions方法，我们接下来进行对bean标签的解析；</p></blockquote><ul><li>processBeanDefinition方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析并返回</span></span><br><span class="line"><span class="comment">//BeanDefinitionHolder实例，BeanDefinitionHolder已经包含了配置文件中的各种属性</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="comment">//当BeanDefinitionHolder返回不null的情况，弱存在默认标签下的子标签再有自定义的属性，还需要再次解析</span></span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//解析默认标签中的自定义标签</span></span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">// 进行实例注册注册操作是BeanDefinitionReaderUtisl.registerBeanDefinition进行处理</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在processBeanDefinition方法中，spring做了两件事情：</p><p>1：委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析并返回BeanDefinitionHolder实例，BeanDefinitionHolder已经包含了配置文件中的各种属性</p><p>2：通过上获得的BeanDefinitionHolder进行bean的注册操作，通BeanDefinitionReaderUtils.registerBeanDefinition方法；</p></blockquote><ul><li>通过delegate.parseBeanDefinitionElement方法进行xml解析：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> &lt;bean&gt;&#125; element. May return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * if there were errors during parse. Errors are reported to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"><span class="comment">//解析id属性</span></span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"><span class="comment">//解析name属性</span></span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割name属性</span></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line"><span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将信息封装到 beanDefinition中</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//beanname不存在则使用默认规则创建</span></span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line"><span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在parseBeanDefinitionElement方法中做了三件事：</p><p>1：解析id/name；</p><p>2：检查name的唯一性；</p><p>3：将信息封装到 beanDefinition中，接下来直接看parseBeanDefinitionElement方法；</p></blockquote><ul><li>parseBeanDefinitionElement源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the bean definition itself, without regard to name or aliases. May return</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; if problems occurred during the parsing of the bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//解析classname属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//解析parent属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建用于承载属性的AbstractBeanDefinition类型的</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析bean的各种属性</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line"><span class="comment">//提取description</span></span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析meta （元数据）</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析Lookup-method 书中53页有使用方法</span></span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"><span class="comment">//解析replaced-method 书中55页有使用方法</span></span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 参数</span></span><br><span class="line"><span class="comment">//解析constructor-arg 书中replaced-method后边</span></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line"><span class="comment">//解析Property 书中replaced-method后边</span></span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line"><span class="comment">//解析Qualifier 书中Property后边</span></span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上述代码我们可以看到这里首先是实例化了一个AbstractBeanDefinition来承载各种xml属性，接下来通过<strong>parseBeanDefinitionAttributes</strong>方法解析了xml中的各种你属性值，然后在解析<strong>lookUp-method(方法注入)</strong>，<strong>replaced-method(替换方法或方法返回值)</strong>，构造函数参数<strong>constructor-arg</strong>，<strong>property</strong>属性，<strong>Qualifier</strong>属性等；上述方法的源码就不一一展示了，无非都是通过Element进行解析；</p></blockquote><ul><li>接下来看真正注册的代码    BeanDefinitionReaderUtils.registerBeanDefinition</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//beanName不可为空</span></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line"><span class="comment">//beanDefinition不可为空</span></span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//校验 MethodOverrides，MethodOverrides在解析并组装beanDefinition时有提到</span></span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//beanDefinitionMap 存储实例的全局Map 使用ConcurrentHashMap 线程安全</span></span><br><span class="line">BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="comment">//如果已经注册 处理内容</span></span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//是否覆盖</span></span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//判断是否已经至少创建过一次 使用AbstractBeanFactory.alreadyCreated来判断</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 仍处于启动注册阶段</span></span><br><span class="line"><span class="comment">// 注册 beanDefinitionMap 新实例 beanName + beanDefinition</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="comment">// 增加beanDefinitionNames</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="comment">// 清除缓存</span></span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除缓存</span></span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中首先验证了beanName和BeannDefinition不可为空,然后继续校验了MethodOverridesMethodOverrides在解析并组装beanDefinition时lookup-method和recpse-method的源码中有提到，继续判断beanDefinitionMap是否存在该bean，如果bean已经存在，通过allowBeanDefinitionOverriding属性判断是否可覆盖，反之则抛出异常；如果不存在则需要判断本次是否是第一次注册bean，如果是则初始化beanDefinitionMap后进行put操作，反之直接put beanDefinitionMap完成注册；</p></blockquote><p>至此我们已经看完了整个XmlBeanFactory的xml解析和注册的源码部分，相信看本篇文章无法真正理解，还需要读者下载源码使用debug运行，再结合本篇文章的注释，相信会很容易理解，码字不易，转发请注明出处：<a href="https://blog.csdn.net/qq_30257149/article/details/87972291" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/87972291</a></p><p>博客地址：<a href="https://lantaogithub.github.io" target="_blank" rel="noopener">https://lantaogithub.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对Srping的XMLBeanFactory来进行解析xml并将解析后的信息使用GenericBeanDefinition作为载体进行注册,xmlBeanFactory已经在Spring 3.1中被标记为不建议使用，但是我们分析源码不影响，因为源码并未改变，&lt;/p&gt;
    
    </summary>
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/categories/spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="XMLBeanFactory" scheme="https://www.lantaoblog.site/tags/XMLBeanFactory/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码之ApplicationContext</title>
    <link href="https://www.lantaoblog.site/2019/02/27/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring%E6%BA%90%E7%A0%81%E4%B9%8BApplicationContext/"/>
    <id>https://www.lantaoblog.site/2019/02/27/Spring源码系列/Spring源码之ApplicationContext/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-06-20T01:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        本文是针对Srping的ClassPathXMLApplicationContext来进行源码解析,在本篇博客中将不会讲述spring Xml解析注册代码，因为ApplicationContext是BeanFactory的扩展版本，</p><a id="more"></a><p>ApplicationContext的GetBean和xml解析注册BeanDefinition都是用一套代码，如果您是第一次看请先看一下XMLBeanFactory解析和BeanFactory.GetBean源码解析：</p><blockquote><ul><li><strong>XMLBeanFactory源码解析地址：<a href="https://blog.csdn.net/qq_30257149/article/details/87972291" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/87972291</a></strong></li><li><strong>BeanFactory.getBean源码解析地址：<a href="https://blog.csdn.net/qq_30257149/article/details/88016361" target="_blank" rel="noopener">https://blog.csdn.net/qq_30257149/article/details/88016361</a></strong></li></ul></blockquote><p><strong>作者整理了spring-framework 5.x的源码注释，代码已经上传者作者的GitHub了，可以让读者更好的理解，地址：</strong></p><blockquote><ul><li>GItHub:<a href="https://github.com/lantaoGitHub/spring-framework.git" target="_blank" rel="noopener">https://github.com/lantaoGitHub/spring-framework.git</a></li></ul></blockquote><ul><li>接下来我们你直接上源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lantao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lantao.UserBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-bean.xml"</span>);</span><br><span class="line">UserBean userBean = (UserBean) applicationContext.getBean(<span class="string">"userBean"</span>);</span><br><span class="line">System.out.println(userBean.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里直接使用ClassPathXmlApplicationContext进行xml解析，在这里xml解析的代码和GetBean的代码就不过多的描述了，ApplicationContext是BeanFactory的扩展，所以想要看这两部分源码的请看作者的上两篇博客Sprin源码解析； </p></blockquote><ul><li>接下来我们看一下ClassPathXmlApplicationContext的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new ClassPathXmlApplicationContext with the given parent,</span></span><br><span class="line"><span class="comment"> * loading the definitions from the given XML files.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configLocations array of resource locations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> refresh whether to automatically refresh the context,</span></span><br><span class="line"><span class="comment"> * loading all bean definitions and creating all singletons.</span></span><br><span class="line"><span class="comment"> * Alternatively, call refresh manually after further configuring the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if context creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">// 支持解析多文件</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在setConfigLocations方法中将资源文件放入configLocations全局变量中，，并且支持多文件解析，接下来我们你看一下重点，refresh方法；</p></blockquote><ul><li>源码refresh方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 准备刷新上下文</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 对beanFactory的各种功能填充，加载beanFactory，经过这个方法 applicationContext就有了BeanFactory的所有功能</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 对beanFactory进行各种功能填充</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">//  允许在context子类中对BeanFactory进行post-processing。</span></span><br><span class="line"><span class="comment">// 允许在上下文子类中对Bean工厂进行后处理</span></span><br><span class="line"><span class="comment">// 可以在这里进行 硬编码形式的 BeanFactoryPostProcessor 调用 addBeanFactoryPostProcessor</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 激活各种BeanFactory处理器 BeanFactoryPostProcessors是在实例化之前执行</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 注册 拦截Bean创建 的Bean处理器，这里只是注册，真正地调用在getBean的时候  BeanPostProcessors实在init方法前后执行 doCreateBean方法中的 实例化方法中执行</span></span><br><span class="line"><span class="comment">// BeanPostProcessor执行位置：doCreateBean --&gt; initializeBean --&gt; applyBeanPostProcessorsBeforeInitialization 和 applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">//为上下文初始化Message源，（比如国际化处理） 这里没有过多深入</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">//初始化应用消息广播，并放入 applicationEventMulticaster bean中</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">//留给子类来初始化其它的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//在所有注册的bean中查找Listener bean，注册到消息广播器中</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//初始化剩下的单实例</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">//完成刷新过程，通知生命周期护处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人（LifecycleProcessor 用来与所有声明的bean的周期做状态更新）</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于ApplicationContext来说，refresh方法几乎涵盖了所有的基础和扩展功能，接下来看一下这个方法都做了什么；</p><ol><li><strong>刷新上下文，初始化前的准备工作；</strong></li><li><strong>加载beanFactory，经过这个方法 applicationContext就有了BeanFactory的所有功能</strong></li><li><strong>对beanFactory进行各种功能填充</strong></li><li><strong>允许在这里对BeanFactory的二次加工，例如：可以在这里进行硬编码方法的对BeanFactory进行BeanFactoryPostProcessor或BeanPostProcessor的操作；在这里简单说一下BeanFactoryPostProcessor是在bean实例化之前执行的，BeanPostProcessor是在初始化方法前后执行的，BeanFactoryPostProcessor操作的是BeanFactoryBeanPostProcessor操作的是Bean，其次这里还涉及了一个扩展BeanDefinitionRegistryPostProcessor它是继承了BeanFactoryPostProcessor，并且还有自己的定义方法 postProcessBeanDefinitionRegistry，这个方法可以操作BeanDefinitionRegistry，BeanDefinitionRegistry有个最主要的方法就是registerBeanDefinition，可以注册BeanDefinition，可以用这方法来处理一下不受spring管理的一下bean；</strong></li><li><strong>处理所有的BeanFactoryPostProcessor，也可以说是激活BeanFactory处理器，在这个方法里会先处理BeanDefinitionRegistryPostProcessor，在处理BeanFactoryPostProcessor，因为BeanDefinitionRegistryPostProcessor有自己的定义，所以先执行；</strong></li><li><strong>注册BeanPostProcessors ，这里只是注册，真正地调用在getBean的时候  BeanPostProcessors实在init方法前后执行  BeanPostProcessor执行位置：doCreateBean –&gt; initializeBean –&gt; applyBeanPostProcessorsBeforeInitialization 和 applyBeanPostProcessorsAfterInitialization方法中；</strong></li><li><strong>为上下文初始化Message源，（比如国际化处理） 这里没有过多深入；</strong></li><li><strong>初始化应用消息广播，初始化 applicationEventMulticaster ，判断使用自定义的还是默认的；</strong></li><li><strong>留给子类来初始化其它的bean；</strong></li><li><strong>在所有注册的bean中查找 ApplicationListener bean，注册到消息广播器中；</strong></li><li><strong>初始化剩下的单实例（非懒加载），这里会是涉及conversionService，LoadTimeWeaverAware，冻结BeanFactory，初始化Bean等操作；</strong></li><li><strong>完成刷新过程，包括 清除 下文级资源(例如扫描的元数据)，通知生命周期护处理器lifecycleProcessor并strat，同时publish Event发出ContextRefreshEvent通知别人；</strong></li></ol></blockquote><ul><li>先来看prepareRefresh方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Switch to active.</span></span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 标志，指示是否已关闭此上下文</span></span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 指示此上下文当前是否处于活动状态的标志</span></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line"><span class="comment">// 对上下文环境中的任何属性源进行分类。</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line"><span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证标示为必填的属性信息是否都有了 ConfigurablePropertyResolver#setRequiredProperties 方法</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line"><span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line"><span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line"><span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一眼望去，可能觉得这个方法没有做什么，其实这方法中除了Closed和Active最终要的是initPropertySources和getEnvironment().validateRequiredProperties()方法；</p><ol><li>initPropertySources证符合Spring的开放式结构设计，给用户最大扩展Spring的能力。用户可以根据自身的需要重写initPropertySourece方法，并在方法中进行个性化的属性处理及设置。</li><li>validateRequiredProperties则是对属性进行验证，那么如何验证呢？举个融合两句代码的小例子来理解。</li></ol><p>例如现在有这样一个需求，工程在运行过程中用到的某个设置（例如VAR）是从系统环境变量中取得的，而如果用户没有在系统环境变量中配置这个参数，工程不会工作。这一要求也各种各样许有的解决办法，在Spring中可以这么做，可以直接修改Spring的源码，例如修改ClassPathXmlApplicationContext.淡然，最好的办法是对源码进行扩展，可以自定义类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">ClassPathXmlApplicationContext</span></span>&#123;</span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="title">MyClassPathXmlApplicationContext</span><span class="params">(String.. configLocations)</span></span>&#123;</span><br><span class="line">&gt;             <span class="keyword">super</span>(configLocations);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;              <span class="comment">//添加验证要求</span></span><br><span class="line">&gt;              getEnvironment().setRequiredProterties(<span class="string">"VAR"</span>)；</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>自定义了继承自ClassPathXmlApplicationContext的MyClassPathXmlApplicationContext,并重写了initPropertySources方法，在方法中添加了个性化需求，那么在验证的时候也就是程序走到getEnvironment().validateRequiredProperties()代码的时候，如果系统并没有检测到对应VAR的环境变量，将抛出异常。当然我们还需要在使用的时候替换掉原有的ClassPathXmlApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span></span>&#123;</span><br><span class="line">&gt;    ApplicationContext bf = <span class="keyword">new</span> MyClassPathXmlApplicationContext(<span class="string">"myTest.xml"</span>)；</span><br><span class="line">&gt;    User user = (User)bf.getBean(<span class="string">"testBean"</span>);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>上述案例来源于：Spring源码深度解析（第二版）141页；</p></blockquote><ul><li>接下来看一下obtainFreshBeanFactory方法，在这里初始化DefaultListAbleBeanFactory并解析xml：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context's underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context's lifecycle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// createBeanFactory方法直接新建一个DefaultListableBeanFactory，内部使用的是DefaultListableBeanFactory实例</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line"><span class="comment">// 设置序列化id</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">// 定制beanFactory工厂</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">// 加载BeanDefinition</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="comment">// 使用全局变量记录BeanFactory</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>看一下上述方法都做了什么：</p><ol><li><p>判断BeanFactory是否存在，如果存在则销毁所有Bean，然后关闭BeanFactory；</p></li><li><p>使用createBeanFactory方法直接新建一个DefaultListableBeanFactory，内部使用的是DefaultListableBeanFactory实例；</p></li><li><p>设置BeanFactory的设置序列化id</p></li><li><p>定制beanFactory工厂，也就是给allowBeanDefinitionOverriding(是否允许覆盖同名称的Bean)和allowCircularReferences(是否允许bean存在循环依赖)，可通过setAllowBeanDefinitionOverriding和setAllowCircularReferences赋值,这里就可通过商编初始化方法中的initPropertySources方法来进行赋值；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">package</span> lantao;</span><br><span class="line">&gt;   <span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationContext</span> <span class="keyword">extends</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationContext</span><span class="params">(String... configLocations)</span></span>&#123;</span><br><span class="line">&gt;<span class="keyword">super</span>(configLocations);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt; <span class="comment">//添加验证要求</span></span><br><span class="line">&gt; getEnvironment().setRequiredProperties(<span class="string">"VAR"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// 在这里添加set</span></span><br><span class="line">&gt; <span class="keyword">super</span>.setAllowBeanDefinitionOverriding(<span class="keyword">true</span>);</span><br><span class="line">&gt; <span class="keyword">super</span>.setAllowCircularReferences(<span class="keyword">true</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="6"><li>加载BeanDefinition，就是解析xml，循环解析，这里就不看了，如果不了解看作者上篇博客；</li></ol></blockquote><ul><li>下面看一下prepareBeanFactory方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line"><span class="comment">// 设置BeanFactory的classLoader为当前context的classloader</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spel语言解析器</span></span><br><span class="line"><span class="comment">// 设置BeanFactory的表达式语言处理器 Spring3中增加了表达式语言的支持</span></span><br><span class="line"><span class="comment">// 默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值</span></span><br><span class="line"><span class="comment">// 在Bean实例化的时候回调用 属性填充的方法(doCreateBean 方法中的 populateBean 方法中的 applyPropertyValues 方法中的 evaluateBeanDefinitionString ) 就会判断beanExpressionResolver是否为null操作</span></span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为BeanFactory增加一个默认的 PropertyEditor 这个主要对bean的属性等设置管理的一个工具 增加属性注册编辑器  例如：bean property 类型 date 则需要这里</span></span><br><span class="line"><span class="comment">// beanFactory会在初始化 BeanWrapper（initBeanWrapper）中调用 ResourceEditorRegistrar 的 registerCustomEditors 方法</span></span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">// ApplicationContextAwareProcessor --&gt; postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment">// 注册 BeanPostProcessor  BeanPostProcessor 实在实例化前后执行的</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置几个忽略自动装配的接口 在addBeanPostProcessor方法中已经对下面几个类做了处理，他们就不是普通的bean了，所以在这里spring做bean的依赖的时候忽略</span></span><br><span class="line"><span class="comment">// doCreateBean 方法中的 populateBean 方法中的 autowireByName 或 autowireByType 中的 unsatisfiedNonSimpleProperties 中的  !isExcludedFromDependencyCheck(pd) 判断，</span></span><br><span class="line"><span class="comment">// 在属性填充的时候回判断依赖，如果存在下属几个则不做处理 对于下面几个类可以做implements操作</span></span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// 设置几个注册依赖 参考spring源码深度解析原文：当注册依赖解析后，例如但那个注册了对BeanFactory。class的解析依赖后，当bean的属性注入的时候，一旦检测到属性为BeanFactory的类型变回将beanFactory 实例注入进去</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">// 寄存器早期处理器，用于检测作为ApplicationListener的内部bean。</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="comment">// 增加了对AxpectJ的支持</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">// 添加默认的系统环境bean</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不说废话，直接看这个方法都做了什么:</p><ol><li><p>设置BeanFactory的classLoader为当前context的classloader;</p></li><li><p>设置BeanFactory的表达式语言处理器 Spring3中增加了Spel表达式语言的支持, 默认可以使用#{bean.xxx}的形式来调用相关属性值，</p><p>在Bean实例化的时候回调用 属性填充的方法(doCreateBean 方法中的 populateBean 方法中的 applyPropertyValues 方法中的 evaluateBeanDefinitionString ) 就会判断beanExpressionResolver是否为null操作，如果不是则会使用Spel表达式规则解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&gt;    &lt;beans</span><br><span class="line">&gt;           xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">&gt;           xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">&gt;           xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">&gt;        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;bean id=<span class="string">"testOneBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"lantao.bean.TestOneBean"</span>&gt;</span><br><span class="line">&gt;    &lt;property name=<span class="string">"testTwoBean"</span> value=<span class="string">"#&#123;testTWoBean&#125;"</span>/&gt;</span><br><span class="line">&gt;    &lt;/bean&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;bean id=<span class="string">"testTWoBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"lantao.bean.TestTwoBean"</span>/&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;!-- 上面 相当于 下边 --&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;bean id=<span class="string">"testOneBean1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"lantao.bean.TestOneBean"</span>&gt;</span><br><span class="line">&gt;    &lt;property name=<span class="string">"testTwoBean"</span> ref=<span class="string">"testTWoBean1"</span>/&gt;</span><br><span class="line">&gt;    &lt;/bean&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;bean id=<span class="string">"testTWoBean1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"lantao.bean.TestTwoBean"</span>/&gt;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    &lt;/beans&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>为BeanFactory增加一个默认的 PropertyEditor 这个主要对bean的属性等设置管理的一个工具 增加属性注册编辑器  例如：User类中 startDate 类型 date 但是xml property的value是2019-10-10，在启动的时候就会报错，类型转换不成功，这里可以使用继承PropertyEditorSupport这个类机型重写并注入即可使用；beanFactory会在初始化BeanWrapper (initBeanWrapper)中调用 ResourceEditorRegistrar 的 registerCustomEditors 方法进行初始化；</li></ol><ol start="4"><li>配置BeanPostProcessor，这里配置的是ApplicationContextAwareProcessor，上边我们说了，BeanPostProcessor是在初始化方法Init前后执行，看一下ApplicationContextAwareProcessor的Before和After方法:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;    <span class="meta">@Nullable</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">&gt;    AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="comment">// 该方法也会在 BeanFactory 实例化bean 中调用  doCreateBean --&gt; initializeBean --&gt; applyBeanPostProcessorsBeforeInitialization --&gt; postProcessBeforeInitialization</span></span><br><span class="line">&gt;    <span class="comment">// 如果实例化的类实现了 invokeAwareInterfaces 方法中的判断类 则会调用初始方法赋值</span></span><br><span class="line">&gt;    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">&gt;    (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">&gt;    bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">&gt;    bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">&gt;    acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">&gt;    invokeAwareInterfaces(bean);</span><br><span class="line">&gt;    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;    &#125;, acc);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;    invokeAwareInterfaces(bean);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">return</span> bean;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">&gt;    ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">&gt;    ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">&gt;    ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">&gt;    ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">&gt;    ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">&gt;    ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="meta">@Override</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">return</span> bean;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>   在Before方法中调用了invokeAwareInterfaces方法，在invokeAwareInterfaces方法中做了类型 instanceof 的判断，意思就是如果这个Bean实现了上述的Aware，则会初始会一下资源，比如实现了ApplicationContextAware，就会setApplicationContext，这里相信大家都用过，就不多说了；</p><ol start="5"><li><p>设置几个忽略自动装配的接口 在addBeanPostProcessor方法中已经对下面几个类做了处理，他们就不是普通的bean了，所以在这里spring做bean的依赖的时候忽略，在doCreateBean 方法中的 populateBean 方法中的 autowireByName 或 autowireByType 中的 unsatisfiedNonSimpleProperties 中的  !isExcludedFromDependencyCheck(pd) 判断，如果存在则不做依赖注入了；</p></li><li><p>设置几个注册依赖 参考spring源码深度解析原文：当注册依赖解析后，例如当注册了对BeanFactory的解析依赖后，当bean的属性注入的时候，一旦检测到属性为BeanFactory的类型便会将beanFactory 实例注入进去；</p></li></ol><ol start="7"><li><p>添加BeanPostProcessor，这里是添加ApplicationListener，是寄存器早期处理器；这里可以看作者的源码测试，在spring-context的test测试类下有；</p></li><li><p>增加了对AxpectJ的支持</p></li><li><p>注册默认的系统环境bean，environment ，systemProperties，systemEnvironment；</p></li></ol></blockquote><ul><li>上述就是对BeanFactory的功能填充，下面看postProcessBeanFactory:</li></ul><blockquote><p>postProcessBeanFactory方法是个空方法，允许在上下文子类中对Bean工厂进行后处理，例如：可以在这里进行 硬编码形式的 BeanFactoryPostProcessor 调用 addBeanFactoryPostProcessor，进行addBeanFactoryPostProcessor或者是BeanPostProcessor；</p></blockquote><ul><li>接下来看一下invokeBeanFactoryPostProcessors方法:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 BeanDefinitionRegistry  类型处理</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line"><span class="comment">// 强转</span></span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的处理器</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册处理器</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就是硬编码处理 因为这里是从 getBeanFactoryPostProcessors()方法获取的 可以硬编码从addBeanFactoryPostProcessor（）方法添加</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 BeanDefinitionRegistryPostProcessor 类型 在 BeanFactoryPostProcessor 的基础上还有自己的定义，需要先调用</span></span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 继承 BeanDefinitionRegistryPostProcessor 类的  postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line"></span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边的For循环只是调用了硬编码的 BeanDefinitionRegistryPostProcessor 中的 postProcessBeanDefinitionRegistry 方法，</span></span><br><span class="line"><span class="comment">// 但是 BeanFactoryPostProcessor 中的 postProcessBeanFactory 方法还没有调用，是在方法的最后一行</span></span><br><span class="line"><span class="comment">// invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">// invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); 这两个方法中执行的，</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是自动处理器 获取类型是BeanDefinitionRegistryPostProcessor  beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 获取的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前注册处理器</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先调用实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 下一个 ，调用实现 Ordered 的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 最后，调用所有其他BeanDefinitionRegistryPostProcessors，直到不再显示其他BeanDefinitionRegistryPostProcessors 无序的</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行 BeanDefinitionRegistryPostProcessor类的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，调用到目前为止处理的所有处理器的  执行BeanFactoryPostProcessor 类的 postProcessBeanFactory 方法</span></span><br><span class="line"><span class="comment">// 这里执行的是 硬编码 和 非硬编码（自动）的 BeanFactoryPostProcessor 类的 postProcessBeanFactory 方法 分为硬编码处理器 和 普通处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 调用在上下文实例中注册的工厂处理器的postProcessBeanFactory方法。 就是硬编码 通过 addBeanFactoryPostProcessor 方法添加的BeanFactoryPostProcessor</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动处理 非硬编码 获取类型为是BeanFactoryPostProcessor    beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  实现 priorityOrdered 的</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Ordered 的</span></span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序的</span></span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码看起来很多，但是总计起来就三件事：</p><ol><li>执行硬编码的和主动注入的BeanDefinitionRegistryPostProcessor,调用postProcessBeanDefinitionRegistry方法；</li><li>执行硬编码的和主动注入的BeanFactoryPostProcessor，调用postProcessBeanFactory方法；</li><li>自动注入的可继承Ordered排序，priorityOrdered排序或无序；</li></ol><p>上述测试在作者的spring源码congtext中lantao包下有测试用例；</p></blockquote><ul><li>registerBeanPostProcessors方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line"><span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line"><span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line"><span class="comment">// 使用 priorityOrdered保证顺序</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MergedBeanDefinitionPostProcessor</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用order保证顺序</span></span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序的</span></span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行add操作</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先 注册实现PriorityOrdered的 BeanPostProcessors 先排序PostProcessors</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 下一个，注册实现Ordered的BeanPostProcessors</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 现在，注册所有常规注册。无序的</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 最后，注册所有MergedBeanDefinitionPostProcessor类型的BeanPostProcessor,并非重复注册。</span></span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line"><span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">// 添加 ApplicationListener探测器</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>registerBeanPostProcessors方法代码还是比较长的，它和invokeBeanFactoryPostProcessors方法最主要的区别就是registerBeanPostProcessors只在这里注册，但不在这里调用，做的事情和invokeBeanFactoryPostProcessors差不多：</p><ol><li>使用priorityOrdered，Ordered或无序保证顺序；</li><li>通过beanFactory.addBeanPostProcessor(postProcessor)进行注册；</li></ol><p>很简单，代码篇幅很长，但是很好理解，这里可以简单看一下；</p></blockquote><ul><li>接下来是initMessageSource方法，这里作者没有过多的看源码，后续补上吧…….(抱歉)</li></ul><ul><li>initApplicationEventMulticaster源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 使用自定义的 广播</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 使用spring 默认的广播</span></span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line"><span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initApplicationEventMulticaster方法中主要就是判断是使用自定义的ApplicationEventMulticaster(广播器)还是使用呢Spring默认的SimpleApplicationEventMulticaster广播器；</p></blockquote><ul><li><p>onRefresh 方法是留个子类重写的，内容是空；</p></li><li><p>registerListeners方法：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">// 注册 添加 ApplicationListener  这里通过硬编码 addApplicationListener 方法添加的</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 注册 添加 ApplicationListener 这里是自动注册添加的</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">// 发布早期的事件</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>registerListeners方法做了三件事情：</p><ol><li>添加 ApplicationListener  这里通过硬编码 addApplicationListener 方法添加的；</li><li>添加 ApplicationListener 是通过自动注册添加的</li><li>发布早起事件</li></ol></blockquote><ul><li>finishBeanFactoryInitialization方法源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="comment">// conversionService 用于类型转换 ，比如 String 转Date</span></span><br><span class="line"><span class="comment">//判断BeanFactory中是否存在名称为“conversionService”且类型为ConversionService的Bean，如果存在则将其注入到beanFactory</span></span><br><span class="line"><span class="comment">// 判断有无自定义属性转换服务接口，并将其初始化，我们在分析bean的属性填充过程中，曾经用到过该服务接口。在TypeConverterDelegate类的convertIfNecessary方法中</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">// 得到所有的实现了LoadTimeWeaverAware接口的子类名称，初始化它们</span></span><br><span class="line"><span class="comment">// 如果有LoadTimeWeaverAware类型的bean则初始化，用来加载Spring Bean时织入第三方模块,如AspectJ，我们在后面详细讲解。</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"><span class="comment">// 停止使用临时类加载器 就是在这里不让使用呢 ClassLoader 了</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">// 冻结所有bean定义，说明你注册的bean将不被修改或进行任何进一步的处理 就是不让改了 BeanDefinition</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 初始化所有非懒加载的 单例 bean  调用你getBean方法</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>finishBeanFactoryInitialization方法做了五件事情：</p><ol><li>设置BeanFactory的conversionService，conversionService用于类型转换使用, 例如：User类中 startDate 类型 date 但是xml property的value是2019-10-10，在启动的时候就会报错，类型转换不成功，可以使用conversionService；书中170页有具体代码；</li><li>添加BeanFactory的addEmbeddedValueResolver，读取配置信息放到这里，可以通过EmbeddedValueResolverAware来获取，参考：<a href="https://www.cnblogs.com/winkey4986/p/7001173.html" target="_blank" rel="noopener">https://www.cnblogs.com/winkey4986/p/7001173.html</a></li><li>得到所有的实现了LoadTimeWeaverAware接口的子类名称，初始化它们，用来加载Spring Bean时织入第三方模块,如AspectJ，我们在后面详细讲解。</li><li>停止使用临时类加载器 就是在这里不让使用呢 ClassLoader 了</li><li>冻结所有bean定义，说明你注册的bean将不被修改或进行任何进一步的处理 就是不让改了 BeanDefinition</li><li>初始化所有非懒加载的 单例 bean  调用你getBean方法，循环所有bean并实例化 条件是：单例，非Abstract 非懒加载</li></ol></blockquote><ul><li>最后的一个方法finishRefresh：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line"><span class="comment">// 清除 下文级资源(例如扫描的元数据)。</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line"><span class="comment">// 在当前context中初始化 lifecycle</span></span><br><span class="line"><span class="comment">// lifecycle 有自己的 start/ stop方法，实现此接口后spring保证在启动的时候调用start方法开始生命周期 关闭的时候调用 stop方法结束生命周期</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line"><span class="comment">// onRefresh 启动所有实现了 lifecycle 的方法</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish the final event.</span></span><br><span class="line"><span class="comment">// 当ApplicationContext初始化完成发布后发布事件 处理后续事宜</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">// 这里 没明白》。。</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>finishRefresh方法是ApplicationContext初始化的最后一个方法了，他做了一些结尾的事情：</p><ol><li>清除 下文级资源(例如扫描的元数据)。</li><li>在当前context中初始化 lifecycle，lifecycle 有自己的 start/ stop方法，实现此接口后spring保证在启动的时候调用start方法开始生命周期 关闭的时候调用 stop方法结束生命周期。</li><li>onRefresh 启动所有实现了 lifecycle 的方法，调用了start方法。</li><li>当ApplicationContext初始化完成发布事件 处理后续事宜。</li><li>LiveBeansView.registerApplicationContext(this)这个代码没有太明白，有大神可以留言；</li></ol></blockquote><p>至此ApplicationContext的源码就都已经分析完成了，其中有很多地方很难懂，大家可以对应着源码一起看，会好理解一些，如果其中有错误，欢迎大神指点，在下方留言，本篇博客是作者参考SPring 源码深度解析 + 自己的理解写出来的，算是一个学习后的的产出，最后，码字不易，转载请注明出处。</p><p>博客地址：<a href="https://lantaogithub.github.io" target="_blank" rel="noopener">https://lantaogithub.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        本文是针对Srping的ClassPathXMLApplicationContext来进行源码解析,在本篇博客中将不会讲述spring Xml解析注册代码，因为ApplicationContext是BeanFactory的扩展版本，&lt;/p&gt;
    
    </summary>
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/categories/spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="https://www.lantaoblog.site/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="ApplicationContext" scheme="https://www.lantaoblog.site/tags/ApplicationContext/"/>
    
  </entry>
  
  <entry>
    <title>多线程的宏观和微观视角</title>
    <link href="https://www.lantaoblog.site/2019/02/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8F%E8%A7%82%E5%92%8C%E5%BE%AE%E8%A7%82%E8%A7%86%E8%A7%92/"/>
    <id>https://www.lantaoblog.site/2019/02/04/多线程/多线程的宏观和微观视角/</id>
    <published>2019-02-03T16:00:00.000Z</published>
    <updated>2019-06-20T01:38:18.084Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能；</p><a id="more"></a><h2 id="微观视角"><a href="#微观视角" class="headerlink" title="微观视角"></a>微观视角</h2><ul><li><strong>可见性</strong>:一个线程对共享变量的修改，另外一个线程能够立刻感知到，我们称为可见性;</li><li><strong>原子性</strong>：一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性；</li><li><strong>有序性</strong>：就是我们代码的执行顺序，依赖等。(指令重排导致顺序被打乱);</li></ul><hr><p>&#8195;&#8195;<strong>线程工作内存：</strong> 是指 Cpu 的 <strong>‘寄存器’</strong> 和 <strong>‘高速缓存’</strong>，线程的 工作内存/本地内存 是指cpu的寄存器和高速缓存的抽象描述,数据读取顺序优先级 是：<strong>寄存器－&gt;高速缓存－&gt;内存</strong></p><hr><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><ul><li><strong>安全性</strong>：安全性我认为其实是包含了原子性丶可见性和有序性的，是一个总的概念，在程序开发的时候首先要注重安全性，会在下面详细解释这三点；</li><li><strong>活跃性</strong><br>活跃性告诉我们的是要避免死锁，饥饿和活锁；<br><strong>— 死锁</strong>：这个都不陌生，线程A持有1锁，等待获取2锁，线程B持有2锁，等待获取1锁，这就是个典型的死锁，就就是阻塞了。<br><strong>— 饥饿</strong>：饥饿当多线程获取锁都得时候，总有线程没有机会获取到锁，出现饥饿的三中情况：<strong>1-高优先级的线程吞噬了低优先级线程的CPU使用权 2-线程被一直阻塞(比如Thread.Sleep) 3-等待线程永远不被唤醒</strong>，也可以理解为锁的优先级，我们常用的synchronized就是非公平锁，例如线程A，B,C按顺序获取锁1，首先是A获取到了锁，执行完临界区代码释放了锁，这是线程D来了直接获取到了锁，这就是非公平锁；ReentrantLock()默认是非公平锁，可以在ReentractLock（true）创建公平锁；</li></ul><p><strong>— 活锁</strong>：在生活中A和B同时进入左手门，为了不发生碰撞，A和B互相礼让同时进入了右手门，为了不发生碰撞又进入了左手们会一直循环下去，<strong>实例代码找到适用的场景在增加</strong></p><ul><li><strong>性能</strong><br>1：<strong>延迟:</strong> 延迟就是指一个请求调用到返回所使用的时间，时间越短，程序的处理的就越快，性能也就会高；<br>2：<strong>吞吐量:</strong> 吞吐量就是值在单位时间内(秒)处理的请求数量，吞吐量越大，程序处理的请求就越多，性能也越好；</li></ul><hr><h3 id="可见性：线程工作空间导致可见性问题"><a href="#可见性：线程工作空间导致可见性问题" class="headerlink" title="可见性：线程工作空间导致可见性问题"></a>可见性：<strong>线程工作空间导致可见性问题</strong></h3><p>&#8195;&#8195;例如：线程A在主存中年将变量age=0拉去到自己的工作内存中，然后做了age = 5，当然这个操作是在cpu的寄存器中进行的，然后写会高速缓存中，这时线程A的高速缓存还未执行同步主内存的操作，线程B又将age=0从主存拉取到了线程B的工作内存中，导致A线程已经更新但是B线程看不到的可见性问题；</p><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7.png?raw=true" alt="%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7.png"></p><h3 id="原子性：线程切换导致原子性问题-count"><a href="#原子性：线程切换导致原子性问题-count" class="headerlink" title="原子性：线程切换导致原子性问题 ++count"></a>原子性：<strong>线程切换导致原子性问题 ++count</strong></h3><p>&#8195;&#8195;例如：当线程A从<strong>主内存</strong>中将共享变量Count加载到线程A的<strong>工作内存</strong>后，发生了线程切换，这个时候线程B也将共享变量Count从<strong>主内存</strong>加载到了线程B的<strong>工作内存</strong>，这时<strong>线程A和B的工作内存中count都是0</strong>，线程B执行了Count = Count + 1,然后写回到<strong>主内存</strong>，这时候线程切换完成，回到了线程A再次执行 Count = Count + 1,再将线程A<strong>工作内存计算过</strong>的count写回主内存，现在我们得到的主内存呢中Count值是1而不是2。</p><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98++count%20.png?raw=true" alt="%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%2B%2Bcount%20.png"></p><h3 id="有序性：指令重排导致有序性问题；"><a href="#有序性：指令重排导致有序性问题；" class="headerlink" title="有序性：指令重排导致有序性问题；"></a>有序性：<strong>指令重排导致有序性问题；</strong></h3><p>在这里讲一个例子，就是获取单例双重检查锁(double-checked locking)判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Auther: lantao</span><br><span class="line"> * @Date: 2019-03-28 14:32</span><br><span class="line"> * @Company: 随行付支付有限公司</span><br><span class="line"> * @maill: lan_tao@suixingpay.com</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> */</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    </span><br><span class="line">    private DoMain doMain;</span><br><span class="line">    </span><br><span class="line">    public DoMain getDoMain()&#123;</span><br><span class="line">        if(doMain == null)&#123;</span><br><span class="line">            synchronized (this.getClass())&#123;</span><br><span class="line">                if(doMain == null)&#123;</span><br><span class="line">                    doMain = new DoMain(&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return doMain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return doMain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在上边的代码中在synchronized内和外都有一个if判断，判断doMain是否为null操作，有很多人对synchronized中的if null判断不理解，其实可以这样想，线程A和线程B都执行到了synchronized这里进行竞争锁，结果A得到锁，判断if null，结果还未实例化，继续进行实例化，然后return对象并释放锁，这时线程B获取到了锁进入if null判断，发现doMain已经被线程A实例化过了，直接返回实例即可，第二个if null的作用就在这里；</p><p>看上去上边的代码是完美的，但是new的操作上我们理解是：</p><ul><li>创建内存M</li><li>在内存M上初始化doMain对象</li><li>将内存M的地址指向变量doMain</li></ul><p>但是实际上优化后(指令重排)的执行路径可能是这样的：</p><ul><li>创建内存M</li><li>将内存M的地址指向变量doMain</li><li>将内存M的地址指向变量doMain</li></ul><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98.png?raw=true" alt="%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能；&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://www.lantaoblog.site/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="可见性/原子性/有序性" scheme="https://www.lantaoblog.site/tags/%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    
      <category term="安全性/活跃性/性能" scheme="https://www.lantaoblog.site/tags/%E5%AE%89%E5%85%A8%E6%80%A7-%E6%B4%BB%E8%B7%83%E6%80%A7-%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized升级过程总结</title>
    <link href="https://www.lantaoblog.site/2019/02/04/%E9%94%81/Synchronized%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://www.lantaoblog.site/2019/02/04/锁/Synchronized升级过程总结/</id>
    <published>2019-02-03T16:00:00.000Z</published>
    <updated>2019-06-20T02:26:46.352Z</updated>
    
    <content type="html"><![CDATA[<p>要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等,下<a id="more"></a>面我们就来介绍一下Synchronized的流程和使用方法；</p><ul><li><h2 id="Synchronized的升级过程"><a href="#Synchronized的升级过程" class="headerlink" title="Synchronized的升级过程"></a><strong>Synchronized的升级过程</strong></h2><p><strong>(Java SE 1.6中为了减少获得锁和释放锁带来的 性能消耗而引入的偏向锁和轻量级锁)</strong></p><p><strong>Synchronized的升级顺序是 无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁，顺内不可逆。</strong></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p> 当一个线程访问<strong>同步代码块</strong>并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁，以后该线程在进入和退出该同步代码块时不需要花费 CAS 操作来加锁和解锁，而只需简单的<strong>测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁(当前线程的线程ID)</strong>，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果偏向锁标识是1，<strong>则使用 CAS 进行锁获取</strong>，偏向锁标识不是1，则尝试使用 <strong>CAS 将对象头的偏向锁指向当前线程</strong>，上述两种CAS获取锁的操作，如果<strong>CAS操作成功则获取到了偏向锁</strong>，<strong>失败则代表出现了锁竞争，需要锁撤销操作</strong>。</p><h3 id="锁撤销"><a href="#锁撤销" class="headerlink" title="锁撤销"></a><strong>锁撤销</strong></h3><p>偏向锁使用了一种等到<strong>竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要<strong>等待拥有偏向锁的线程到达全局安全点</strong>（在这个时间点上没有字节码正在执行），会首先<strong>暂停拥有偏向锁的线程</strong>，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁的对象的对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行<strong>(判断是否需要持有锁)</strong>，遍历偏向对象的锁记录，查看使用情况，如果还需要持有偏向锁，则偏向锁<strong>升级为轻量级锁</strong>，如果不需要持有偏向锁了，则将锁对象恢复成无锁状态，最后唤醒暂停的线程。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋来获取锁</strong>，<strong>自旋有一定次数，如果超过设置自旋的次数则升级到重量级锁</strong>，<strong>或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转</strong>。</p><h3 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a><strong>轻量级锁解锁</strong></h3><p>轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。<strong>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。</p><p><strong>例如：</strong>T1线程持有锁，T2线程自旋，但是T2线程自旋最大次数已经过了，则自旋失败，进行锁升级到重量级锁，T2线程阻塞，这时T1执行完了同步代码块，进行轻量级锁解锁，但是这时Mark Word中的标志位已经从原来的00(偏向锁)变成了10(中练级锁)，解锁会CAS失败，T1会进行解锁(释放监视器，释放锁)，并唤醒线程T2.</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h3><p>Synchronized是非公平锁,Synchronized在线程进入阻塞队列时，等待的线程会先尝试获取锁，如果获取不到就进入阻塞队列，这明显对于已经进入队列的线程是不公平的。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加解锁不需要过多的资源消耗，和非同步方法的相比仅仅是<strong>纳秒</strong>的差距</td><td align="center">如果存在所竞争，会有额外的锁撤销操作</td><td align="center">适用于只有一个线程访问的场景</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争线程不会阻塞，会自旋，减少了上线文切换。</td><td align="center">如果始终得不到锁，会消耗cpu资源</td><td align="center">追求响应时间，同步代码块多为计算，执行快的场景</td></tr><tr><td align="center">重量级锁</td><td align="center">没啥优点</td><td align="center">线程阻塞响应时间慢</td><td align="center">同步代码块执行时间较长的场景使用</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h3><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/Synchronized%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true" alt></p></li></ul><ul><li><h2 id="Synchronized-方法"><a href="#Synchronized-方法" class="headerlink" title="Synchronized 方法"></a><strong>Synchronized 方法</strong></h2><p><strong>1:</strong> <strong>Synchronized</strong> 是java的<strong>内置锁</strong>，也是<strong>排它锁</strong>和<strong>非公平锁</strong>，<strong>排它锁</strong>也就是当前线程获取锁后，其他线程都会阻塞挂起 ，<strong>非公平锁</strong>是在线程后去锁的时候会先尝试后去锁，获取不到在进行阻塞。</p><p><strong>2:</strong> <strong>Synchronized</strong> 是如何保证 ‘原子性’ 的？是因为进入 Synchronized 块的内存语义是把 Synchronized 块内使用的 ‘工作内存清除’， 这样在使用共享变量时就会直接存主内存中获取并复制到工作你内存中，在退出 Synchronized 语句块时 会把 工作内存中计算过的 ‘共享变量’ 更新到主内存中。</p><p><strong>3:</strong> 获取到 Synchronized 锁 ，<strong>都是 ‘对象锁’而非’代码块锁’ (锁的都是对象或类，而不是某个方法)</strong>，因此 Synchronized 是<strong>具有可重入性</strong>，在获取到该对象锁后可以不用再次获取该对象其他方法的锁，直接进入。</p><p><strong>4:</strong> 如果是 <strong>Synchronized 用在 static 上</strong>， 就代表是<strong>类锁(.class)</strong>，<strong>无论创建多少个对象都不可行</strong>；</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><p>wait和sleep区别在于<strong>wait会释放锁</strong>， 但是<strong>sleep不会释放锁</strong> ，sleep会导致线程阻塞挂起。</p><p><strong>wait/wait(timeout)/notify/notifyAll</strong> 方法仅可以在<strong>获取到锁后</strong>才可以使用。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><p><strong>wait：</strong> 线程等待。</p><p><strong>wait(time)：</strong> 线程等待，如果时间超过了设置的time，则继续执行。</p><p><strong>notify：</strong> <strong>随机唤醒一个</strong>等待的线程。</p><p><strong>notifyAll：</strong> 唤醒全部等待线程。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a><strong>代码演示</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: concurrenncy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-03-25 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: wait 和 sleep 区别在于 wait会释放锁， 但是 sleep 不会 ，sleep会导致线程阻塞挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 创建线程 thread1</span></span><br><span class="line">                Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                                obj.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建线程 thread2</span></span><br><span class="line">                Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                                obj.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 启动</span></span><br><span class="line">                thread1.start();</span><br><span class="line">                thread2.start();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 睡眠一秒</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常</span></span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒 使用 obj 调用 wait 方法的其中一个线程 (随机)</span></span><br><span class="line">                    obj.notify();</span><br><span class="line">                    <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的所有线程</span></span><br><span class="line">                    obj.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等,下
    
    </summary>
    
      <category term="锁" scheme="https://www.lantaoblog.site/categories/%E9%94%81/"/>
    
    
      <category term="偏向锁/轻量级锁/重量级锁" scheme="https://www.lantaoblog.site/tags/%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    
      <category term="synchronized使用" scheme="https://www.lantaoblog.site/tags/synchronized%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
