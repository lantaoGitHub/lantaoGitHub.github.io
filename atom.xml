<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lantao</title>
  
  <subtitle>最怕一生碌碌无为，还说平凡难得可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-06T09:45:58.469Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>兰涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/06/06/hello-world/"/>
    <id>http://yoursite.com/2019/06/06/hello-world/</id>
    <published>2019-06-06T08:17:46.637Z</published>
    <updated>2019-06-06T09:45:58.469Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程的宏观和微观视角</title>
    <link href="http://yoursite.com/2019/02/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8F%E8%A7%82%E5%92%8C%E5%BE%AE%E8%A7%82%E8%A7%86%E8%A7%92/"/>
    <id>http://yoursite.com/2019/02/04/多线程的宏观和微观视角/</id>
    <published>2019-02-03T16:00:00.000Z</published>
    <updated>2019-06-12T03:45:33.813Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能；</p><a id="more"></a><h2 id="微观视角"><a href="#微观视角" class="headerlink" title="微观视角"></a>微观视角</h2><ul><li><strong>可见性</strong>: 一个线程对共享变量的修改，另外一个线程能够立刻感知到，我们称为可见性;</li><li><strong>原子性</strong>： 一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性；</li><li><strong>有序性</strong>：就是我们代码的执行顺序，依赖等。(指令重排导致顺序被打乱);</li></ul><hr><p>&#8195;&#8195;<strong>线程工作内存：</strong> 是指 Cpu 的 <strong>‘寄存器’</strong> 和 <strong>‘高速缓存’</strong>，线程的 工作内存/本地内存 是指cpu的寄存器和高速缓存的抽象描述,数据读取顺序优先级 是：<strong>寄存器－&gt;高速缓存－&gt;内存</strong></p><hr><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><ul><li><p><strong>安全性</strong>：安全性我认为其实是包含了原子性丶可见性和有序性的，是一个总的概念，在程序开发的时候首先要注重安全性，会在下面详细解释这三点；</p></li><li><p><strong>活跃性</strong><br>活跃性告诉我们的是要避免死锁，饥饿和活锁；</p><p> <strong>— 死锁</strong>：这个都不陌生，线程A持有1锁，等待获取2锁，线程B持有2锁，等待获取1锁，这就是个典型的死锁，就就是阻塞了。</p><p> <strong>— 饥饿</strong>：饥饿当多线程获取锁都得时候，总有线程没有机会获取到锁，出现饥饿的三中情况：<strong>1-高优先级的线程吞噬了低优先级线程的CPU使用权 2-线程被一直阻塞(比如Thread.Sleep) 3-等待线程永远不被唤醒</strong>，也可以理解为锁的优先级，我们常用的synchronized就是非公平锁，例如线程A，B,C按顺序获取锁1，首先是A获取到了锁，执行完临界区代码释放了锁，这是线程D来了直接获取到了锁，这就是非公平锁；ReentrantLock()默认是非公平锁，可以在ReentractLock（true）创建公平锁。</p><p><strong>— 活锁</strong>：在生活中A和B同时进入左手门，为了不发生碰撞，A和B互相礼让同时进入了右手门，为了不发生碰撞又进入了左手们会一直循环下去，**实例代码找到适用的场景在增加。</p></li><li><p><strong>性能</strong><br>1：<strong>延迟:</strong> 延迟就是指一个请求调用到返回所使用的时间，时间越短，程序的处理的就越快，性能也就会高；<br>2：<strong>吞吐量:</strong> 吞吐量就是值在单位时间内(秒)处理的请求数量，吞吐量越大，程序处理的请求就越多，性能也越好；</p></li></ul><hr><h3 id="可见性：线程工作空间导致可见性问题"><a href="#可见性：线程工作空间导致可见性问题" class="headerlink" title="可见性：线程工作空间导致可见性问题"></a>可见性：<strong>线程工作空间导致可见性问题</strong></h3><p>&#8195;&#8195;例如：线程A在主存中年将变量age=0拉去到自己的工作内存中，然后做了age = 5，当然这个操作是在cpu的寄存器中进行的，然后写会高速缓存中，这时线程A的高速缓存还未执行同步主内存的操作，线程B又将age=0从主存拉取到了线程B的工作内存中，导致A线程已经更新但是B线程看不到的可见性问题；</p><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7.png?raw=true" alt="%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7.png"></p><h3 id="原子性：线程切换导致原子性问题-count"><a href="#原子性：线程切换导致原子性问题-count" class="headerlink" title="原子性：线程切换导致原子性问题 ++count"></a>原子性：<strong>线程切换导致原子性问题 ++count</strong></h3><p>&#8195;&#8195;例如：当线程A从<strong>主内存</strong>中将共享变量Count加载到线程A的<strong>工作内存</strong>后，发生了线程切换，这个时候线程B也将共享变量Count从<strong>主内存</strong>加载到了线程B的<strong>工作内存</strong>，这时<strong>线程A和B的工作内存中count都是0</strong>，线程B执行了Count = Count + 1,然后写回到<strong>主内存</strong>，这时候线程切换完成，回到了线程A再次执行 Count = Count + 1,再将线程A<strong>工作内存计算过</strong>的count写回主内存，现在我们得到的主内存呢中Count值是1而不是2。</p><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98++count%20.png?raw=true" alt="%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%2B%2Bcount%20.png"></p><h3 id="有序性：指令重排导致有序性问题；"><a href="#有序性：指令重排导致有序性问题；" class="headerlink" title="有序性：指令重排导致有序性问题；"></a>有序性：<strong>指令重排导致有序性问题；</strong></h3><p>在这里讲一个例子，就是获取单例双重检查锁(double-checked locking)判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: lantao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-03-28 14:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DoMain doMain;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoMain <span class="title">getDoMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(doMain == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass())&#123;</span><br><span class="line">                <span class="keyword">if</span>(doMain == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    doMain = <span class="keyword">new</span> DoMain(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> doMain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doMain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在上边的代码中在synchronized内和外都有一个if判断，判断doMain是否为null操作，有很多人对synchronized中的if null判断不理解，其实可以这样想，线程A和线程B都执行到了synchronized这里进行竞争锁，结果A得到锁，判断if null，结果还未实例化，继续进行实例化，然后return对象并释放锁，这时线程B获取到了锁进入if null判断，发现doMain已经被线程A实例化过了，直接返回实例即可，第二个if null的作用就在这里；</p><p>看上去上边的代码是完美的，但是new的操作上我们理解是：</p><ul><li>创建内存M</li><li>在内存M上初始化doMain对象</li><li>将内存M的地址指向变量doMain</li></ul><p>但是实际上优化后(指令重排)的执行路径可能是这样的：</p><ul><li>创建内存M</li><li>将内存M的地址指向变量doMain</li><li>将内存M的地址指向变量doMain</li></ul><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98.png?raw=true" alt="%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们在做并发编程的的时候会考虑到原子性丶可见性和有序性，在宏观上会考虑到安全性丶活跃性和性能；&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="可见性/原子性/有序性" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    
      <category term="安全性/活跃性/性能" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%80%A7-%E6%B4%BB%E8%B7%83%E6%80%A7-%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized总结</title>
    <link href="http://yoursite.com/2019/01/20/Synchronized%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/20/Synchronized总结/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-06-12T05:04:55.376Z</updated>
    
    <content type="html"><![CDATA[<p>要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等。</p><a id="more"></a><ul><li><h2 id="Synchronized的升级过程"><a href="#Synchronized的升级过程" class="headerlink" title="Synchronized的升级过程"></a><strong>Synchronized的升级过程</strong></h2><p><strong>Synchronized的升级顺序是 无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁，顺内不可逆，(Java SE 1.6中为了减少获得锁和释放锁带来的 性能消耗而引入的偏向锁和轻量级锁)</strong></p><h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a><strong>偏向锁：</strong></h3><p>当一个线程访问<strong>同步代码块</strong>并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁，以后该线程在进入和退出该同步代码块时不需要花费 CAS 操作来加锁和解锁，而只需简单的<strong>测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁(当前线程的线程ID)</strong>，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果偏向锁标识是1，<strong>则使用 CAS 进行锁获取</strong>，偏向锁标识不是1，则尝试使用 <strong>CAS 将对象头的偏向锁指向当前线程</strong>，上述两种CAS获取锁的操作，如果<strong>CAS操作成功则获取到了偏向锁</strong>，<strong>失败则代表出现了锁竞争，需要锁撤销操作</strong>。</p><h3 id="锁撤销："><a href="#锁撤销：" class="headerlink" title="锁撤销："></a><strong>锁撤销：</strong></h3><p>偏向锁使用了一种等到<strong>竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要<strong>等待拥有偏向锁的线程到达全局安全点</strong>（在这个时间点上没有字节码正在执行），会首先<strong>暂停拥有偏向锁的线程</strong>，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁的对象的对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行<strong>(判断是否需要持有锁)</strong>，遍历偏向对象的锁记录，查看使用情况，如果还需要持有偏向锁，则偏向锁<strong>升级为轻量级锁</strong>，如果不需要持有偏向锁了，则将锁对象恢复成无锁状态，最后唤醒暂停的线程。</p><h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h3><p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋来获取锁</strong>，<strong>自旋有一定次数，如果超过设置自旋的次数则升级到重量级锁</strong>，<strong>或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转</strong>。</p><h3 id="轻量级锁解锁："><a href="#轻量级锁解锁：" class="headerlink" title="轻量级锁解锁："></a><strong>轻量级锁解锁</strong>：</h3><p>轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。<strong>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。</p><p><strong>例如：</strong>T1线程持有锁，T2线程自旋，但是T2线程自旋最大次数已经过了，则自旋失败，进行锁升级到重量级锁，T2线程阻塞，这时T1执行完了同步代码块，进行轻量级锁解锁，但是这时Mark Word中的标志位已经从原来的00(偏向锁)变成了10(中练级锁)，解锁会CAS失败，T1会进行解锁(释放监视器，释放锁)，并唤醒线程T2.</p><h3 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h3><p>Synchronized是非公平锁,Synchronized在线程进入阻塞队列时，等待的线程会先尝试获取锁，如果获取不到就进入阻塞队列，这明显对于已经进入队列的线程是不公平的。</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><strong>优缺点：</strong></h3><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加解锁不需要过多的资源消耗，和非同步方法的相比仅仅是<strong>纳秒</strong>的差距</td><td align="center">如果存在所竞争，会有额外的锁撤销操作</td><td align="center">适用于只有一个线程访问的场景</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争线程不会阻塞，会自旋，减少了上线文切换。</td><td align="center">如果始终得不到锁，会消耗cpu资源</td><td align="center">追求响应时间，同步代码块多为计算，执行快的场景</td></tr><tr><td align="center">重量级锁</td><td align="center">没啥优点</td><td align="center">线程阻塞响应时间慢</td><td align="center">同步代码块执行时间较长的场景使用</td></tr></tbody></table><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a><strong>流程图：</strong></h3><p><img src="https://github.com/lantaoGitHub/photos/blob/master/Concurrency/Synchronized%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true" alt></p></li></ul><ul><li><h2 id="Synchronized-的使用"><a href="#Synchronized-的使用" class="headerlink" title="Synchronized 的使用"></a><strong>Synchronized 的使用</strong></h2><p><strong>1:</strong> <strong>Synchronized</strong> 是java的<strong>内置锁</strong>，也是<strong>排它锁</strong>和<strong>非公平锁</strong>，<strong>排它锁</strong>也就是当前线程获取锁后，其他线程都会阻塞挂起 ，<strong>非公平锁</strong>是在线程后去锁的时候会先尝试后去锁，获取不到在进行阻塞。</p><p><strong>2:</strong> <strong>Synchronized</strong> 是如何保证 ‘原子性’ 的？是因为进入 Synchronized 块的内存语义是把 Synchronized 块内使用的 ‘工作内存清除’， 这样在使用共享变量时就会直接存主内存中获取并复制到工作你内存中，在退出 Synchronized 语句块时 会把 工作内存中计算过的 ‘共享变量’ 更新到主内存中。</p><p><strong>3:</strong> 获取到 Synchronized 锁 ，<strong>都是 ‘对象锁’而非’代码块锁’ (锁的都是对象或类，而不是某个方法)</strong>，因此 Synchronized 是<strong>具有可重入性</strong>，在获取到该对象锁后可以不用再次获取该对象其他方法的锁，直接进入。</p><p><strong>4:</strong> 如果是 <strong>Synchronized 用在 static 上</strong>， 就代表是<strong>类锁(.class)</strong>，<strong>无论创建多少个对象都不可行</strong>；</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a><strong>使用方法：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码块 锁的是括号里的对象</span></span><br><span class="line">  Synchronized(需要锁的对象)&#123;</span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 普通方法 锁的是当前对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Synchronized <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//是临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 静态方法 锁的是当前的类(.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Synchronized <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//临界区</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="wait-notify-notifyAll-的使用"><a href="#wait-notify-notifyAll-的使用" class="headerlink" title="wait/notify/notifyAll 的使用"></a>wait/notify/notifyAll 的使用</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>wait和sleep区别在于<strong>wait会释放锁</strong>， 但是<strong>sleep不会释放锁</strong> ，sleep会导致线程阻塞挂起。</p><p><strong>wait/wait(timeout)/notify/notifyAll</strong> 方法仅可以在<strong>获取到锁后</strong>才可以使用。</p><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p><strong>wait：</strong> 线程等待。</p><p><strong>wait(time)：</strong> 线程等待，如果时间超过了设置的time，则继续执行。</p><p><strong>notify：</strong> <strong>随机唤醒一个</strong>等待的线程。</p><p><strong>notifyAll：</strong> 唤醒全部等待线程。</p><h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Auther</span>: concurrenncy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-03-25 16:43</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Company</span>: 随行付支付有限公司</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@maill</span>: lan_tao@suixingpay.com</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: wait 和 sleep 区别在于 wait会释放锁， 但是 sleep 不会 ，sleep会导致线程阻塞挂起</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotifyTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 创建线程 thread1</span></span><br><span class="line">          Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                      <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                          obj.wait();</span><br><span class="line">                      &#125;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, <span class="string">"thread1"</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 创建线程 thread2</span></span><br><span class="line">          Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"   begin wait..."</span>);</span><br><span class="line">                      <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                          obj.wait();</span><br><span class="line">                      &#125;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"   end wait..."</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, <span class="string">"thread2"</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 启动</span></span><br><span class="line">          thread1.start();</span><br><span class="line">          thread2.start();</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 睡眠一秒</span></span><br><span class="line">              Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 如果调用 notify 的线程未获取 对象锁，在调用 notify 的时候会抛出 java.lang.IllegalMonitorStateException 异常</span></span><br><span class="line">          <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">              <span class="comment">// 唤醒 使用 obj 调用 wait 方法的其中一个线程 (随机)</span></span><br><span class="line">              obj.notify();</span><br><span class="line">              <span class="comment">// 唤醒 使用呢 obj 调用 wait 方法的所有线程</span></span><br><span class="line">              obj.notifyAll();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要理解Synchronized，首先要清楚偏向锁，轻量级锁和重量级锁，在使用方面需要有wait/wait(time)/notify/notifyAll等。&lt;/p&gt;
    
    </summary>
    
      <category term="锁" scheme="http://yoursite.com/categories/%E9%94%81/"/>
    
    
      <category term="偏向锁/轻量级锁/重量级锁" scheme="http://yoursite.com/tags/%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    
      <category term="synchronized使用" scheme="http://yoursite.com/tags/synchronized%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
